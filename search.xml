<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常见的Web攻击及防御办法 - 重学计算机网络系列(5)</title>
      <link href="/2020/01/08/chang-jian-de-web-gong-ji-ji-fang-yu-ban-fa-chong-xue-ji-suan-ji-wang-luo-xi-lie-5/"/>
      <url>/2020/01/08/chang-jian-de-web-gong-ji-ji-fang-yu-ban-fa-chong-xue-ji-suan-ji-wang-luo-xi-lie-5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2019/12/27/16f46871006b6c39?w=1144&h=439&f=png&s=45298" alt=""></p><h1 id="Web攻击分类"><a href="#Web攻击分类" class="headerlink" title="Web攻击分类"></a>Web攻击分类</h1><p>简单的HTTP协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用HTTP协议的<strong>服务器和客户端</strong>，以及运行在服务器上的<strong>Web应用</strong>等资源才是攻击目标。</p><p>web应用的攻击模式有以下两种</p><ul><li>主动攻击(主要攻击服务器上的资源)<ul><li>SQL注入攻击</li><li>OS命令注入攻击</li><li>其他</li></ul></li><li>被动攻击(主要攻击用户的资源和权限)  <ul><li>跨站脚本攻击</li><li>跨站点请求伪造</li><li>点击劫持（与跨站请求伪造手法相似）</li><li>HTTP首部注入攻击</li><li>其他<h1 id="跨站脚本攻击（XSS）"><a href="#跨站脚本攻击（XSS）" class="headerlink" title="跨站脚本攻击（XSS）"></a>跨站脚本攻击（XSS）</h1>跨站脚本攻击（XSS）是指通过存在安全漏洞的Web网站注册用户的浏览器内<strong>运行非法的HTML标签或JavaScript</strong>进行的一种攻击。动态创建的HTML部分有可能隐藏着安全漏洞。就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击。<strong>目的：利用网站漏洞从用户那里恶意盗取信息</strong>。</li></ul></li></ul><p>XSS攻击，通常指黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。在一开始，这种攻击的演示案例是跨域的，所以叫做“跨站脚本”。但是发展到今天，由于JavaScript的强大功能以及网站前端应用的复杂化，是否跨域已经不再重要。但是由于历史原因，XSS这个名字却一直保留下来。</p><h2 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h2><ul><li>反射型XSS（非持久型XSS）</li><li>DOM型XSS（非持久性XSS）</li><li>存储型XSS（持久性XSS攻击）</li></ul><h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><ul><li>攻击构造出特殊的 URL ，其中包含恶意代码。（这个恶意代码诸如第三方的JS或document.cookie等）</li><li>用户被诱导打开带有恶意代码的 URL，服务器端将恶意代码从 URL 中取出当做参数处理，然后返回给用户带有恶意代码的数据。</li><li>用户浏览器接收到响应解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户敏感数据发送给攻击者，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ul><h2 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h2><blockquote><p>从效果上来说也是反射型XSS，单独划分出来，是因为DOM Based XSS的形成原因比较特别，发现它的安全专家专门提出了这种类型的XSS。出于历史原因，也就把它单独作为一个分类了。</p></blockquote><ul><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户被诱导打开带有恶意代码的 URL。</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ul><h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>存储型 XSS 跟 反射型 XSS 的区别是：存储型 XSS 的恶意代码存在服务器上，反射型 XSS 的恶意代码存在 URL 里。<strong>它是最危险的一种跨站脚本</strong>。比反射性 XSS 和 DOM 型 XSS 都更有隐蔽性，因为它不需要用户手动触发。<strong>任何允许用户存储数据的 Web 程序都可能存在存储型 XSS 漏洞</strong>。若某个页面遭受存储型 XSS 攻击，<strong>所有</strong>访问该页面的用户都会被 XSS 攻击。</p><ul><li>攻击者把恶意代码提交到目标网站的服务器中。</li><li>用户打开目标网站，网站服务器端把带有恶意代码的数据取出，当做正常数据返回给用户。</li><li>用户浏览器接收到响应解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户敏感数据发送给攻击者，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ul><h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><ul><li>浏览器自带防御（X-XSS-Protection）<br>HTTP X-XSS-Protection 响应头是 Internet Explorer，Chrome 和 Safari 的一个功能，当检测到跨站脚本攻击(XSS)时，浏览器将停止加载页面。<code>其原理是检查 URL 和 DOM 中元素的相关性，但这并不能完全防止反射型 XSS，而且也并不是所有浏览器都支持 X-XSS-Protection。</code><pre><code>X-XSS-Protection: 0     禁止XSS过滤。     </code></pre></li></ul><p>X-XSS-Protection: 1<br>启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。  </p><p>X-XSS-Protection: 1; mode=block<br>启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。  </p><p>X-XSS-Protection: 1; report=<reporting-uri><br>启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。  </p><pre><code>- 转义  XSS攻击主要是通过构造特殊字符来注入脚本。所以在客户端与服务端都进行输入检测，然后对用户输入的数据进行转义。</code></pre><p>function escapeHTML(str) {<br>    if (!str) return ‘’;<br>    str = str.replace(/&amp;/g, “&amp;”);<br>    str = str.replace(/&lt;/g, “&lt;”);<br>    str = str.replace(/&gt;/g, “&gt;”);<br>    str = str.replace(/“/g, “&quot;”);<br>    str = str.replace(/‘/g, “&#39;”);<br>    return str;<br>};</p><pre><code>- 过滤  在富文本中因为需要保留 HTML ，所以我们不能使用转义的方法防御 XSS 攻击，这里使用过滤的方式防御 XSS 攻击，也就是通过只使用白名单允许的 HTML 标记及其属性，来防御攻击。- 内容安全策略（csp）   实质是白名单策略，开发者明确告诉客户端，哪些外部资源可以加载和执行，大大增强了网页的安全性。# 跨站请求伪造（CSRF）叫做“攻击者伪造请求”，更好理解。- 用户登录一些官方网站。- 攻击者伪造一个链接或事件，诱导用户去点击。- 用户触发事件后（点击或者触发其他什么事件），执行操作。用户执行了表面的操作，实际上攻击者利用用户触发这个事件，伪造用户在官方网站做一些事情。## 例子- 张三登录了购物网站。- 之后张三不小心点击了攻击者的恶意链接。- 在点击链接之后，张三的购物车被清空。此时，张三还并不知情。## 分析攻击者为什么能成功- 张三如果第一次登录购物网站，网站要求用户输入用户名和命名，验证正确才能进入。- 此时购物网站在张三登录成功之后，会给张三Cookie（里面有Session ID），下次张三登录的时候可以不必输入用户名密码，靠着Session ID 就可以直接进入。- 若张三点击了攻击者的事件之后，其实就是伪造用户去进入购物网站然后执行一些操作。（利用张三的权限去做事情）- 此时购物网站的服务器会认为是张三本人在做的一些操作，因为有Session ID。## CSRF特点- 攻击一般发起在第三方网站，而不是被攻击的网站。- 攻击是利用受害者在被攻击网站的登录凭证，冒充受害者提交操作，仅仅是“冒用”，而不是直接窃取数据。- 攻击者预测出被攻击的网站接口的所有参数，成功伪造请求。## 防御方法- SameSite 属性     Cookie 的 SameSite 属性用来限制第三方 Cookie，从而减少安全风险，可以用来防止 CSRF 攻击和用户追踪。- 同源检测  在 HTTP 协议中，每一个异步请求都会携带两个 Header ，用于标记来源域名：    - Origin Header    - Referer Header 这两个 Header 在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个 Header 中的域名，确定请求的来源域。通过校验请求的该字段，我们能知道请求是否是从本站发出的。我们可以**通过拒绝非本站发出的请求**，来避免了 CSRF 攻击。# 点击劫持点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的`iframe`，覆盖在一个网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的`iframe`页面。通过调整`iframe`页面的位置，可以诱使用户恰好点击在`iframe`页面的一些功能性按钮上。原理很简单：- 通过`z-index`属性让其位于最上层。- 通过`opacity`属性让其透明度为0。&gt;点击劫持攻击与CSRF攻击（详见“跨站点请求伪造”一章）有异曲同工之妙，都是在用户不知情的情况下诱使用户完成一些动作。但是在CSRF攻击的过程中，如果出现用户交互的页面，则攻击可能会无法顺利完成。与之相反的是，点击劫持没有这个顾虑，它利用的就是与用户产生交互的页面。## Flash点击劫持案例：- 攻击者制作了一个Flash游戏，并诱使用户来玩这个游戏。这个游戏就是让用户去点击“CLICK”按钮，每次点击后这个按钮的位置都会发生变化。- 在其上隐藏了一个看不见的iframe。- 攻击通过诱导用户鼠标点击的位置，能够完成一些较为复杂的流程。- 最终通过这一步步的操作，打开了用户的摄像头。## 其他的点击劫持- 图片覆盖攻击- 拖拽劫持- 触屏劫持（发生在智能手机上的攻击）# HTTP首部注入攻击HTTP首部注入攻击（HTTP Header Injection）是指攻击者通过在**响应首部字段**内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。&gt;向首部主体内添加内容的攻击称为HTTP响应截断攻击（HTTP Response Splitting Attack）。如下所示，Web应用有时会把从外部接收到的数值，赋给响应首部字段`Location`和`Set-Cookie`。</code></pre><p>Loaction: <a href="http://www.example.com/a.cgi?q=12345" target="_blank" rel="noopener">http://www.example.com/a.cgi?q=12345</a><br>Set-Cookie: UID=12345</p><pre><code>## 危害- 设置任何Cookie信息- 重定向至任意URL- 显示任意的主体（HTTP响应截断攻击）# SQL注入攻击&gt;注入攻击的本质，是把用户输入的数据当做代码执行。这里有两个关键条件，**第一个是用户能够控制输入；第二个是原本程序要执行的代码，拼接了用户输入的数据**。所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。&gt;比如先前的很多影视网站泄露VIP会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到SQL注入式攻击．## 如何防御SQL注入攻击- 使用预编译语句，绑定变量。`（最佳方式）    `     使用预编译的SQL语句，SQL语句的语义不会发生改变。在SQL语句中，变量用`？`表示，攻击者无法改变SQL的结构，在上面的例子中，即使攻击者插入类似于`tom&#39; or&#39;1&#39;=&#39;1`的字符串，也只会将此字符串当做`username`来查询。- 使用安全的存储过程对抗SQL注入。          使用存储过程的效果和使用预编语句译类似，其区别就是存储过程需要先将SQL语句定义在数据库中。但需要注意的是，存储过程中也可能会存在注入问题，因此应该尽量避免在存储过程内使用动态的SQL语句。如果无法避免，则应该使用`严格的输入过滤`或者是`编码函数`来处理用户的输入数据。- 检查数据类型  检查输入数据的数据类型，在很大程度上可以对抗SQL注入。比如用户在输入邮箱时，必须严格按照邮箱的格式；输入时间、日期时，必须严格按照时间、日期的格式，等等，都能避免用户数据造成破坏。但数据类型检查并非万能，如果需求就是需要用户提交字符串，比如一段短文，则需要依赖其他的方法防范SQL注入。- 使用安全函数- 使用最小权限原则，避免Web应用直接使用root、dbowner等高权限账户直接连接数据库。    如果有多个不同的应用在使用同一个数据库，则也应该为每个应用分配不同的账户。Web应用使用的数据库账户，不应该有创建自定义函数、操作本地文件的权限。# OS命令注入攻击OS命令注入攻击（OS Command Injection）是指通过Web应用，执行非法的操作系统命令达到攻击的目的。**只要在能调用Shell函数的地方就有存在被攻击的风险**。OS命令注入攻击可以向Shell发送命令，让Windows或Linux操作系统的命令行启动程序。也就是说，通过OS注入攻击可执行OS上安装着的各种程序。## 产生的原因- 使用了内部调用Shell的函数（system、open等）- 将倍加传入的参数传递给内部调用的shell的函数- 参数中shell的元字符没有被转义## 防御对策- 选择不调用OS命令的实现方法。不调用利用shell的功能，既能杜绝了OS命令注入漏洞混入的可能性，又消除了调用OS命令的而系统开销，能够从多方面提高应用的性能。- 不将外界输入的字符串传递给命令行参数。- 使用安全的函数对传递给OS命令参数进行转义。# 其他一些Web攻击## 目录遍历攻击目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历（PathTraversal）攻击。通过Web应用对文件处理操作时，在由外部指定文件名的处理存在疏漏的情况下，用户可使用．../等相对路径定位到/etc/passed等绝对路径上，因此服务器上任意的文件或文件目录皆有可能被访问到。这样一来，就有可能非法浏览、篡改或删除Web服务器上的文件。固然存在输出值转义的问题，但更应该关闭指定对任意文件名的访问权限。## 远程文件包含漏洞远程文件包含漏洞（Remote File Inclusion）是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。这主要是PHP存在的安全漏洞，对PHP的`include或require`来说，这是一种可通过设定，指定外部服务器的URL作为文件名的功能。但是，该功能太危险，PHP5.2.0之后默认设定此功能无效。固然存在输出值转义的问题，但更应控制对任意文件名的指定。</code></pre><p>源代码：<br><a href="http://example.com/foo.php?mod=news.php" target="_blank" rel="noopener">http://example.com/foo.php?mod=news.php</a></p><p>经过攻击后：<br><a href="http://example.com/foo.php?mod=http://hackr.jp/cmd.php&amp;cmd=1s" target="_blank" rel="noopener">http://example.com/foo.php?mod=http://hackr.jp/cmd.php&amp;cmd=1s</a></p><pre><code>攻击者通过把要引入的文件替换成自己的文件，就能攻击到服务器了。## 不正确的错误消息处理不正确的错误消息处理（Error Handling Vulnerability）的安全漏洞是指，Web应用的**错误信息内包含对攻击者有用的信息**。与Web应用有关的主要错误信息如下所示。- Web应用抛出的错误消息- 数据库等系统抛出的错误消息Web应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示。## 开放重定向开放重定向（Open Redirect）是一种对指定的任意URL作重定向跳转的功能。而与此功能相关联的安全漏洞是指，假如指定的重定向URL到某个具有恶意的Web网站，那么用户就会被诱导至那个Web网站。</code></pre><p>原URL：<br><a href="http://example.com/?redirect=http://www.tricorder.jp" target="_blank" rel="noopener">http://example.com/?redirect=http://www.tricorder.jp</a></p><p>被攻击后：<br><a href="http://example.com/?redirect=http://hackr.jp" target="_blank" rel="noopener">http://example.com/?redirect=http://hackr.jp</a></p><p>```<br>用户看到URL后原以为访问example.com，不料实际上被诱导至hackr.jp这个指定的重定向目标。</p><p>可信度高的Web网站如果开放重定向功能，则很有可能被攻击者选中并用来作为钓鱼攻击的跳板。</p><h2 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h2><p>密码破解攻击（Password Cracking）即算出密码，突破认证。攻击不仅限于Web应用，还包括其他的系统（如FTP或SSH等）。有以下几种破解方法：</p><ul><li>穷举法<br>对所有密钥集合构成的密钥空间（Keyspace）进行穷举。即，用所有可行的候选密码对目标的密码系统试错，用以突破验证的一种攻击。</li><li>字典攻击<br>利用事先收集好的候选密码（经过各种组合方式后存入字典），枚举字典中的密码，尝试通过认证的一种攻击手法。<blockquote><p>字典攻击中有一种利用其他Web网站已泄露的ID及密码列表进行的攻击。很多用户习惯随意地在多个Web网站使用同一套ID及密码，因此攻击会有相当高的成功几率</p></blockquote></li></ul><h2 id="DoS攻击"><a href="#DoS攻击" class="headerlink" title="DoS攻击"></a>DoS攻击</h2><p>DoS攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS攻击的对象不仅限于Web网站，还包括网络设备及服务器等。</p><p>有两种DOS攻击方式：</p><ul><li>集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态。（海量请求导致服务器瘫痪,服务器很难分辨何为正常请求，何为攻击请求，因此很难防止DoS攻击。）</li><li>通过攻击安全漏洞使服务停止。</li></ul><blockquote><p>多台计算机发起的DoS攻击称为DDoS攻击（DistributedDenial of Service attack）。DDoS攻击通常利用那些感染病毒的计算机作为攻击者的攻击跳板。</p></blockquote><h2 id="后门程序"><a href="#后门程序" class="headerlink" title="后门程序"></a>后门程序</h2><p>后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。</p><p>通常的后门程序分为以下3种类型。</p><ul><li>开发阶段作为Debug调用的后门程序</li><li>开发者为了自身利益植入的后门程序</li><li>攻击者通过某种方法设置的后门程序</li></ul><p>可通过监视进程和通信的状态发现被植入的后门程序。但设定在Web应用中的后门程序，由于和正常使用时区别不大，通常很难发现。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li>《图解HTTP》</li><li>吴瀚清《白帽子讲Web安全》</li><li><a href="https://segmentfault.com/a/1190000020402185" target="_blank" rel="noopener">跨站脚本攻击—XSS</a></li><li><a href="https://segmentfault.com/a/1190000021114673" target="_blank" rel="noopener">跨站请求伪造—CSRF</a></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我的计算机网络学习之旅暂时就结束了。因为大四还在实习，白天还需要完成公司的任务，只能在晚上或者周末去公司自主学习，前前后后大约有花一两个月的时间。收获很多，这种感觉与当初上计算机网络课的感觉完全不一样，当时上了也就上了，知识都是零零散散的，都没有去串联起来，导致记得不深刻。如今花了心思去整理总结后，有种融会贯通的感觉，在<strong>Chrome调试，项目中前后端对接，性能优化</strong>方面的认知更为巩固和深刻。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS，HTTP追加协议 - 重学计算机网络系列(4)</title>
      <link href="/2020/01/08/https-http-zhui-jia-xie-yi-chong-xue-ji-suan-ji-wang-luo-xi-lie-4/"/>
      <url>/2020/01/08/https-http-zhui-jia-xie-yi-chong-xue-ji-suan-ji-wang-luo-xi-lie-4/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2019/12/27/16f46871006b6c39?w=1144&h=439&f=png&s=45298" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>本篇文章主要讲HTTPS，HTTP和HTTPS区别，认证，SPDY的AJAX与Comet，Websocket<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1></li></ul><h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><h3 id="通信使用明文可能会被窃听"><a href="#通信使用明文可能会被窃听" class="headerlink" title="通信使用明文可能会被窃听"></a>通信使用明文可能会被窃听</h3><p>由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密。即，HTTP报文使用明文（指未经过加密的报文）方式发送。</p><blockquote><p>按TCP/IP协议族的工作机制，通信内容在<strong>所有</strong>的通信线路上都有可能遭到窥视。</p></blockquote><blockquote><p>即使已经过加密处理的通信，也会被窥视到通信内容，这点和未加密的通信是相同的。只是说如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息本身还是会被看到的。</p></blockquote><h4 id="如何防止被窃听"><a href="#如何防止被窃听" class="headerlink" title="如何防止被窃听"></a>如何防止被窃听</h4><p>最为普及的就是加密技术。</p><ul><li>通信的加密<br>HTTP协议中没有加密机制，但可以通过和<strong>SSL</strong>（Secure Socket Layer，安全套接层）或<strong>TLS</strong>（Transport Layer Security，安全传输层协议）的组合使用，加密HTTP的通信内容。</li></ul><p><strong>用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTPover SSL。</strong></p><ul><li>内容的加密<br>由于HTTP协议中没有加密机制，那么就对HTTP协议传输的内容本身加密。即把HTTP报文里所含的内容进行加密处理。</li></ul><p>诚然，为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。主要应用在Web服务中。有一点必须引起注意，由于该方式不同于SSL或TLS将整个通信线路加密处理，所以内容仍有被篡改的风险。</p><h3 id="不验证通信方的身份"><a href="#不验证通信方的身份" class="headerlink" title="不验证通信方的身份"></a>不验证通信方的身份</h3><p>HTTP协议中的请求和响应不会对通信方进行确认。</p><h4 id="任何人都可以发起请求"><a href="#任何人都可以发起请求" class="headerlink" title="任何人都可以发起请求"></a>任何人都可以发起请求</h4><p>在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）。不确认通信方，会存在以下各种隐患。</p><ul><li>无法确定请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的Web服务器。</li><li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。</li><li>无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限。</li><li>无法判定请求是来自何方、出自谁手。</li><li>即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击（Denial of Service，拒绝服务攻击）。</li></ul><h4 id="如何验证身份呢"><a href="#如何验证身份呢" class="headerlink" title="如何验证身份呢"></a>如何验证身份呢</h4><p>虽然使用HTTP协议无法确定通信方，但如果使用SSL则可以。SSL不仅提供加密处理，而且还使用了一种被称为<strong>证书</strong>的手段，可用于确定方。</p><p>证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。</p><h3 id="报文可能会被篡改"><a href="#报文可能会被篡改" class="headerlink" title="报文可能会被篡改"></a>报文可能会被篡改</h3><p>由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。</p><blockquote><p>比如，从某个Web网站上下载内容，是无法确定客户端下载的文件和服务器上存放的文件是否前后一致的。文件内容在传输途中可能已经被篡改为其他的内容。即使内容真的已改变，作为接收方的客户端也是觉察不到的。像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middleattack,MITM）。</p></blockquote><h4 id="如何防止被篡改"><a href="#如何防止被篡改" class="headerlink" title="如何防止被篡改"></a>如何防止被篡改</h4><p><strong>虽然有使用HTTP协议（头部字段Content-MD5）确定报文完整性的方法，但事实上并不便捷、可靠</strong>。其中常用的是MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法。</p><h2 id="HTTPS-HTTP-加密-认证-完整性保护"><a href="#HTTPS-HTTP-加密-认证-完整性保护" class="headerlink" title="HTTPS = HTTP + 加密 + 认证 + 完整性保护"></a>HTTPS = HTTP + 加密 + 认证 + 完整性保护</h2><p>如果在HTTP协议通信过程中使用未经加密的明文，比如在Web页面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了。</p><p>另外，对于HTTP来说，服务器也好，客户端也好，都是没有办法确认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性。</p><p>为了统一解决上述这些问题，需要在HTTP上再加入加密处理和认证等机制。<strong>我们把添加了加密及认证机制的HTTP称为HTTPS（HTTP Secure）</strong>。</p><h3 id="HTTPS是身披SSL外壳的HTTP"><a href="#HTTPS是身披SSL外壳的HTTP" class="headerlink" title="HTTPS是身披SSL外壳的HTTP"></a>HTTPS是身披SSL外壳的HTTP</h3><p>HTTPS并非是应用层的一种新协议。只是<strong>HTTP通信接口部分</strong>用SSL（Secure Socket Layer）和TLS（TransportLayer Security）协议代替而已。</p><p>通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/24/16f370728f5c8d1a?w=490&h=211&f=png&s=24065" alt=""></p><blockquote><p>SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。可以说SSL是当今世界上应用最为广泛的网络安全技术。</p></blockquote><h2 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h2><ul><li>HTTPS协议需要到CA（证书颁发机构）申请证书，一般免费证书很少，需要交费。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由HTTP+SSL协议构建的可进行加密传输、身份认证的网络协议，可以有效的防止运营商劫持，解决了防劫持的一个大问题，比http协议安全。</li></ul><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><h2 id="何为认证"><a href="#何为认证" class="headerlink" title="何为认证"></a>何为认证</h2><p>计算机本身无法判断坐在显示器前的使用者的身份。进一步说，也无法确认网络的那头究竟有谁。可见，为了弄清究竟是谁在访问服务器，就得让对方的客户端自报家门。</p><p>为确认用户是否真的具有访问系统的权限，就需要核对“登录者本人才知道的信息”、“登录者本人才会有的信息”</p><p>核对的信息通常是指以下这些。</p><ul><li>密码：只有本人才会知道的字符串信息。</li><li>动态令牌：仅限本人持有的设备内显示的一次性密码。</li><li>数字证书：仅限本人（终端）持有的信息。</li><li>生物认证：指纹和虹膜等本人的生理信息。</li><li>IC卡等：仅限本人持有的信息。</li></ul><h3 id="HTTP-1-1使用的认证方式"><a href="#HTTP-1-1使用的认证方式" class="headerlink" title="HTTP/1.1使用的认证方式"></a>HTTP/1.1使用的认证方式</h3><ul><li>BASIC认证（基本认证）</li><li>DIGEST认证（摘要认证）</li><li>SSL客户端认证</li><li>FormBase认证（基于表单认证）</li></ul><h2 id="BASIC认证"><a href="#BASIC认证" class="headerlink" title="BASIC认证"></a>BASIC认证</h2><p>BASIC认证（基本认证）是从HTTP/1.0就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是Web服务器与通信客户端之间进行的认证方式。</p><ul><li>步骤1：当请求的资源需要BASIC认证时，服务器会随状态码401 Authorization Required，返回带WWW-Authenticate首部字段的响应。该字段内包含认证的方式（BASIC）及Request-URI安全域字符串（realm）。</li><li>步骤二： 接收到状态码401的客户端为了通过BASIC认证，需要将用户ID及密码发送给服务器。发送的字符串内容是由用户ID和密码构成，两者中间以冒号（:）连接后，再经过Base64编码处理。当用户代理为浏览器时，用户仅需输入用户ID和密码即可，之后，浏览器会自动完成到Base64编码的转换工作。</li><li>步骤3：步骤3： 接收到包含首部字段Authorization请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含Request-URI资源的响应。</li></ul><blockquote><p>BASIC认证虽然采用Base64编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，<strong>由于明文解码后就是用户ID和密码，在HTTP等非加密通信的线路上进行BASIC认证的过程中，如果被人窃听，被盗的可能性极高</strong>。</p></blockquote><blockquote><p>BASIC认证使用上不够便捷灵活，且达不到多数Web网站期望的安全性等级，因此它并不常用。</p></blockquote><h2 id="DIGEST认证"><a href="#DIGEST认证" class="headerlink" title="DIGEST认证"></a>DIGEST认证</h2><p>为弥补BASIC认证存在的弱点，从HTTP/1.1起就有了DIGEST认证。<strong>DIGEST认证同样使用质询/响应的方式，但不会像BASIC认证那样直接发送明文密码</strong>。</p><blockquote><p>所谓质询响应方式是指，一开始客户端会先发送认证要求给服务端，服务端发送质询码给客户端，接着客户端使用接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。</p></blockquote><ul><li>步骤1：请求需认证的资源时，服务器会随着状态码401 Authorization Required，返回带WWW-Authenticate首部字段的响应。</li><li>步骤2： 接收到401状态码的客户端，返回的响应中包含DIGEST认证必须的首部字段Authorization信息。 </li><li>步骤3： 接收到包含首部字段Authorization请求的服务器，会确认认证信息的正确性。认证通过后则返回包含Request-URI资源的响应。</li></ul><blockquote><p>DIGEST认证提供了高于BASIC认证的安全等级，但是和HTTPS的客户端认证相比仍旧很弱。DIGEST认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。</p></blockquote><h2 id="SSL客户端认证"><a href="#SSL客户端认证" class="headerlink" title="SSL客户端认证"></a>SSL客户端认证</h2><p>从使用用户ID和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为。但如果<strong>用户ID和密码被盗</strong>，就很有可能被第三者冒充。利用<strong>SSL客户端认证</strong>则可以避免该情况的发生。</p><p>SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。凭借客户端证书（在HTTPS一章已讲解）认证，服务器可确认访问是否来自已登录的客户端。</p><ul><li>步骤1： 接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书。</li><li>步骤2： 用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate报文方式发送给服务器。</li><li>步骤3： 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，<strong>然后开始HTTPS加密通信</strong>。</li></ul><blockquote><p>使用SSL客户端认证需要用到客户端证书。而客户端证书需要向认证机构购买。</p></blockquote><h2 id="表单认证"><a href="#表单认证" class="headerlink" title="表单认证"></a>表单认证</h2><p>基于表单的认证方法并不是在HTTP协议中定义的。客户端会向服务器上的Web应用程序发送登录信息（Credential），按登录信息的验证结果认证。</p><p>多数情况下，输入已事先登录的用户ID（通常是任意字符串或邮件地址）和密码等登录信息后，发送给Web应用程序，基于认证结果来决定认证是否成功。</p><h3 id="认证多半为表单认证"><a href="#认证多半为表单认证" class="headerlink" title="认证多半为表单认证"></a>认证多半为表单认证</h3><p>由于使用上的便利性及安全性问题，HTTP协议标准提供的BASIC认证和DIGEST认证几乎不怎么使用。另外，SSL客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及。</p><h3 id="Session-会话-管理及Cookie应用"><a href="#Session-会话-管理及Cookie应用" class="headerlink" title="Session(会话)管理及Cookie应用"></a>Session(会话)管理及Cookie应用</h3><blockquote><p>基于表单认证本身是通过服务器端的Web应用，将客户端发送过来的用户ID和密码与之前登录过的信息做匹配来进行认证的。</p></blockquote><blockquote><p>但鉴于HTTP是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用Cookie来管理Session，以弥补HTTP协议中不存在的状态管理功能。</p></blockquote><ul><li>步骤1： 客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方法把请求发送给服务器。而这时，会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送。</li><li>步骤2： 服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端。</li><li>步骤3： 客户端接收到从服务器端发来的Session ID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以SessionID也随之发送到服务器。服务器端可通过验证接收到的Session ID识别用户和其认证状态。</li></ul><h1 id="基于HTTP的功能追加协议"><a href="#基于HTTP的功能追加协议" class="headerlink" title="基于HTTP的功能追加协议"></a>基于HTTP的功能追加协议</h1><p>在建立HTTP标准规范时，制订者主要想把HTTP当作传输HTML文档的协议。随着时代的发展，Web的用途更具多样性，比如演化成在线购物网站、SNS（SocialNetworking Service，社交网络服务）、企业或组织内部的各种管理工具，等等。</p><p>而这些网站所追求的功能可通过Web应用和脚本程序实现。即使这些功能已经满足需求，在性能上却未必最优，这是因为HTTP协议上的限制以及自身性能有限。</p><p>HTTP功能上的不足可通过创建一套全新的协议来弥补。可是目前基于HTTP的Web浏览器的使用环境已遍布全球，因此无法完全抛弃HTTP。有一些新协议的规则是基于HTTP的，并在此基础上添加了新的功能。</p><h2 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h2><p>Google在2010年发布了SPDY，其开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间（50%）。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在Facebook和Twitter等SNS网站上，短的时间内就会发生大量的内容更新。</p><p>为了尽可能实时地显示这些更新的内容，服务器上一有内容更新，就需要直接把那些内容反馈到客户端的界面上。虽然看起来挺简单的，但HTTP却无法妥善地处理好这项任务。</p><p>使用HTTP协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。</p><h3 id="HTTP的瓶颈"><a href="#HTTP的瓶颈" class="headerlink" title="HTTP的瓶颈"></a>HTTP的瓶颈</h3><ul><li>一条连接上只可发送一个请求。</li><li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。</li><li>请求/响应首部未经压缩就发送。首部信息越多延迟越大。</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</li><li>可任意选择数据压缩格式。非强制压缩发送。</li></ul><h3 id="那么SPDY如何解决这些瓶颈呢？"><a href="#那么SPDY如何解决这些瓶颈呢？" class="headerlink" title="那么SPDY如何解决这些瓶颈呢？"></a>那么SPDY如何解决这些瓶颈呢？</h3><ul><li>AJAX</li><li>Comet</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/25/16f3bd07648dd67f?w=362&h=287&f=png&s=33282" alt=""><br>SPDY没有完全改写HTTP协议，而是在TCP/IP的应用层与传输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY规定通信中使用SSL。</p><p>SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。因此，可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文等。</p><h3 id="SPDY的优点"><a href="#SPDY的优点" class="headerlink" title="SPDY的优点"></a>SPDY的优点</h3><ul><li><p>多路复用流。<br>通过单一的TCP连接，可以无限制处理多个HTTP请求。<strong>所有请求的处理都在一条TCP连接上完成</strong>，因此TCP的处理效率得到提高。</p></li><li><p>请求优先级<br>SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</p></li><li><p>压缩HTTP首部<br>这样一来，通信产生的数据包数量和发送的字节数就更少了。</p></li><li><p>推送功能<br>支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</p></li></ul><h2 id="AJAX技术"><a href="#AJAX技术" class="headerlink" title="AJAX技术"></a>AJAX技术</h2><p>AJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是<strong>用JavaScript执行异步网络请求</strong>。</p><blockquote><p>Ajax（Asynchronous JavaScript and XML，异步JavaScript与XML技术）是一种有效利用JavaScript和DOM（Document Object Model，文档对象模型）的操作，以达到局部Web页面替换加载的异步通信手段。和以前的同步通信相比，由于它只<strong>更新一部分页面，响应中传输的数据量会因此而减少</strong>，这一优点显而易见。</p></blockquote><p>Ajax的<strong>核心技术是名为XMLHttpRequest的API</strong>，通过JavaScript脚本语言的调用就能和服务器进行HTTP通信。借由这种手段，就能从已加载完毕的Web页面上发起请求，只更新局部页面。</p><pre><code>引用廖雪峰老师的例子（利用XMLHttpRequest来做请求）&#39;use strict&#39;;----function success(text) {    var textarea = document.getElementById(&#39;test-response-text&#39;);    textarea.value = text;}function fail(code) {    var textarea = document.getElementById(&#39;test-response-text&#39;);    textarea.value = &#39;Error code: &#39; + code;}var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象request.onreadystatechange = function () { // 状态发生变化时，函数被回调    if (request.readyState === 4) { // 成功完成        // 判断响应结果:        if (request.status === 200) {            // 成功，通过responseText拿到响应的文本:            return success(request.responseText);        } else {            // 失败，根据响应码判断失败原因:            return fail(request.status);        }    } else {        // HTTP请求还在继续...    }}// 发送请求:request.open(&#39;GET&#39;, &#39;/api/categories&#39;);request.send();alert(&#39;请求已发送，请等待响应...&#39;);</code></pre><h2 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h2><p>一旦服务器端有内容更新了，Comet不会让请求等待，而是直接给客户端返回响应。这是<strong>一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能</strong>。</p><p>通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。</p><p>内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><h3 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h3><p>很多网站为了实现<strong>推送技术</strong>，所用的技术都是<strong>轮询</strong>。轮询是在<strong>特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器</strong>。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。</p><p>而比较新的技术去做轮询的效果是<strong>Comet</strong>。这种技术虽然可以双向通信，但依然需要反复发出请求。而且在Comet中，普遍采用的长链接，也会消耗服务器资源。</p><blockquote><p>Comet本质上也是轮询，但是在没有消息的情况下，服务器先拖一段时间，等到有消息了再回复。这个机制暂时地解决了实时性问题，但是它带来了新的问题：以多线程模式运行的服务器会让大部分线程大部分时间都处于挂起状态，极大地浪费服务器资源。另外，一个HTTP连接在长时间没有数据传输的情况下，链路上的任何一个网关都可能关闭这个连接，而网关是我们不可控的，这就要求Comet连接必须定期发一些ping数据表示连接“正常工作”。</p></blockquote><p>在这种情况下，HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><h3 id="WebSocket连接创建过程"><a href="#WebSocket连接创建过程" class="headerlink" title="WebSocket连接创建过程"></a>WebSocket连接创建过程</h3><ul><li>WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下：<pre><code>GET ws://localhost:3000/ws/chat HTTP/1.1Host: localhostUpgrade: websocketConnection: UpgradeOrigin: http://localhost:3000Sec-WebSocket-Key: client-random-stringSec-WebSocket-Version: 13</code></pre></li><li>该请求和普通的HTTP请求有几点不同:<ul><li>GET请求的地址不是类似/path/，而是以ws://开头的地址</li><li>请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；</li><li>Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；</li><li>Sec-WebSocket-Version指定了WebSocket的协议版本。</li></ul></li><li>随后，服务器如果接受该请求，就会返回如下响应：<pre><code>HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: server-random-string</code></pre>该<strong>响应代码101表示本次连接的HTTP协议即将被更改</strong>，更改后的协议就是Upgrade: websocket指定的<strong>WebSocket协议</strong>。</li></ul><p>版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用WebSocket的API，就不需要关心这些。</p><p>现在，一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本，这样，在浏览器处理起来就十分容易。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。 </p><p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成<strong>一次握手</strong>，两者之间就直接可以创建<strong>持久性的连接</strong>，并进行双向数据传输。  </p><p>在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p><p>由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端，而一旦确立WebSocket通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p><p>为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。<strong>WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧</strong>。</p><p>安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>推送功能<br>支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</p></li><li><p>减少通信量<br>只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了。</p></li></ul><blockquote><p>成功握手确立WebSocket连接之后，通信时不再使用HTTP的数据帧，而采用WebSocket独立的数据帧。</p></blockquote><p>很显然，要支持WebSocket通信，浏览器得支持这个协议，这样才能发出ws://xxx的请求。目前，支持WebSocket的主流浏览器如下：</p><ul><li>Chrome</li><li>Firefox</li><li>IE &gt;= 10</li><li>Sarafi &gt;= 6</li><li>Android &gt;= 4.4</li><li>iOS &gt;= 8</li></ul><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h2><p>HTTP/2.0在2014年11月实现标准化。</p><p>HTTP/2.0的目标是改善用户在使用Web时的速度体验。</p><p>有以下几个目标：</p><ul><li>异步连接多路复用</li><li>头部压缩；</li><li>请求/响应管线化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议 - 重学计算机网络系列(3)</title>
      <link href="/2020/01/08/http-xie-yi-chong-xue-ji-suan-ji-wang-luo-xi-lie-3/"/>
      <url>/2020/01/08/http-xie-yi-chong-xue-ji-suan-ji-wang-luo-xi-lie-3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2019/12/27/16f4686bba50f5bd?w=1144&h=439&f=png&s=45298" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>学习资料来源于《图解HTTP》。</li><li>部分内容参考于： <a href="https://juejin.im/post/5cd0438c6fb9a031ec6d3ab2" target="_blank" rel="noopener">前端基础篇之HTTP协议</a></li><li>本篇文章性质为笔记，总结。<h1 id="Web及网络基础"><a href="#Web及网络基础" class="headerlink" title="Web及网络基础"></a>Web及网络基础</h1><h2 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h2>1989年3月,HTTP诞生了。</li></ul><pre><code>CERN（欧洲核子研究组织）的蒂姆·伯纳斯-李（TimBerners-Lee）博士提出了一种能让远隔两地的研究者们共享知识的设想。最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的WWW（World Wide Web，万维网）。</code></pre><p><em>WWW这一名称，是Web浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为Web。</em></p><pre><code>现在已提出了3项WWW构建技术，分别是：页面的文本标记语言的HTML（HyperText Markup Language，超文本标记语言）；作为文档传递协议的HTTP；指定文档所在地址的URL（Uniform Resource Locator，统一资源定位符）。</code></pre><p><strong>总结：WWW = Web = HTML + HTTP + URL。</strong></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li><p>HTTP/0.9<br>HTTP于1990年问世。那时的HTTP并没有作为正式的标准被建立。这时的HTTP其实含有HTTP/1.0之前版本的意思，因此被称为HTTP/0.9。</p></li><li><p>HTTP/1.0<br>HTTP正式作为标准被公布是在1996年的5月，版本被命名为HTTP/1.0，并记载于RFC1945。虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端。</p></li><li><p>HTTP/1.1<br>1997年1月公布的HTTP/1.1是目前主流的HTTP协议版本。当初的标准是RFC2068，之后发布的修订版RFC2616就是当前的最新版本。</p></li></ul><blockquote><p>HTTP/2.0 下一篇会讲到。</p></blockquote><h2 id="网络基础TCP-IP"><a href="#网络基础TCP-IP" class="headerlink" title="网络基础TCP/IP"></a>网络基础TCP/IP</h2><p>TCP/IP是互联网相关的各类协议族的总称。而不是单指TCP和IP两个协议。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层决定了向用户提供应用服务时通信的活动。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。</p><p>在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><strong>网络层用来处理在网络上流动的数据包</strong>。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</p><p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/20/16f2281fae8be09a?w=867&h=622&f=png&s=237302" alt="传输过程"></p><h2 id="与HTTP关系密切的协议：IP、TCP和DNS"><a href="#与HTTP关系密切的协议：IP、TCP和DNS" class="headerlink" title="与HTTP关系密切的协议：IP、TCP和DNS"></a>与HTTP关系密切的协议：IP、TCP和DNS</h2><h3 id="负责传输的IP协议"><a href="#负责传输的IP协议" class="headerlink" title="负责传输的IP协议"></a>负责传输的IP协议</h3><pre><code>IP协议位于网络层。TCP/IP协议族中的IP指的就是网际协议。可能有人会把“IP”和“IP地址”搞混，“IP”其实是一种协议的名称。</code></pre><p>IP协议的作用是把各种数据包传送给对方。但是IP协议用什么来确定传输的数据包要发到谁手中在呢？要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是<strong>IP地址</strong>和<strong>MAC地址</strong>（Media Access ControlAddress）。</p><pre><code>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。</code></pre><h4 id="使用ARP协议凭借MAC地址进行通信"><a href="#使用ARP协议凭借MAC地址进行通信" class="headerlink" title="使用ARP协议凭借MAC地址进行通信"></a>使用ARP协议凭借MAC地址进行通信</h4><p>ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/20/16f2295dd89e7ce6?w=899&h=588&f=png&s=260257" alt="IP协议利用MAC通信"></p><h3 id="确保可靠性的TCP协议"><a href="#确保可靠性的TCP协议" class="headerlink" title="确保可靠性的TCP协议"></a>确保可靠性的TCP协议</h3><p>TCP位于传输层，提供可靠的字节流服务。</p><p>所谓的字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。<strong>一言以蔽之，TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方</strong>。</p><blockquote><p>如何保证数据能到达目标？TCP协议采用了三次握手策略。</p></blockquote><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志（flag）——SYN（synchronize）和ACK（acknowledgement）。</p><p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</p><p>若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/20/16f229fcabf08800?w=744&h=383&f=png&s=168064" alt="三次握手"></p><p>除了上述三次握手，TCP协议还有其他各种手段来保证通信的可靠性。</p><h3 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h3><p>DNS在系列2已经讲过就不在赘述。</p><h3 id="各种协议关系一目了然"><a href="#各种协议关系一目了然" class="headerlink" title="各种协议关系一目了然"></a>各种协议关系一目了然</h3><p><img src="https://user-gold-cdn.xitu.io/2019/12/20/16f22a5f2996c16e?w=640&h=876&f=png&s=338103" alt="各种协议关系"></p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><strong>绝对URL格式</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/12/20/16f22ad122eb4f74?w=670&h=149&f=png&s=63107" alt=""></p><ul><li>协议方案名。<br>使用http：或https：等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）。<br><strong>也可使用data：或javascript：这类指定数据或脚本程序的方案名</strong>。</li><li>登录信息（认证）<br>指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。</li><li>服务器地址<br>使用绝对URI必须指定待访问的服务器地址。地址可以是类似hackr.jp这种DNS可解析的名称，或是192.168.1.1这类IPv4地址名，还可以是[0:0:0:0:0:0:0:1]这样用方括号括起来的IPv6地址名</li><li>查询字符串<br>针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</li><li>片段标识符<br>使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在RFC中并没有明确规定其使用方法。该项也为可选项。</li></ul><h1 id="简单的HTTP基础"><a href="#简单的HTTP基础" class="headerlink" title="简单的HTTP基础"></a>简单的HTTP基础</h1><h2 id="请求报文和响应报文"><a href="#请求报文和响应报文" class="headerlink" title="请求报文和响应报文"></a>请求报文和响应报文</h2><p>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/21/16f262e041400a16?w=779&h=318&f=png&s=96963" alt=""><br>请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/21/16f263040dedaf94?w=768&h=356&f=png&s=103066" alt=""><br>在起始行开头的HTTP/1.1表示服务器对应的HTTP版本。紧挨着的200 OK   表示请求的处理结果的状态码和原因短语）。下一行显示了创建响应的日期时间，是首部字段内的一个属性。接着以一空行分隔，之后的内容称为资源实体的主体。</p><h2 id="无状态的HTTP"><a href="#无状态的HTTP" class="headerlink" title="无状态的HTTP"></a>无状态的HTTP</h2><p><strong>HTTP协议自身不对请求和响应之间的通信状态进行保存</strong>。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。</p><p>为什么要这样做？</p><pre><code>使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。</code></pre><p>HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了<strong>Cookie技术</strong>。有了Cookie再用HTTP协议通信，就可以管理状态了。</p><h2 id="请求URI定位资源"><a href="#请求URI定位资源" class="headerlink" title="请求URI定位资源"></a>请求URI定位资源</h2><p>HTTP协议使用URI定位互联网上的资源。正是因为URI的特定功能，在互联网上任意位置的资源都能访问到。</p><p>客户请求资源的时候，请求报文需要指定URL，有以下几种方法。</p><ul><li>完整请求。<br><code>GET http://hacker.jp/index/html HTTP/1.1</code> </li><li>在HOST写明网络域名或IP地址。<br><code>GET /index.htm HTTP/1.1  HOST:hacker.jp</code></li><li>此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用一个*来代替请求URI。<br><code>OPTIONS * HTTP/1.1</code></li></ul><h2 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h2><ul><li><p>GET：获取资源。<br>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。<strong>也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGI（CommonGateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果</strong>。</p></li><li><p>POST：传输实体内容。<br>虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。虽说POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。</p></li><li><p>PUT：传输文件<br>PUT方法用来传输文件。<strong>就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置</strong>。</p><blockquote><p>但是，鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的Web网站不使用该方法。</p></blockquote></li><li><p>HEAD: 获取报文首部    </p></li></ul><p><strong>HEAD方法和GET方法一样</strong>，只是不返回报文主体部分。用于<strong>确认URI的有效性及资源更新的日期时间</strong>等。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/21/16f265b3797123f4?w=644&h=94&f=png&s=26411" alt=""></p><ul><li><p>DELETE：删除文件<br>DELETE方法用来删除文件，是<strong>与PUT相反的方法</strong>。DELETE方法按请求URI删除指定的资源。  </p><blockquote><p>但是，HTTP/1.1的DELETE方法本身和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。当配合Web应用程序的验证机制，或遵守REST标准时还是有可能会开放使用的。</p></blockquote></li><li><p>OPTIONS：询问支持的方法<br>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。<br>响应报文会返回当前服务器所支持的方法：比如 <code>Allow:GET,POST,HEAD,OPTIONS</code></p></li><li><p>TRACE: 追踪路径<br>发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200 OK的响应。</p></li></ul><p>客户端通过TRACE方法可以<strong>查询发送出去的请求是怎样被加工修改/篡改的</strong>。这是因为，<strong>请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作</strong>。</p><blockquote><p>但是，TRACE方法本来就不怎么常用，再加上它容易引发XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。</p></blockquote><ul><li>CONNECT：要求用隧道协议连接代理<br>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（SecureSockets Layer，安全套接层）和TLS（Transport LayerSecurity，传输层安全）协议把通信内容加密后经网络隧道传输。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/21/16f26666ec9a0100?w=724&h=342&f=png&s=90041" alt=""></p><h2 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h2><p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使这样也没有多大问题。可随着HTTP的普及，文档中包含大量图片的情况多了起来。比如，使用浏览器浏览一个包含多张图片的HTML页面时，在发送请求访问HTML页面资源的同时，也会请求该HTML页面里包含的其他资源。因此，每次的请求都会造成无谓的TCP连接建立和断开，增加通信量的开销。</p><p>为解决上述TCP连接的问题，HTTP/1.1和一部分的HTTP/1.0想出了持久连接（也称为HTTP keep-alive）的方法。持久连接的特点是，<strong>只要任意一端没有明确提出断开连接，则保持TCP连接状态</strong>。</p><p>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样Web页面的显示速度也就相应提高了。</p><blockquote><p>在HTTP/1.1中，所有的连接默认都是持久连接。HTTP/1.0 则不一定。</p></blockquote><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。</p><p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态,用来让服务端记住客户端。</p><p><strong>Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。<br>服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/21/16f2673e57c07922?w=868&h=713&f=png&s=215340" alt=""></p><p>过程：  </p><ul><li>请求报文(首次请求)<br>```<br>GET /reader/ HTTP/1.1<br>HOST: hacker.jp</li></ul><ul><li>首部字段内没有Cookie的相关信息<br>```</li></ul><ul><li><p>响应报文(服务端生成Cookie信息)    </p><pre><code>HTTP/1.1 200 OK.....server: Apache &lt;Set-Cookie: sid=12313123121; path=/; .......&gt;</code></pre></li><li><p>请求报文(第二次请求)  </p><pre><code>GET /image/ HTTP/1.1Host: hacker.jpCookie: sid=12313123121这样二次请求的时候，服务端通过cookie会记住上一次访问的是谁</code></pre></li></ul><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/21/16f2689bf46a4d38?w=688&h=231&f=png&s=73372" alt=""></p><blockquote><p>只要遵守状态码类别的定义，即使改变RFC2616中定义的状态码，或服务器端自行创建状态码都没问题。</p></blockquote><blockquote><p>仅记录在RFC2616上的HTTP状态码就达40种，若再加上WebDAV和附加HTTP状态码等扩展，数量就达60余种。别看种类繁多，实际上经常使用的大概只有14种。</p></blockquote><h2 id="2XX成功"><a href="#2XX成功" class="headerlink" title="2XX成功"></a>2XX成功</h2><ul><li><p>200 OK<br>表示从客户端发来的请求在服务器端被正常处理了。</p></li><li><p>204 No Content<br>表示请求处理成功，但没有资源可以返回。(响应报文中并没有主体资源，或者并不允许返回任何资源)比如，当从浏览器发出请求处理后，返回204响应，那么浏览器显示的页面不发生更新。</p><blockquote><p>一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p></blockquote></li><li><p>206 Partial Content<br>该状态码表示客户端进行了<strong>范围请求</strong>，而服务器<strong>成功执行了这部分的GET请求</strong>。响应报文中包含由Content-Range指定范围的实体内容。</p></li></ul><h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><p>3XX响应结果表明<strong>浏览器需要执行某些特殊的处理</strong>以正确处理请求。</p><ul><li><p>301 永久性重定向。<br>该状态码表示<strong>请求的资源已被分配了新的URI</strong>，以后应使用资源现在所指的URI。也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。</p></li><li><p>302 临时性重定向<br>该状态码表示<strong>请求的资源已被分配了新的URI</strong>，希望用户（本次）能使用新的URI访问。</p></li></ul><p>和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。比如，用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回302状态码的页面对应的URI。</p><ul><li>303 See Other<br>该状态码表示由于请求对应的资源存在着另一个URI，应使用<strong>GET方法</strong>定向获取请求的资源。<br>303状态码和302 Found状态码有着相同的功能，但303状态码<strong>明确表示客户端应当采用GET方法获取资源</strong>，这点与302状态码有区别。</li></ul><p>比如，当使用POST方法访问CGI程序，其执行后的处理结果是希望客户端能以GET方法重定向到另一个URI上去时，返回303状态码。虽然302 Found状态码也可以实现相同的功能，但这里使用303状态码是最理想的。</p><ul><li>304 Not Modified<br>该状态码表示客户端<strong>发送附带条件的请求</strong>时，服务器端允许请求访问资源，但因发生<strong>请求未满足条件</strong>的情况后，直接返回304 Not Modified。  </li></ul><p><strong>304状态码返回时，不包含任何响应的主体部分</strong>。304虽然被划分在3XX类别中，但是和重定向没有关系。</p><blockquote><p>附带条件的请求是指采用GET方法的请求报文中包含if-Match,if-Modified-Since,if-None-Match,if-Range,if-Unmodified-Since中任一首部。</p></blockquote><blockquote><p>当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。301、302标准是禁止将POST方法改变成GET方法的，但实际使用时大家都会这么做。</p></blockquote><h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><p>4XX的响应结果表明客户端是发生错误的原因所在。</p><ul><li><p>400 Bad Request<br>状态码表示<strong>请求报文中存在语法错误</strong>。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200 OK一样对待该状态码。</p></li><li><p>401 Unauthorized<br>该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的<strong>认证信息</strong>。</p><ul><li>若第一次返回401，会弹出认证的对话框。</li><li>第二次返回401，表示认证失败。</li></ul></li><li><p>403 Forbidden<br>该状态码表明对<strong>请求资源的访问被服务器拒绝了</strong>。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。</p><blockquote><p>未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举的情况都可能是发生403的原因。</p></blockquote></li><li><p>404 Not Found<br>该状态码表明服务器上<strong>无法找到请求的资源</strong>。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p></li></ul><h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><p>5XX的响应结果表明服务器本身发生错误。</p><ul><li><p>500 Internal Server Error<br>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。</p></li><li><p>503 Service Unavailable<br>该状态码表明<strong>服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</strong>。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。</p></li></ul><blockquote><p>不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如Web应用程序内部发生错误，状态码依然返回200 OK，这种情况也经常遇到。</p></blockquote><h1 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h1><p>一台Web服务器可搭建多个独立域名的Web网站，也可作为通信路径上的中转度武器提升传输效率。</p><h2 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h2><p>HTTP/1.1规范允许一台HTTP服务器搭建多个Web站点。即一个服务器可以为每位客户持有的域名<strong>运行各自不同的网站</strong>。这是因为利用了<strong>虚拟主机</strong>的功能。</p><p>即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器。</p><blockquote><p>若<a href="http://www.baidu.com/" target="_blank" rel="noopener">www.baidu.com/</a> 和 <a href="http://www.cctv.com/同时部署在同一个服务器上，使用DNS解析域名后，两者的访问IP地址会相同。" target="_blank" rel="noopener">www.cctv.com/同时部署在同一个服务器上，使用DNS解析域名后，两者的访问IP地址会相同。</a></p></blockquote><p>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完整指定主机名或域名的URI。</p><h2 id="通信数据转发"><a href="#通信数据转发" class="headerlink" title="通信数据转发"></a>通信数据转发</h2><p>HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如<strong>代理、网关和隧道</strong>。它们可以配合服务器工作。</p><p>这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理服务器的基本行为就是<strong>接收客户端发送的请求后转发给其他服务器</strong>。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。</p><p>持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。</p><p>为什么要使用代理？</p><ul><li>利用缓存技术减少网络带宽的流量。</li><li>组织内部针对特定网站的访问控制，以获取访问日志为主要目的</li></ul><blockquote><p>代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。</p></blockquote><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关的工作机制和代理十分相似。而<strong>网关能使通信线路上的服务器提供非HTTP协议服务</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/21/16f272b47fb05d3c?w=745&h=183&f=png&s=118667" alt=""></p><p>为什么要用网关？<br>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在Web购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。</p><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</p><p>隧道本身不会去解析HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存是指<strong>代理服务器或客户端本地磁盘内保存的资源副本</strong>。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。</p><p>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。</p><h3 id="缓存有效期"><a href="#缓存有效期" class="headerlink" title="缓存有效期"></a>缓存有效期</h3><p>即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。因为这关系到被缓存资源的有效性问题。</p><p>当遇上<strong>源服务器上的资源更新</strong>时，如果还是使用不变的缓存，那就会演变成返回更新前的“旧”资源了。</p><p>即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。</p><h3 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h3><p>缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。</p><p>浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。<br>比如在系列1中提到过，DNS解析的时候，当在浏览器输入地址后，不会直接进行解析，会在本地缓存中对比是否有访问对象的IP地址，有的话就不用DNS解析，直接就可以拿到IP地址。</p><h1 id="HTTP报文首部"><a href="#HTTP报文首部" class="headerlink" title="HTTP报文首部"></a>HTTP报文首部</h1><p><img src="https://user-gold-cdn.xitu.io/2019/12/21/16f2744ee407b0bd?w=749&h=245&f=png&s=129777" alt=""></p><blockquote><p>请求报文首部组成<br>请求报文 = 报文首部 + 报文主体<br>报文首部 = (方法 + URI + HTTP版本) + (请求首部字段 + 通用首部字段 + 实体首部字段)</p></blockquote><blockquote><p>响应报文首部组成<br>响应报文 = 报文首部 + 主体<br>报文首部 = (HTTP版本 + 状态码) + (响应首部字段 + 通用首部字段 + 实体首部字段)</p></blockquote><h2 id="首部字段类型分类"><a href="#首部字段类型分类" class="headerlink" title="首部字段类型分类"></a>首部字段类型分类</h2><ul><li><p>请求首部字段</p></li><li><p>响应首部字段</p></li><li><p>通用首部字段</p></li><li><p>实体首部字段</p><h2 id="首部字段概述"><a href="#首部字段概述" class="headerlink" title="首部字段概述"></a>首部字段概述</h2></li><li><p>首部字段的作用：<br>使用首部字段是为了<strong>给浏览器和服务器提供报文主体大小、所使用的语言、认证信息</strong>等内容。</p></li><li><p>首部字段的结构：<br>HTTP首部字段是由首部字段名和字段值构成的，中间用冒号“:”分隔。</p><pre><code>首部字段名： 字段值</code></pre></li></ul><p>例如表示报文主体的对象类型:<br>Content-Type: text/html</p><pre><code>- 字段值对应单个HTTP首部字段可以有多个值</code></pre><p>Keep-Alive: timeout=15, max=100</p><pre><code>&gt;**若HTTP首部字段重复了会如何**。      当HTTP报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样？这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段。## 请求首部字段请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于**补充请求的附加信息、客户端信息、对响应内容相关的优先级**等内容。    | 请求首部字段 |  说明 ||------|------------||Accept|`text/html,image/jpeg,video/mpeg,application/octet-stream`客户端可以接收的媒体类型(文本文件，图片文件，视频文件，二进制文件)||Accept-Charset|`iso-8859-5,unicode-1-1;q=0.8`能正确接收的字符集||Accept-Encoding|客户端能支持的内容编码（可多个）:`gzip,compress,deflate`||Accept-Language|`zh-cn,zh;q=0.7,en-us,en;q=0.3`客户端能够处理的语言||Authorization|认证信息。当出现401时将其添加到请求头中便可认证||Expect|期待服务端的指定行为||From|告知服务器使用用户代理的用户的电子邮件地址。(使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式)||Host|(必须存在于请求头中) 告知服务器，请求的资源所处的互联网主机名和端口号`（当一个服务器下部署着多个域名的时候需指定，不然分不清请求的是哪一个域名）`||If-Match|形如if-xxx的格式，称为`条件请求`。服务器接收到条件后，只有判断指定条件为真，才会接受请求||If-Modified-Since|告知服务器若`If-Modified-Since`字段值早于资源的更新时间，则希望能处理该请求。而在指定`If-Modified-Since`字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码`304 Not Modified`的响应。||If-None-Match|资源未修改返回 304(通过对比ETag)||If-Range|告知服务器若指定的If-Range字段值（ETag值或者时间）和请求资源的ETag值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。||If-Unmodified-Since|首部字段If-Unmodified-Since和首部字段If-Modified-Since的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码412 Precondition Failed作为响应返回。||Max-Forwards|限制可被代理及网关转发的次数||Proxy-Authorization|向代理服务器发送验证信息`（这个行为是与客户端和服务器之间的HTTP访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间的认证，使用首部字段Authorization可起到相同作用。）`||Range|`bytes=5001-10000`请求某个内容的一部分，配合If-Range使用||Referer|告知服务器请求的原始资源的URI。`(客户端一般都会发送Referer首部字段给服务器。但当直接在浏览器的地址栏输入URI，或出于安全性的考虑时，也可以不发送该首部字段。因为原始资源的URI中的查询字符串可能含有ID和密码等保密信息，要是写进Referer转发给其他服务器，则有可能导致保密信息的泄露。)`||TE|`gzip,deflate;q=0.5.`告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段Accept-Encoding的功能很相像，但是用于传输编码。||User-Agent|将发起请求的**浏览器和用户代理名称等**信息**传达给服务器。|## 响应首部字段响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于**补充响应的附加信息、服务器信息，以及对客户端的附加要求**等信息。|响应首部字段|说明||------|------------||Accept-Ranges|告知客户端自己能否处理范围请求。能`bytes`，否`none`||Age|告知客户端，**源服务器**在多久前创建了响应。  若创建该响应的服务器是**缓存服务器**，Age值是指缓存后的响应再次发起认证到认证完成的时间值。`(资源在代理缓存中存在的时间)`|| ETag|资源标识，资源发生变化时标识也会发生改变||Location|使用首部字段Location可以将响应接收方引导至某个与请求URI位置不同的资源。基本上，该字段会配合3xx:Redirection的响应，提供重定向的URI。几乎所有的浏览器在接收到包含首部字段Location的响应后，都会强制性地尝试对已提示的重定向资源的访问。||Proxy-Authenticate|把由代理服务器所要求的认证信息发送给客户端。||Retry-After|告知客户端应该在多久之后再次发送请求。主要配合状态码`503 Service Unavailable`响应||Server|`Apache/2.2.6 (Unix) PHP/5.2.5`告知客户端当前服务器上安装的HTTP服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。||Vary|对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。||WWW-Authenticate|用于HTTP访问认证。它会告知客户端适用于访问请求URI所指定资源的认证方案（Basic或是Digest）和带参数提示的质询（challenge）。状态码401 Unauthorized响应中，肯定带有首部字段WWW-Authenticate。|## 通用首部字段通用首部字段是指，请求报文和响应报文双方都会使用的首部。| 通用首部字段 |  说明(请求报文和响应报文都会用到) ||------|------------|| Cache-Control|表示是否能缓存的指令。` public`(客户端、代理服务器都可利用缓存),`no-cache`(防止从缓存中返回过期的资源),`no-store`(暗示包含机密信息，不允许缓存)，`s-maxage,max-age`(资源可缓存最大时间 秒)||Connection|`不再转发的首部字段名`(控制不再转发给代理的首部字段),`close`(关闭持续连接),`Keep-Alive`(在HTTP/1.0上开启持续连接，1.1默认持续连接所以不需要)||Data|表明创建HTTP报文的日期和时间||Pragma|`no-cache`(只用于请求报文，客户端要求中间服务器不返回缓存的资源)||Trailer|事先说明在报文主体后记录了哪些首部字段||Transfer-Encoding|`chunked`(规定了传输报文主体时采用的编码方式。)||Upgrade|检测HTTP协议及其他协议是否可使用更高的版本进行通信||Via|追踪客户端与服务器之间的请求和响应报文的传输路径。报文经过代理或网关时，会先在首部字段Via中附加该服务器的信息，然后再进行转发。首部字段Via不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。||Warning|告知用户一些与缓存相关的问题的警告。|## 实体首部字段实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于**补充内容的更新时间等与实体相关的信息**。在请求和响应两方的HTTP报文中都含有与实体相关的首部字段。|实体首部字段|说明||------|-----||Allow|`GET,HEAD`。通知客户端能够支持Request-URI指定资源的所有HTTP方法。当服务器接收到不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应返回。与此同时，还会把所有能支持的HTTP方法写入首部字段Allow后返回。||Content-Encoding|`gzip,compress,deflate,identity`。告知客户端服务器对实体的主体部分选用的内容编码方式。`内容编码是指在不丢失实体信息的前提下所进行的压缩`。||Content-Language|告知客户端，实体主体使用的自然语言（指中文或英文等语言）||Content-Length|表明了实体主体部分的大小（单位是字节）||Content-Location|返回数据的备用地址||Content-MD5|首部字段Content-MD5是一串由MD5算法生成的值，其目的在于`检查报文主体在传输过程中是否保持完整，以及确认传输到达`。||Content-Range|`bytes 5001-10000/10000`。告知客户端作为响应返回的实体的哪个部分符合范围请求。||Content-Type|`application/json;charset=UTF-8`。说明了实体主体内对象的媒体类型。||Expires|缓存服务器在接收到含有首部字段Expires的响应后，表示可以缓存到指定日期，到达指定日期，缓存服务器会向源服务器请求更新资源；同时也会告知客户端||Last-Modified|指明资源最终修改的时间|## 为Cookie服务的首部字段管理服务器与客户端之间状态的Cookie，虽然没有被编入标准化HTTP/1.1的RFC2616中，但在Web网站方面得到了广泛的应用。Cookie的工作机制是用户识别及状态管理。Web网站为了管理用户的状态会通过Web浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前存放的Cookie。调用Cookie时，由于可校验Cookie的**有效期**，以及发送方的**域、路径、协议**等信息，所以正规发布的Cookie内的数据不会因来自其他Web站点和攻击者的攻击而泄露。|为Cookie服务的首部字段|说明||-----|-----||Set-Cookie|`name`:赋予Cookie的名称和其值；`expires`:Cookie的有效期(若不指定则默认为浏览关闭前为止)；`path`:将服务器上的文件目录作为Cookie的适用对象；`domain = 域名`：作为Cookie适用对象的域名；`secure`:仅在HTTPS安全通行时才会发送Cookie;`HttpOnly`:加以限制，使Cookie不能被JavaScript脚本访问||Cookie|`Cookie: status=enable`:首部字段Cookie会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie。接收到多个Cookie时，同样可以以多个Cookie形式发送。|## 其他首部字段HTTP首部字段是可以自行扩展的。所以在Web服务器和浏览器的应用上，会出现各种非标准的首部字段。|其他首部字段|说明||-----|-----||X-Frame-Options|`DENY(拒绝);SAMEORIGIN(仅同源域名下许可)`：用于控制网站内容在其他Web网站的Frame标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。||X-XSS-Protection|`0:将XSS过滤设置成无效状态`;`1 ：将XSS过滤设置成有效状态`。它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器XSS防护机制的开关。||DNT|`0 ：同意被追踪; 1 ：拒绝被追踪`:DNT是Do NotTrack的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。由于首部字段DNT的功能具备有效性，所以Web服务器需要对DNT做对应的支持。||P3P|通过利用P3P（ThePlatform for Privacy Preferences，在线隐私偏好平台）技术，可以让Web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。|&gt;要进行P3P的设定，需按以下操作步骤进行。    步骤1： 创建P3P隐私             步骤2： 创建P3P隐私对照文件后，保存命名在/w3c/p3p.xml  步骤3： 从P3P隐私中新建Compact policies后，输出到HTTP响应中&gt; **下一篇讲HTTPS，HTTP追加协议，WEB安全的知识点**</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层 - 重学计算机网络系列(2)</title>
      <link href="/2020/01/08/ying-yong-ceng-chong-xue-ji-suan-ji-wang-luo-xi-lie-2/"/>
      <url>/2020/01/08/ying-yong-ceng-chong-xue-ji-suan-ji-wang-luo-xi-lie-2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2019/12/27/16f46865b88d8984?w=1144&h=439&f=png&s=45298" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>这是关于计算机网络的一系列专题，后续会不断更新。</li><li>学习资料来源于 <em>《计算机网络》(第七版) 和《图解HTTP》</em>。</li><li>本篇文章主要分享应用层下面的几个协议：<strong>DNS域名解析;FTP文件传输协议;DHCP动态主机配置协议;电子邮件的SMTP，POP3协议</strong>。</li><li>至于HTTP协议作为重中之重，会单独留篇幅来分享。</li></ul><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>每个应用层协议都是为了解决<strong>某一类应用</strong>问题，而问题的解决又必须通过位于不同主机中的多个应用进程之间的<strong>通信和协同</strong>工作来完成。应用层的具体内容就是精确定义这些通信规则。具体来说，应用层协议应当定义：</p><ul><li>应用进程交换的报文类型，如请求报文和响应报文。</li><li>各种报文类型的语法，如报文中的各个字段以及详细描述。</li><li>字段的语义，即包含在字段中的信息的含义。</li><li>进程何时，如何发送报文，以及对报文进行响应的规则。</li></ul><h1 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="何为DNS？"><a href="#何为DNS？" class="headerlink" title="何为DNS？"></a>何为DNS？</h3><p>域名系统DNS是互联网使用的<strong>命名系统</strong>，用来把便于人们使用的机器名字装换为IP地址。域名系统就是名字系统。为什么不叫“名字”而叫“域名”呢？是因为在这种互联网的命名系统中使用了许多的“域”。</p><h3 id="为什么用户要用域名来访问？"><a href="#为什么用户要用域名来访问？" class="headerlink" title="为什么用户要用域名来访问？"></a>为什么用户要用域名来访问？</h3><p>用户与互联网上某台主机通信时，<strong>必须知道对方的IP地址</strong>。然而用户很难记住长达32位的二进制主机地址。域名系统DNS能够把互联网上的主机名字转换为IP地址。</p><h3 id="为什么机器在处理IP数据报时要使用IP地址而不使用域名呢？"><a href="#为什么机器在处理IP数据报时要使用IP地址而不使用域名呢？" class="headerlink" title="为什么机器在处理IP数据报时要使用IP地址而不使用域名呢？"></a>为什么机器在处理IP数据报时要使用IP地址而不使用域名呢？</h3><p>因为IP地址的长度是固定32位的（如果是IPv6，就是128位），但是域名却不是固定的，机器处理起来很难。</p><h3 id="DNS的结构"><a href="#DNS的结构" class="headerlink" title="DNS的结构"></a>DNS的结构</h3><p>互联网采用<strong>层次树状结构</strong>的命名方法，并使用<strong>分布式</strong>的域名系统DNS。</p><p>互联网的域名系统DNS被设计成为一个联机分布式数据库系统，并采用客户服务器方式。DNS让大多数名字都在本地进行解析，仅少量解析需要在互联网上通信，因此NDS系统<strong>效率</strong>很高。由于DNS是分布式系统，即便单个计算机出了故障，也不会妨碍整个DNS系统正常运行。</p><p>域名到IP地址的解析是由分布在互联网上的许多域名服务器程序共同完成的。域名服务器程序在专设的结点上运行，而人们也常把运行域名服务器程序的机器称为 <strong>域名服务器</strong>。</p><h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p>过程如下：当一个应用程序需要把主机名解析为IP地址时，该应用进程就调用解析程序，并成为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名解析器，本地域名服务器查找后，就返回对应的IP地址。应用进程获得目的的IP地址后即可进行通信。若本地域名服务器无法解析，就向上一层的域名服务器上查找，直到找到。</p><h2 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h2><p>早期因为用户数少，用了非等级的名字空间。但是随着用户急剧增加，采用了层次树状结构的命名方法。</p><p>mail.cctv.com中 com 为顶级域名，cctv为二级域名,mail为三级域名。级别最低的写在最左边，而级别最高的顶级域名写在最右边。</p><p>DNS既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。各级域名由其上一级的域名管理机构管理，最顶级的域名由ICANN进行管理。用这种方法可以使每个域名在整个互联网范围内是唯一的，并且容易设计出一种查找域名的机制。</p><ul><li>通用顶级域名：com(公司企业) net(网络服务机构) org(非营利性组织) int(国际组织) edu(美国专用教育机构) gov(美国政府机构) mil(美国军事机构) 等等共有20个。</li><li>国家顶级域名： cn(中国)  us(美国) 等等</li><li>反向域名：arpa,用于反向解析</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ebf64cef01ada5?w=891&h=409&f=png&s=63696" alt="互联网域名空间"></p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>理论上，可以让每一级的域名都都有一个相对应的域名服务器，但是这样会造成服务器数量过多，效率降低。所以采用<strong>划分区</strong>的方法来解决这个问题。</p><p> 一个服务器所负责管辖的范围叫做<strong>区</strong>。每个区设置相对应的<strong>权限域名服务器</strong>，用来<strong>保存该区所有域名到IP地址的映射</strong>。</p><p> DNS服务器的管辖范围不是以域为单位，而是以区为单位。区是服务器实际管辖的范围，区可能等于或小于域，但一定不能大于域。一个域下面可能会有一个或多个区。</p><h3 id="域名服务器的分类"><a href="#域名服务器的分类" class="headerlink" title="域名服务器的分类"></a>域名服务器的分类</h3><ul><li>根域名服务器。最高层次，最重要的域名服务器。</li><li>顶级域名服务器。诸如com cn gov 这种的。</li><li>权限域名服务器。负责一个区的域名服务器。</li><li>本地域名服务器。当一台主机发出DNS查询请求，这个查询请求报文就发送给本地域名服务器。每个ISP，或一个大学都可以拥有一个本地域名服务器。本地域名服务器离用户较近，一般不超过几个路由器的距离。<em>当所要查询的主机也同属于同一个ISP时，该本地域名服务器立即就能把要查询的主机名转换为她的IP地址，而不需要去询问其他的域名服务器。</em></li></ul><h3 id="辅助域名服务器"><a href="#辅助域名服务器" class="headerlink" title="辅助域名服务器"></a>辅助域名服务器</h3><p>为了提高域名服务器的可靠性，DNS域名服务器都把数据复制到几个域名服务器来保存，其中<strong>一个是主域名服务器，其他的是辅助域名服务器</strong>。当主域名服服务器出现故障，辅助域名服务器可以确保工作不会中段。</p><h2 id="域名查询的两种方式"><a href="#域名查询的两种方式" class="headerlink" title="域名查询的两种方式"></a>域名查询的两种方式</h2><ul><li><p>递归查询</p><p>  假如主机A想访问主机B。主机A输入B的域名后，先是到本地域名服务器查询，查询不到，本地域名服务器以DNS客户的身份代表主机A去访问根域名服务器，若还是查询不到，根域名服务器如法炮制去到下面一级的顶级域名服务器查询，直到拿到主机B的IP地址。然后原路返回，给主机A。</p></li><li><p>迭代查询</p><p>  当根域名服务器收到本地域名服务器发出的请求报文时，要么给出IP地址，要么告诉本地域名服务器“下一步应该向哪一个域名服务器进行查询”，直到有域名服务器给出IP地址。</p></li></ul><p><strong>注意：主机向本地域名服务器查询一般采用递归查询。本地域名服务器向根域名服务器查询通常采用迭代查询。</strong></p><h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><ul><li>为了提高DNS查询效率，并减轻根域名服务器的负荷和减少互联网上的DNS查询报文数量，在<strong>域名系统服务器</strong>中广泛使用了高速缓存。高速缓存用来存放<strong>最近查询过的域名</strong>以及从何处获得域名映射信息的记录。</li><li>许多主机在启动时从本地域名服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且在缓存中找不到名字时才使用域名服务器。</li></ul><h2 id="总结DNS解析全过程"><a href="#总结DNS解析全过程" class="headerlink" title="总结DNS解析全过程"></a>总结DNS解析全过程</h2><ol><li>浏览器输入一个地址，按下回车。</li><li>如果地址的信息未写完整，(完整的格式应该是这样：<a href="http://www.baidu.com::8080),那么现在的浏览器会自动帮你补齐协议号和端口号。" target="_blank" rel="noopener">http://www.baidu.com::8080),那么现在的浏览器会自动帮你补齐协议号和端口号。</a></li><li>浏览器得到完整地址会开始解析，获取改地址的协议，各级域名，端口，路径。</li><li>比对存储在本地的<strong>高速缓存</strong>，如果有，就直接得到IP地址了。</li><li>如果没有，则向<strong>本地域名服务器</strong>发出查询请求。（递归查询）</li><li>如果本地域名服务器没有，那么本地域名服务器会直接向<strong>根域名服务器</strong>（最顶层）发出查询请求。此时，根域名服务器要么给出IP地址，要么告诉本地域名服务器“下一步应该向哪一个域名服务器进行查询”，直到给出IP地址。（迭代查询）</li></ol><h1 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h1><p>文件传送协议FTP是互联网上使用最广泛的文件传送协议。</p><ul><li>FTP提供交互式的访问</li><li>允许客户指明文件的类型与格式</li><li>允许文件具有存取权限（访问文件的用户必须经过授权，并输入有效的口令）</li><li>FTP屏蔽了个各计算机系统的系统的细节，因而适合于在异构网络中任意计算机之间传送文件。</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>基于TCP的FTP和基于UDP的简单文件传送协议TFTP，它们都是文件共享协议中的一大类，即<strong>复制整个文件</strong>。若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件只能对文件的副本进行修改，然后再将修改后的文件副本传回到原节点。</li><li>联机访问。允许多个程序同时对一个文件进行存取。</li></ul><h2 id="FTP基本工作原理"><a href="#FTP基本工作原理" class="headerlink" title="FTP基本工作原理"></a>FTP基本工作原理</h2><p><strong>两台主机之间传送文件看似是很简单，往往十分困难。</strong></p><p>原因是众多的计算机厂商研制出的文件系统多达数百种，且差别很大。</p><p>经常遇到的问题是：  </p><ol><li>计算机存储数据的格式不同。</li><li>文件的目录结构和文件命名的规定不同。</li><li>对于相同的文件存取功能，操作系统使用的命令不同。</li><li>访问控制方法不同。</li></ol><p>文件传送协议FTP只提供文件传送的一些基本的服务，主要功能是<strong>减少或消除在不同操作系统下处理文件的不兼容性</strong>。</p><p>FTP协议分客户端和服务端。一个FTP服务端可以为多个客户端提供服务。</p><p>服务端分两类：主进程，从属进程。主进程负责接受新请求，若干个从属进程负责处理单个进程。</p><p>客户端和服务端都有两个从属进程：<strong>控制进程和数据传送进程</strong>。<br>控制连接会在整个会话期间一直保持打开。<br>数据连接用来传输文件，传输完成就关闭数据传送连接。</p><h3 id="FTP文件传输过程总结"><a href="#FTP文件传输过程总结" class="headerlink" title="FTP文件传输过程总结"></a>FTP文件传输过程总结</h3><ul><li>客户端发送请求，服务端提供文件。</li><li>客户端和服务端都有两个从属进程：<strong>控制进程和数据传送进程</strong>。 </li><li>控制进程会在整个会话期间一直保持打开，表示一直在连接，有点像电路交换。</li><li>数据连接用来传输文件，传输完成就关闭数据传送连接。</li></ul><h2 id="TFTP简单文件传送协议"><a href="#TFTP简单文件传送协议" class="headerlink" title="TFTP简单文件传送协议"></a>TFTP简单文件传送协议</h2><p>它是一个很小且易于实现的文件传送协议。</p><p><strong>优点：使用UDP数据报。TFTP代码所占的内存较小。</strong></p><p>TFTP只支持文件传输而不支持交互。</p><p>发的一方：发完数据后在规定时间内收不到确认就要重复发送数据PDU。</p><h2 id="FTP下载文件-通过浏览器方式"><a href="#FTP下载文件-通过浏览器方式" class="headerlink" title="FTP下载文件(通过浏览器方式)"></a>FTP下载文件(通过浏览器方式)</h2><ol><li>输入地址：协议+主机号。所以是”<a href="ftp://127.0.0.1&quot;" target="_blank" rel="noopener">ftp://127.0.0.1&quot;</a> 这种形式的。</li><li>接着会让你登录自己主机的用户名和密码。</li><li>接着进入FTP服务器，选择要下载的文件，保存就可以了。</li><li>用FTP协议下载文件时，自己的浏览器要打开（FTP客户端），同时FTP服务端也会打开让客户端去下载。</li></ol><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>1982年，ARPANET的电子邮件问世。</p><p>电子邮件最重要的两个标准是：<strong>简单邮件传送协议SMTP和互联网文本报文格式[RFC 5322]</strong>。</p><p>由于互联网的SMTP只能传送可打印的7位ASCII码邮件，因此1993年提出<strong>通用互联网邮件扩充MIME</strong>。MIME在邮件首部中说明了邮件的数据类型（文本，声音，图像等）。在MIME邮件中可同时传送多种类型的数据。</p><h2 id="电子邮件系统构成"><a href="#电子邮件系统构成" class="headerlink" title="电子邮件系统构成"></a>电子邮件系统构成</h2><p>一个电子邮件系统应由三个主要组成构建：用户代理，邮件服务器，邮件发送协议和邮件读取协议（如POP3）。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/1/16ebf94a88e8c17a?w=929&h=568&f=jpeg&s=80662" alt="电子邮件的最主要的组成构建"></p><blockquote><p>发件人用户代理(SMTP客户) -&gt; 发送邮件SMTP -&gt; 发送方邮件服务器(SMTP服务器，SMTP客户) -&gt; 发送邮件SMTP -&gt; 接收方邮件服务器(SMTP服务器，POP3服务器) -&gt; 读取邮件POP3 -&gt; 收件人用户代理(POP3客户) </p></blockquote><h3 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理"></a>用户代理</h3><p>用户代理UA就是用户与电子邮件系统的接口，在大多数情况下它就是运行在用户电脑中的<strong>一个程序</strong>。因此用户代理又称为电子邮件客户端软件。用户代理提供一个很友好的接口（主要是窗口界面）来发送和接收邮件。微软的<strong>outlook</strong>和张小龙的<strong>Foxmail</strong>都是很受欢迎的电子邮件用户代理。</p><h3 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h3><p>互联网上有许多邮箱服务器可供用户选择。邮件服务器24小时不间断的工作，并且具有很大容量的邮件信箱。</p><p>邮件服务器的功能是发送和接收邮件，同时还要向发件人报告邮件传送的结果（已发送，已拒绝，丢失等）。</p><p>邮件服务器需使用两种不同的协议：SMTP用于传送邮件；POP3用于用户代理从邮件服务器读取邮件。</p><p>邮件服务器即是客户端，也是服务器。A服务器向B服务器发送邮件，A就是SMTP客户，B是SMTP服务器；反之亦然。</p><p>TCP/IP 体系的电子邮箱系统规定电子邮箱地址的格式如下： 用户名 @ 邮件服务器的域名。</p><h3 id="SMTP简单邮件传送协议"><a href="#SMTP简单邮件传送协议" class="headerlink" title="SMTP简单邮件传送协议"></a>SMTP简单邮件传送协议</h3><p>SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。至于邮件内容格式，邮件如何存储，以及邮件系统应以多快的速度来发送邮件，SMTP未做规定。<br><strong>SMTP通信三个阶段：建立连接 -&gt; 邮件传送 -&gt; 连接释放</strong>。具体内容就不展开了。</p><h3 id="POP3邮件读取协议"><a href="#POP3邮件读取协议" class="headerlink" title="POP3邮件读取协议"></a>POP3邮件读取协议</h3><p>邮局协议POP是一个非常简单，但功能有限的邮件读取协议，经过几次更新，现在使用的是1996年版本POP3，它已经成为互联网的正式标准。<br>另外一个邮件读取协议是IMAP。</p><blockquote><p><strong>最后在强调一下，不要把邮件读取协议POP3或IMAP与邮件传输协议SMTP弄混。发件人的用户代理向发送方邮件服务器发送邮件，以及发送方邮件服务器向接收方邮件服务器发送邮件，都是使用SMTP协议。只有用户代理从接收方邮件服务器上读取邮件才使用POP3。</strong></p></blockquote><h1 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>连接到互联网的计算机的协议软件需要配置的项目包括：</p><ul><li>IP地址</li><li>子网掩码</li><li>默认路由器的IP地址</li><li>域名服务器的IP地址</li></ul><p>为了省去给计算机配置IP地址的麻烦，<br>能否在计算机的生产过程中，事先给一台计算机配置好一个唯一的IP地址。（如同每一个以太网适配器拥有一个唯一的硬件的地址）</p><blockquote><p>为什么上个网要这么麻烦？能不被一次性配置好然后永远都可以上网了。</p></blockquote><p><strong>这显然是不行的。这是因为IP地址不仅包括了主机号，而且还包括了网络号。</strong></p><p>一个IP地址指出了一台计算机连接在哪一个网络上。当计算机还在生产时，无法知道它在出厂后将被连接在哪一个网络上。因此，需要连接到互联网的计算机，必须对IP地址等项目进行协议配置。</p><blockquote><p>可以人工配置吗？</p></blockquote><p>用人工进行配置很不方便，且容易出错。</p><h2 id="动态IP"><a href="#动态IP" class="headerlink" title="动态IP"></a>动态IP</h2><p>动态IP指的是在需要的时候才进行IP地址分配的方式。所谓动态就是指当你每一次上网时，电信会随机分配一个IP地址。</p><p>由于IP地址资源很宝贵，因此大部分用户上网都是使用动态IP地址的，比如通过Modem、ISDN、ADSL、有线宽频、小区宽频等方式上网的计算机，都是在每次上网的时候临时分配一个IP地址。</p><p>IP地址是一个32位二进制数的地址，理论上讲, 有大约40亿(2 的32次方)个可能的地址组合，这似乎是一个很大的地址空间。实际上，根据网络ID和主机ID的不同位数规则，可以将IP地址分为A (7 位网络ID和24位主机ID)、B (14位网络ID和16位主机ID)、C (21位网络ID和8 位主机ID)三类，由于历史原因和技术发展的差异，A 类地址和B 类地址几乎分配殆尽，能够供全球各国各组织分配的只有C 类地址。所以说IP地址是一种非常重要的网络资源。</p><p>对于一个设立了因特网服务的组织机构，由于其主机对外开放了诸如<strong>WWW 、FTP 、E-mail等访问服务，通常要对外公布一个固定的IP地址，以方便用户访问</strong>。当然，数字IP不便记忆和识别，人们更习惯于通过域名来访问主机，而域名实际上仍然需要被域名服务器(DNS )翻译为IP地址。例如，你的主页地址，用户可以方便地记忆和使用，而域名服务器会将这个域名翻译为101.12.123.234，这才是你在网上的真正地址。</p><p>而对于大多数拨号上网的用户，由于其上网时间和空间的离散性，为每个用户分配一个固定的IP地址(静态IP)是非常不可取的，这将造成IP地址资源的极大浪费。因此这些用户通常会在每次拨通ISP 的主机后，自动获得一个动态的IP地址，该地址当然不是任意的，而是该ISP 申请的网络ID和主机ID的合法区间中的某个地址。拨号用户任意两次连接时的IP地址很可能不同，但是在每次连接时间内IP地址不变。</p><h2 id="静态IP"><a href="#静态IP" class="headerlink" title="静态IP"></a>静态IP</h2><p>静态IP地址（又称固定IP地址）是长期分配给一台计算机或网络设备使用的 IP 地址。一般来说，一般是特殊的服务器或者采用专线上网的计算机才拥有固定的 IP 地址而且需要比较昂贵的费用。</p><p>静态IP是可以直接上网的IP段，该IP在ISP装机时会划分一个IP地址给你，让计算机在连接网络时不再自动获取网络地址，避免了网络连接上的困扰，宽带运营商会提供一根一个IP地址、子网掩码、网关和DNS服务器地址给用户。<strong>在未使用路由器的情况下，只需要把这根入户网线连接到电脑上，并且手动设置电脑上的IP地址，这样电脑才能上网</strong>。静态IP地址不会改变，并且主要用于互联网上的网站应用或服务。一些游戏者和使用VOIP的人往往也倾向于选择静态IP地址，因为沟通更容易。</p><p>动态IP地址和静态IP地址相对。其一：为了节省lP资源，通过电话拨号、ADSL虚拟拨号等方式上网的机器是不分配固定IP地址的。而是由ISP动态临时分配，提高lP地址利用率；其二：在局域网中为了客户机设置简便，也常采用动态分配IP地址，这意味着您每次连接互联网时得到的lP地址是不同的。尽管这不影响您访问互联网，但是您的朋友、用户却不能访问到您。因为，他们不知道您的计算机在哪里。这就像每个人都有一部电话，但您的电话号码天天都在改变。</p><p><strong>之所以出现了静态IP和动态IP，是因为IP地址不够用。现在需要上网的人太多了，但是现有的技术条件满足不了所有人同时上网。</strong></p><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段lP地址范围，客户机登录服务器时就可以自动获得服务器分配的lP地址和子网掩码。默认情况下，DHCP作为Windows Server的一个服务组件不会被系统自动安装，还需要管理员手动安装并进行必要的配置。</p><p>它提供一种机制，称为<strong>即插即用连网</strong>。这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与。</p><h3 id="主机连网过程"><a href="#主机连网过程" class="headerlink" title="主机连网过程"></a>主机连网过程</h3><p>我们知道要上网的话，主机必须要有IP地址可以。</p><p>需要IP地址的主机在启动时就向DHCP服务器广播发送<strong>发现报文（将目的IP设置为全1，即255.255.255.255）</strong>。这时，该主机就成为了DHCP客户。</p><p>发送广播报文是因为现在还不知道DHCP服务器在什么地方，所以才要发送发现报文。<br>这台主机因为还没有IP地址，所以将IP数据报的源IP地址设置为全0.这样在本地网络上的所有主机都能接收到这个广播报文，<strong>但只有DHCP服务器才对这广播进行应答</strong>：DHCP服务器先在其数据库中查找该计算机的配置信息，若找到，则返回找到的信息。若找不到，则从服务器的<strong>IP地址池</strong>中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文，表示提供了IP地址等配置信息。</p><p>但是，我们并不愿意在每个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多。<br>因此现在是使每个网络至少有一个<strong>DHCP中继代理（通常是一台路由器）</strong>，它配置了DHCP服务器的IP地址信息。当中继代理收到主机A的发现报文后，就以单播方式向DHCP服务器转发此报文，并等待其回答。收到DHCP服务器回答后，中继代理再把此提供报文发回主机A。</p><p>DHCP服务器分配给DHCP客户的IP地址是临时的，因此DHCP客户只能在<strong>一段时间</strong>内使用这个分配到的IP地址。<br>DHCP协议称之为租用期，但并未规定租用期应取为多长或至少为多长，这个数值应由DHCP服务器自己决定。</p><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><ul><li>请求租约 </li><li>提供租约 （所有收到请求报文的DHCP服务器都会回应）</li><li>选择IP租约 （可能多个DHCP服务器都会收到发现报文，所以才要选择）</li><li>确认IP租约 （DHCP服务器发送确认报文）</li><li>时间过一半，更新租用期</li><li>若DHCP服务器不同意，停止使用原IP，客户需要重新发送发现报文。</li></ul><p>DHCP很适合于经常移动位置的计算机。在Windows系统下，控制面板/网络，找到某个连接中的网络下面的菜单，找到TCP/IP协议后，<br>点击属性按钮，若选择自动获得IP地址和自动获得DNS服务器地址，就表示的是使用DHCP协议。</p><h1 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>P2P应用就是指具有P2P体系结构的网络应用，没有固定的服务器，而绝大部分的交互都是使用对等方式（P2P方式）进行的。</p><p>P2P文件分发不需要使用集中式的媒体服务器，而所有的音频/视频文件都是在普通的互联网用户之间传输的。</p><p>这其实是相当于有很多分散在各地的媒体服务器（由普通用户的计算机充当这种媒体服务器）向其他用户提供所要下载的音频/视频文件。</p><p>这种P2P文件分发方式解决了集中式媒体服务器可能出现的瓶颈问题。</p><h2 id="具有集中目录服务器的P2P工作方式"><a href="#具有集中目录服务器的P2P工作方式" class="headerlink" title="具有集中目录服务器的P2P工作方式"></a>具有集中目录服务器的P2P工作方式</h2><p>最早使用P2P工作方式的是Napster（1999年美国一个大学生写的软件）。利用这个软件可以免费下载各种MP3音乐。</p><p>Napster的出现使MP3成为网络音乐事实的标准。</p><p>Napster能够搜索音乐文件，能够提供检索功能。所有音乐文件的索引信息都集中存放在Napster目录服务器中，这个服务器起索引功能，使用者只要查找目录服务器，就可以知道应从何处下载MP3文件。</p><h3 id="Napster的工作原理"><a href="#Napster的工作原理" class="headerlink" title="Napster的工作原理"></a>Napster的工作原理</h3><ol><li>运行Napster的所有用户，都必须及时向Napster的目录服务器报告自己已经存有哪些音乐文件。</li><li>Napster目录服务器就用这些用户信息建立起一个动态数据库，集中存储了所有用户的音乐文件信息（即对象名和向对应的IP地址）。</li><li>当某个用户想下载某个MP3文件时，就向目录服务器发出查询（这个过程依然是传统的客户-服务器方式），目录检索出结果之后向用户返回存放这一文件的计算机IP地址，于是这个用户就可以从中选取一个地址下载想要得到的MP3文件（这个下载过程就是P2P方式）。</li><li>可以看出，Napster的文件传输是分散的（P2P方式）,但文件的定位是集中的(客户-服务器方式)</li></ol><blockquote><p>Napster网站于2000年被迫关闭，罪名：间接侵害版权。</p></blockquote><h2 id="具有全分布式结构的P2P文件共享程序"><a href="#具有全分布式结构的P2P文件共享程序" class="headerlink" title="具有全分布式结构的P2P文件共享程序"></a>具有全分布式结构的P2P文件共享程序</h2><p>第一代P2P文件共享软件Napster关闭之后，开始出现了以Gnutella为代表的第二代P2P文件共享软件。</p><p>G与N最大的区别在于不使用集中式的目录服务器进行查询，而是使用<strong>洪范法</strong>在大量G用户之间进行查询。</p><p>为了更加有效的在大量用户之间使用P2P技术下载共享文件，最近几年已经开发出很多P2P文件共享程序，他们使用分散定位和分散传输技术。<strong>如KaZaA,电骡eMulw,比特洪流BT</strong>等。</p><h3 id="BT工作原理"><a href="#BT工作原理" class="headerlink" title="BT工作原理"></a>BT工作原理</h3><p>BT把从<strong>对等方</strong>下载文件的数据单元称为文件块，一个文件块的长度是固定不变的。</p><p>假如一个用户要获取一个文件，（这个用户称之为对等方），一开始它并没有文件块，但新的对等方加入可能使他拥有了一些文件块，并且可以为其他对等方提供数据块。在用户陆续获得多个文件块之后，就可以凑成一整个文件。获取到完整的文件之后，可以选择退出BT（相当于自私的用户），也可以继续留在BT（相当于无私的用户）。可以随时加入或退出，即便某个文件还未完全下载完成，可以以后再加入BT把剩下的文件块再下载完成。</p><p><strong>因此，从不同的对等方获得不同的数据块，然后组装成整个文件，一般要比仅从一个地方下载整个文件要快很多。</strong></p><p>至于BT解决的问题：如何准确定位找到所需的文件块？若有多个请求，我先给谁？或者先给哪一个文件块？这个就不展开仔细讲了。</p><h3 id="下一篇讲HTTP协议。如果对你有帮助，麻烦点赞加关注哦！"><a href="#下一篇讲HTTP协议。如果对你有帮助，麻烦点赞加关注哦！" class="headerlink" title="下一篇讲HTTP协议。如果对你有帮助，麻烦点赞加关注哦！"></a>下一篇讲HTTP协议。如果对你有帮助，麻烦点赞加关注哦！</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从源头上解决HTTP面试问题 - 重学计算机网络系列(1)</title>
      <link href="/2020/01/08/cong-yuan-tou-shang-jie-jue-http-mian-shi-wen-ti-chong-xue-ji-suan-ji-wang-luo-xi-lie-1/"/>
      <url>/2020/01/08/cong-yuan-tou-shang-jie-jue-http-mian-shi-wen-ti-chong-xue-ji-suan-ji-wang-luo-xi-lie-1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2019/12/27/16f4685e332d4a4b?w=1144&h=439&f=png&s=45298" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>这是关于计算机网络的<strong>一系列专题，后续会不断更新</strong>。</li><li>因为是前端开发，所以我的重心是放在<strong>应用层</strong>，重中之重是应用层下面的<strong>HTTP协议</strong>。</li><li>学习资料来源于 <strong>《计算机网络》(第七版) 和《图解HTTP》。</strong></li><li>本篇主要分享<strong>互联网概述，计算机网络体系结构等</strong>知识。</li></ul><h1 id="互连网与互联网的区别"><a href="#互连网与互联网的区别" class="headerlink" title="互连网与互联网的区别"></a>互连网与互联网的区别</h1><h2 id="互连网"><a href="#互连网" class="headerlink" title="互连网"></a>互连网</h2><ul><li>与网络相连的计算机称为主机。智能手机也可以称为主机。</li><li>结点可以是<strong>计算机，集成器，交换机，路由器等</strong>。</li><li>计算机网络（简称网络）由<strong>若干结点</strong>和连接这些结点的<strong>链路</strong>组成。</li><li><strong>互连网</strong>：网络之间可以通过路由器互连起来，这就构成一个覆盖范围更大的计算机网络。</li><li><strong>互连网是“网络的网络”</strong>，泛指由多个计算机网络互连而成的计算机网络。网络把许多计算机连接在一起。而<strong>互连网</strong>把许多网络通过路由器连接在一起。</li></ul><h2 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h2><ul><li>也叫做因特网，不过现在不用了。</li><li>互联网(专有名词)：指当前<strong>全球最大的</strong>，开放的，由众多网络相互连接而成的特定<strong>互连网</strong>。</li><li>这也是为什么1994年中国接入互联网叫做<strong>接入</strong>，而不是其他动词。</li><li>采用<strong>TCP/IP</strong>协议族作为通信的规则，前身是<code>ARPANET</code>。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>计算机，交换机，路由器等 = 结点</li><li>结点 + 链路 = 网络</li><li>网络 + 网络 = 互连网</li><li>互联网 = 全球最大的互连网</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/11/10/16e53aaeea02db07?w=3703&h=1253&f=jpeg&s=909601" alt=""></p><h1 id="互联网发展的几个阶段"><a href="#互联网发展的几个阶段" class="headerlink" title="互联网发展的几个阶段"></a>互联网发展的几个阶段</h1><ul><li>第一阶段：1969美国国防部创建的第一个分组交换网<code>ARPANET</code>。（并不是一个互连的网络）所有要连接在<code>ARPANET</code>上的主机都直接与最近的结点交换机相连。<ul><li>第二阶段：20世纪70年代中期，开始研究<strong>多种网络互连的技术</strong>，导致互连网络的出现。互联网的雏形。</li></ul></li><li>第三阶段：1983年，<code>TCP/IP</code>协议成为<code>ARPANET</code>上的标准协议，使所有使用<code>TCP/IP</code>协议的计算机都能利用互联网相互通信。互联网诞生。</li><li>第四阶段：1985年。建成了三级结构的互联网<code>NSFNET</code>。分为主干网，地区网，校园网。基本覆盖了全美国主要的大学和研究所。</li><li>第五阶段：世界上许多公司纷纷接入到互联网，网络通信急剧增大，满足不了需求。美国政府决定交给私人公司来经营，开始收费。于是，逐渐形成<strong>多层次ISP结构</strong>的互联网。1993年开始，三级结构的互联网<code>NSFNET</code>逐渐被若干个商用的互联网主干网替代。</li></ul><h1 id="ISP（互联网服务提供商）"><a href="#ISP（互联网服务提供商）" class="headerlink" title="ISP（互联网服务提供商）"></a>ISP（互联网服务提供商）</h1><ul><li>中国电信，中国联通，中国移动等公司是中国最有名的ISP。</li><li>ISP可以从互联网管理机构申请到很多IP地址。<strong>主机必须有IP地址才能上网</strong>，同时还有通信线路，路由器等联网设备。缴纳费用就能能获取所需IP地址的使用权。</li><li>所谓上网就是通过ISP获得的IP地址接入互联网。</li><li>ISP分为主干ISP，地区ISP，本地ISP。<ul><li>主干ISP由专门的公司创建和维持，服务面积最大（一般能覆盖国家范围）</li><li>地区ISP是一些较小的ISP。</li><li>本地ISP给用户提供直接的服务。本地ISP可以是一个仅仅提供互联网服务的公司，也可以是一个拥有网络并向自己雇员提供服务的企业，或者是大学。</li></ul></li><li>主机A和主机B通信的过程。主机A –&gt; 本地ISP –&gt; 地区ISP –&gt; 主干ISP –&gt; 地区ISP –&gt; 本地ISP –&gt; 主机B</li><li>上面这种通信要经过层层阻拦，是否能绕过主干ISP，地区ISP直接和地区ISP直接通信呢？可以的。<strong>互联网交换点IXP</strong>的主要作用是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。 主机A –&gt; 本地ISP –&gt; 地区ISP –&gt; 地区ISP –&gt; 本地ISP –&gt; 主机B<br><img src="https://user-gold-cdn.xitu.io/2019/11/10/16e53ae0d72b8ae1?w=678&h=335&f=png&s=79228" alt=""></li></ul><h1 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h1><ul><li>从工作方式可以分为两大块：边缘部分 + 核心部分。<ul><li>边缘部分：由所有连接在互联网上的主机组成，用户直接使用。</li><li>核心部分：由大量网络和连接这些网络的路由器组成。</li></ul></li><li>边缘部分的通信方式<ul><li>客户-服务器方式（C/S）。客户是服务请求方，服务器是服务提供方。</li><li>对等连接方式（P2P）。两台主机通信并不区分哪一个是服务请求方哪一个是提供方。只要两台主机都运行了对等连接软件就可以通信，相互下载对方硬盘里面的文档。</li></ul></li><li>核心部分<ul><li>路由器。它是一种专用计算机。路由器是实现<strong>分组交换</strong>的关键构件，其任务是转发收到的分组。<h2 id="何为分组交换"><a href="#何为分组交换" class="headerlink" title="何为分组交换"></a>何为分组交换</h2></li></ul></li><li>电路交换： 建立连接（占用通信资源） -&gt; 通话（一直占用通信资源） -&gt; 释放连接（归还通信资源）。在通话的全部时间里，通话的两个用户始终占用端到端的通信资源。</li><li>分组交换：采用<strong>存储转发</strong>技术。要发送整块数据，这块数据被称为一个<strong>报文</strong>。在发送之前，把报文分成一个个更小的等长数据段，并在头部加上包头。</li><li><strong>（首部 + 数据 = 分组）X （很多个） = 报文</strong></li><li>路由器的作用就是<strong>用来转发这些分组</strong>的。路由器收到一个分组，先暂存一下，检查头部，查找转发表，交给下一个路由器，一步一步以存储转发的方式给目的主机。分组交换在传输数据之前不必占用一条端到端的通信资源，并且省去了建立连接和释放连接的开销，<strong>传输数据效率更高</strong>。</li></ul><blockquote><p>为了理解<strong>分组</strong>，我还是更愿意称之为<strong>小报文</strong>，更方便记忆。因为称之为分组我感觉太拗口了。</p></blockquote><ul><li>总结  <ul><li>电路交换。整个报文连续从源点到终点，好像在一个管道中传送。适合大量数据传输。</li><li>报文交换。整个报文先到达相邻结点，全部储存下来查找转发表，转发到下一个结点。</li><li>分组交换。单个分组（整个报文的一小部分）传送给相邻结点，存储下来后查找转发表，转发到下一个结点。（原理采用报文交换）灵活。</li></ul></li></ul><h1 id="七层协议和四层协议的由来"><a href="#七层协议和四层协议的由来" class="headerlink" title="七层协议和四层协议的由来"></a>七层协议和四层协议的由来</h1><p><img src="https://user-gold-cdn.xitu.io/2019/11/10/16e53ec3b6abd5b4?w=686&h=409&f=png&s=168302" alt=""><br>先看一个很简单的例子：连接在网络上的两台计算机要互相传送文件。<br>  要实现这种功能需要做什么呢？</p><ul><li>两者之间要有传输数据的通路。</li><li>要保证通道的正确发送和接收。</li><li>要告诉网络如何识别接收数据的计算机。</li><li>必须检查对方是否开机，并且联网了。</li><li>发起通信的计算机的软件必须搞清楚在对方的软件是否做好接收文件和存储文件的准备。</li><li>若计算机文件格式不兼容，则至少其中一台计算机应完成格式转换功能。</li><li>对于出现的各种差错意外，如数据传输错误，重复，丢失，是否有可靠的措施保障对方能接受到正确的文件。</li></ul><p>以上在种种，表明相互通信的两个计算机系统必须高度协调工作才行，为了协调，提出了<strong>分层</strong>的方法。用<strong>分层</strong>把问题分而治之。</p><h2 id="协议与划分层次"><a href="#协议与划分层次" class="headerlink" title="协议与划分层次"></a>协议与划分层次</h2><p>  在计算机网络要做到有条不紊的交换数据，就必须遵守实现约好的规则。这些为进行网络中的数据交换而建立的规则，标准，约定称之为<strong>网络协议</strong>，也可简称为<strong>协议</strong>。协议有三要素。</p><ul><li>语法。数据与控制信息的结构或格式。</li><li>语义。即需要发出何种控制信息，完成何种动作以及做出何种响应。</li><li>同步。事件实现顺序的详细说明。 </li></ul><p>  <strong>我们想连接在网络上的另外一台计算机做点什么事，都需要有协议。</strong></p><h2 id="立贤不立长"><a href="#立贤不立长" class="headerlink" title="立贤不立长"></a>立贤不立长</h2><ul><li>1974年，美国IBM公司宣布了<code>系统网络体系结构SNA</code>。这个网络标准是按照分层的方法制定的。不久其他一些公司也相继推出自己公司的体系结构。</li><li>不同的网络体系结构出现后，使得同一个公司生产的各种设备都能很容易地互连成网。但由于<strong>网络体系结构的不同，不同公司的设备很难互相连通</strong>。</li><li>为了使得不同网络体系结构的用户迫切要求能够互相交换信息，国际化标准组织ISO在1977成立专门机构研究该问题。他们提出一个试图使各种计算机在世界范围内互连成网的标准框架，即OSI/RM,<strong>简称OSI</strong>。只要遵循OSI标准，一个系统就可以和世界上任何地方的，也遵守这一标准的其他任何系统进行通信。</li><li>1983年，OSI提出了<strong>七层协议。</strong></li><li>但是，到了90年代初期，尽管整套的OSI国际标准已经制定出来，但基于<strong>TCP/IP的四层协议</strong>的互联网已抢先在全球相当大的范围成功运行。OSI失败了。</li><li>得到最广泛应用的不是法律上的标准OSI，而是非国际标准TCP/IP。<strong>TCP/IP被当做事实的国际标准</strong>。<blockquote><ul><li>现在人们提到的TCP/IP并不一定单指TCP和IP两个具体的协议，而是往往表示互联网所使用的<strong>整个TCP/IP协议族</strong>。</li><li>网络协议的一个重要的特定是必须把所有不利的条件事先估计到，不能假设一切都是正常的和非常理想的。</li></ul></blockquote></li></ul><h2 id="四层协议"><a href="#四层协议" class="headerlink" title="四层协议"></a>四层协议</h2><ul><li>应用层。<br>  是体系结构的最高层。任务是通过应用进程间的交互来完成特定网络应用。应用层定义的是应用进程间通信和交互的规则。在互联网的应用层协议很多，如<br>  <code>域名系统NDS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议。</code>我们把应用层交互的数据单元称为报文。<ul><li>运输层。<br>负责两台主机中进程之间的通信提供通用的数据传输服务。主要使用两种协议。<ul><li><code>传输控制协议TCP</code>。数据传输的单位是报文段。</li><li><code>用户数据报协议UDP</code>。提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性），数据传输的单位是用户数据报。</li></ul></li><li>网络层。<br>负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组（小报文）或包进行传送。<br>网络层的另外一个任务就是要选择合适的路由，使源主机运输层所传下来的分组（小报文）能够通过路由器找到目的的主机。<code>IP协议</code>。</li><li>数据链路层（链路层）。<br>两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要专门的链路层协议。<br><code>在两个相邻结点之间传送数据时，数据链路层把网络层交下来的IP数据报组装成帧，在两个相邻结点的链路上传送帧，每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制）</code><br>在接收数据时，接收到一个帧，抽出数据部分，提交给网络层。</li></ul></li></ul><h1 id="捋一捋两个主机之间通信的全过程"><a href="#捋一捋两个主机之间通信的全过程" class="headerlink" title="捋一捋两个主机之间通信的全过程"></a>捋一捋两个主机之间通信的全过程</h1><p>主机A向主机B传输数据。</p><ol><li>主机A把数据给应用层，应用层加上必要的控制信息。</li><li>应用层的数据再给运输层，运输层再加上控制信息。</li><li>运输层的数据给网络层，网络层再加上控制信息。</li><li>网络层的数据给链路层，链路层给数据加上首部和尾部。</li><li>链路层再把数据给物理层，物理层传输单位是比特，不加控制信息。</li><li>接着数据到达路由器，路由器分析控制信息。</li><li>路由器的分组（小报文）传给物理层。</li><li>物理层再传给链路层，链路层分析控制信息并剥去，找到上层的网络层。</li><li>网络层接收到数据，分析控制信息并剥去，找到上层的运输层。</li><li>运输层接收到信息，分析并剥去控制信息，找到应用层。</li><li>应用层剥去控制信息，把数据给主机B。</li></ol><p><strong>用一个简单的例子描述：</strong><br>  一封信从最高层向下传，每经过一层就包上一个新的信封，写上必要的地址信息。到达最底层时，向上传，每经过一层就剥去一层信封，到达最高层的时候，去取出发信人的信交给收信人就可以了。</p><h3 id="下一篇文章讲应用层的各种协议，HTTP除外，HTTP是重点应该单拎起来讲。-如果对你有帮助，麻烦点赞加关注哦！"><a href="#下一篇文章讲应用层的各种协议，HTTP除外，HTTP是重点应该单拎起来讲。-如果对你有帮助，麻烦点赞加关注哦！" class="headerlink" title="下一篇文章讲应用层的各种协议，HTTP除外，HTTP是重点应该单拎起来讲。      如果对你有帮助，麻烦点赞加关注哦！"></a>下一篇文章讲应用层的各种协议，HTTP除外，HTTP是重点应该单拎起来讲。      如果对你有帮助，麻烦点赞加关注哦！</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式布局方法总结</title>
      <link href="/2019/11/10/xiang-ying-shi-bu-ju-fang-fa-zong-jie/"/>
      <url>/2019/11/10/xiang-ying-shi-bu-ju-fang-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局。传统的开发方式是PC端开发一套，手机端再开发一套，而使用响应式布局只要开发一套就够。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>面对不同分辨率设备灵活性强</li><li>能够快捷解决多设备显示适应问题<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2></li><li>仅适用布局、信息、框架并不复杂的部门类型网站</li><li>兼容各种设备工作量大，效率低下</li><li>代码累赘，会出现隐藏无用的元素，加载时间加长</li><li>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</li><li>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况<h1 id="响应式与自适应区别"><a href="#响应式与自适应区别" class="headerlink" title="响应式与自适应区别"></a>响应式与自适应区别</h1></li><li>响应式：只需要开发一套代码。<br>  响应式设计通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。</li><li>自适应：需要开发多套界面。<br>  通过检测视口分辨率，来判断当前访问的设备是：pc端、平板、手机，<strong>从而请求服务层，返回不同的页面。</strong></li></ul><h1 id="响应式布局方法一：媒体查询"><a href="#响应式布局方法一：媒体查询" class="headerlink" title="响应式布局方法一：媒体查询"></a>响应式布局方法一：媒体查询</h1><p>使用<code>@media</code>媒体查询可以针对不同的媒体类型定义不同的样式，特别是响应式页面，可以针对不同屏幕的大小，编写多套样式，从而达到自适应的效果。举例来说：</p><pre><code>@media screen and (max-width: 960px){    body{      background-color:#FF6699    }}@media screen and (max-width: 768px){    body{      background-color:#00FF66;    }}@media screen and (max-width: 550px){    body{      background-color:#6633FF;    }}@media screen and (max-width: 320px){    body{      background-color:#FFFF00;    }}</code></pre><p>上述的代码通过媒体查询定义了几套样式，通过max-width设置样式生效时的最大分辨率，上述的代码分别对分辨率在0～320px，320px～550px，550px～768px以及768px～960px的屏幕设置了不同的背景颜色。</p><p>通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局，<strong>比如我们为不同分辨率的屏幕，设置不同的背景图片。比如给小屏幕手机设置@2x图，为大屏幕手机设置@3x图，通过媒体查询就能很方便的实现。</strong></p><p>但是媒体查询的缺点也很明显，如果在<strong>浏览器大小改变时，需要改变的样式太多</strong>，那么多套样式代码会很繁琐。</p><h1 id="响应式布局方法二：百分比"><a href="#响应式布局方法二：百分比" class="headerlink" title="响应式布局方法二：百分比%"></a>响应式布局方法二：百分比%</h1><p>比如当浏览器的宽度或者高度发生变化时，通过百分比单位，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。</p><p>height,width属性的百分比依托于父标签的宽高。但是，<strong>padding、border、margin等属性的情况又不一样？</strong></p><ul><li>子元素的top和bottom如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度，同样，子元素的left和right如果设置百分比，则相对于直接非static定位(默认定位的)父元素的宽度。</li><li>子元素的padding如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width，而与父元素的height无关。</li><li>子元素的margin如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的width</li><li>border-radius不一样，如果设置border-radius为百分比，则是相对于自身的宽度</li></ul><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul><li>计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。 </li><li>各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，而margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。</li><li>所以，<strong>不建议用%来做响应式布局。</strong><h1 id="响应式布局方法三：vw-vh"><a href="#响应式布局方法三：vw-vh" class="headerlink" title="响应式布局方法三：vw/vh"></a>响应式布局方法三：vw/vh</h1>css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度。<br>任意层级元素，在使用vw单位的情况下，1vw都等于视图宽度的百分之一。</li></ul><p>与百分比布局很相似，但更好用。</p><h1 id="响应式布局方法四：rem"><a href="#响应式布局方法四：rem" class="headerlink" title="响应式布局方法四：rem"></a>响应式布局方法四：rem</h1><p>rem单位是相对于字体大小的html元素，也称为根元素。<br>默认情况下，html元素的font-size为16px。所以此时1rem = 16px。</p><h2 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h2><pre><code>@media screen and (max-width: 414px) {  html {    font-size: 18px  }}@media screen and (max-width: 375px) {  html {    font-size: 16px  }}@media screen and (max-width: 320px) {  html {    font-size: 12px  }}</code></pre><p>利用rem和媒体查询，在分辨率发生变换时，给它不同的font-size。</p><h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><pre><code>//动态为根元素设置字体大小function init () {    // 获取屏幕宽度    var width = document.documentElement.clientWidth    // 设置根元素字体大小。此时为宽的10等分    document.documentElement.style.fontSize = width / 10 + &#39;px&#39;}//首次加载应用，设置一次init()// 监听手机旋转的事件的时机，重新设置window.addEventListener(&#39;orientationchange&#39;, init)// 监听手机窗口变化，重新设置window.addEventListener(&#39;resize&#39;, init)</code></pre><p>理解：上面代码实现了，无论设备可视窗口如何变化，始终设置rem为width的1/10.即实现了百分比布局。就没有第一版的媒体查询那样僵硬。</p><blockquote><p>以上代码需在dom之前写入（可放在head里面第一个script标签）</p></blockquote><h1 id="利用UI框架实现响应式布局"><a href="#利用UI框架实现响应式布局" class="headerlink" title="利用UI框架实现响应式布局"></a>利用UI框架实现响应式布局</h1><p>其实，现在的主流UI框架都会考虑到响应式布局这个问题，比如elementUI，iview等框架提供了<strong>栅格</strong>系统，<code>&lt;row&gt;</code>搭配<code>&lt;col&gt;</code>来实现响应式布局。<br>所以在工作中直接拿来使用就完事了。</p><h1 id="移动端响应式布局-viewport"><a href="#移动端响应式布局-viewport" class="headerlink" title="移动端响应式布局 viewport"></a>移动端响应式布局 viewport</h1><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;</code></pre><ul><li>width=device-width: 是自适应手机屏幕的尺寸宽度。</li><li>maximum-scale:是缩放比例的最大值。</li><li>minimum-scale:是缩放比例的最小值。</li><li>inital-scale:是缩放的初始化。</li><li>user-scalable:是用户的可以缩放的操作。</li></ul><blockquote><p>这个写法是用户不能缩放的页面设计。因为，如果页面能缩放的话，就会影响用户的体验，在手机端，我们都可以找到点击的按钮或者自己感兴趣的菜单进行操作。其二：就是我们如果让页面缩放的话，就完全暴露了我们手机app的程序是html的架构了。所以，我们专为移动端的设计页面的时候，就不需要用户进行缩放了。</p></blockquote><h1 id="flexible-js"><a href="#flexible-js" class="headerlink" title="flexible.js"></a>flexible.js</h1><p><code>flexible.js</code>是阿里手淘团队开发的。用来解决移动端的适配问题。    </p><ul><li>假设现在要适配一个iphone6的设备。<ul><li>设计师给了一个750px宽度的设计稿（注意这里是750px而不是375px）</li><li>前端工程师用750px的这个比例开始还原</li><li>把宽高是px的转换成rem</li><li>字体使用px而不使用rem</li><li><code>flexible.js</code>会自动判断dpr进行整个布局视口的放缩  </li></ul></li></ul><pre><code>至于`flexible.js`怎么使用的可以自行搜索，因为本人移动端做得少，就不再多说了。</code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.im/entry/59e70320f265da431c6f6514" target="_blank" rel="noopener">前端移动端适配总结</a> </p><p><a href="https://juejin.im/post/5caaa230e51d452b672f9703" target="_blank" rel="noopener">前端响应式布局原理与方案（详细版</a>   </p><p><a href="https://juejin.im/post/5b39905351882574c72f2808" target="_blank" rel="noopener">响应式布局的常用解决方案对比(媒体查询、百分比、rem和vw/vh）</a></p><p><a href="https://zhongjunhaoz.github.io/">欢迎访问我的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + GitHub 生成个人博客</title>
      <link href="/2019/10/20/hexo-github-sheng-cheng-ge-ren-bo-ke/"/>
      <url>/2019/10/20/hexo-github-sheng-cheng-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章记录一下我生成个人博客的过程。顺便分享给有需要的人。</p><p>如果您需要开发个人博客，需要：</p><ul><li>最基础的前端知识就行。</li><li>用<code>markdown</code>的语法来写文章。</li><li>有<code>GitHub</code>账号。</li><li>安装好了<code>Git</code>和<code>node</code></li><li>知道<code>npm</code>操作。</li></ul><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><p><code>Hexo</code> 是一个快速、简洁且高效的博客框架。<code>Hexo</code>使用 <code>Markdown</code>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p><code>hexo</code> 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在<code>hexo</code>通过<code>markdown</code>编写的文章，然后<code>hexo</code>帮我们生成静态的<code>html</code>页面，然后，将生成的html上传到我们的服务器（或者是GitHub上）。<strong>简而言之：hexo是个静态页面生成、上传的工具</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/16/16dd438b19052027?w=944&h=170&f=png&s=21313" alt=""></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><pre><code>$ npm install hexo-cli -g //全局安装hexo$ hexo init blog //对blog文件夹初始化(这一步会很慢)$ npm install //安装所需要的组件$ hexo g //编译生成静态页面$ hexo s //启动本地服务</code></pre><p>启动本地服务之后，根据终端的提示打开<code>http://localhost:4000/</code>可以在本地查看到博客。如下图所示。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/19/16de1f68dde51b93?w=1887&h=899&f=png&s=1209434" alt=""></p><h2 id="绑定GitHub"><a href="#绑定GitHub" class="headerlink" title="绑定GitHub"></a>绑定GitHub</h2><p>上一步在本地查看到了博客，如果别人想通过在浏览器输入地址来访问你的博客怎么办？</p><p>让你的<code>Hexo</code>与<code>GitHub</code>仓库绑定。这样别人就可以访问了。</p><h3 id="获取本机SSH口令"><a href="#获取本机SSH口令" class="headerlink" title="获取本机SSH口令"></a>获取本机SSH口令</h3><p><code>ssh keys</code>就是用来使本地<code>git</code> 项目与github联系。</p><ul><li><p>提交过代码到<code>GitHub</code>上的同学代表着已经让<code>git</code>仓库绑定到了<code>GitHub</code>上了。就不必再配置<code>SSH 口令了</code>。</p></li><li><p>如果没有绑定的话。</p><ul><li><code>$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; //ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot;</code></li><li>提示<code>Enter passphrase (empty for no passphrase):</code>设置密码</li><li><code>Enter same passphrase again</code> 再次输入</li><li><code>Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub.</code>代表设置成功。</li><li>找到<code>id_rsa.pub</code>文件，复制里面所有内容。</li><li>来到<code>GitHub</code>主页面，路径为<code>Settings/SSH and GPG keys/New SSH key</code>。</li><li><code>Title: blog //不一定非要是blog</code> </li><li><code>key: 复制的内容</code></li><li><code>Add SSH key</code> 完成SSH key 的绑定。</li></ul></li><li><p>最后还要这一步。</p><pre><code>$git config --global user.name &quot;你的名字&quot;$git config --global user.email &quot;你的邮箱&quot;</code></pre></li></ul><blockquote><p>Git还不清楚的同学可以戳<a href="https://juejin.im/post/5d157bf3f265da1bcc1954e6" target="_blank" rel="noopener">Git笔记</a></p></blockquote><h3 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h3><ul><li>平时我们创建仓库会直接写你要创建的仓库名就OK。比如建一个<code>Node</code>的仓库直接填<code>Node</code>就行了。</li></ul><p><strong>但是，博客的仓库地址不一样，必须为<code>你的GitHub名+ github.io</code> 。比如我的博客仓库名就叫做<code>zhongjunhaoz.github.io</code>。必须按照此种格式去填写。</strong></p><h2 id="blog文件的基本配置"><a href="#blog文件的基本配置" class="headerlink" title="blog文件的基本配置"></a>blog文件的基本配置</h2><ul><li>配置<code>_config.yml</code>文件。<pre><code>title: **My Blog** #博客名subtitle: to be continued... #副标题description: My blog #给搜索引擎看的，对网站的描述，可以自定义author: **Yourname** #作者，在博客底部可以看到email: yourname@yourmail.com #你的联系邮箱language: **zh-CN** #中文。如果不填则默认英文timezone: Asia/Shanghai# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: http://yoursite.com# Writing 文章布局、写作格式的定义，不修改# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文# Server 不修改# Date / Time format 日期格式，可以修改成自己喜欢的格式# Pagination 每页显示文章数，可以自定义，贴主设置的是10</code></pre></li></ul><pre><code>- 配置`_config.yml`文件下的`Deploy`</code></pre><p>deploy:<br>  type: git<br>  repository: 你的仓库地址<br>  name: GitHub名<br>  email: 邮箱<br>  branch: master</p><pre><code>- 安装插件`npm install hexo-deployer-git --save`- 准备上传到github仓库。</code></pre><ul><li>hexo clean //清除之前的缓存</li><li>hexo g  // 生成静态文件</li><li>hexo d  //上传至仓库<br>```</li><li>接着在浏览器输入<code>你的GitHub名+ github.io</code>就可以访问你的个人博客了。</li><li><a href="https://zhongjunhaoz.github.io/">https://zhongjunhaoz.github.io/</a>  这是我的个人博客。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/19/16de28c0c64ce460?w=1897&h=1005&f=png&s=554623" alt=""></p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>原生的博客主题有点丑，我们可以选择自己喜欢的主题添加到自己的博客中。</p><ul><li>官方主题库：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a></li><li>在这里我选择的是：<a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">闪烁之狐</a>。<strong>里面有对更改主题配置的文档。</strong></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="首次安装可能需要"><a href="#首次安装可能需要" class="headerlink" title="首次安装可能需要"></a>首次安装可能需要</h3><pre><code>npm install hexo -g #全局安装 npm update hexo -g #升级 hexo init #初始化</code></pre><h3 id="写博客最常用"><a href="#写博客最常用" class="headerlink" title="写博客最常用"></a>写博客最常用</h3><pre><code>hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成静态Htmlhexo s == hexo server #会监视文件变动并自动更新，您无须重启服务器hexo d == hexo deploy #部署</code></pre><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><pre><code>hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo server -s #静态模式hexo clean #清除缓存 网页正常情况下可以忽略此条命令</code></pre><h3 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h3><pre><code>hexo generate --watch  #监视文件变动</code></pre><h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><pre><code>hexo publish [layout] &lt;title&gt;</code></pre><h2 id="网站效果"><a href="#网站效果" class="headerlink" title="网站效果"></a>网站效果</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/20/16de7143fc28e327?w=1898&h=964&f=png&s=1542846" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2019/10/20/16de714eac983fbf?w=1899&h=962&f=png&s=1338643" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2019/10/20/16de715fadb4cf90?w=1899&h=957&f=png&s=570306" alt=""></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">hexo常用命令笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂CSS中的字体单位大小</title>
      <link href="/2019/10/20/yi-wen-gao-dong-css-zhong-de-zi-ti-dan-wei-da-xiao/"/>
      <url>/2019/10/20/yi-wen-gao-dong-css-zhong-de-zi-ti-dan-wei-da-xiao/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习的过程中,发现CSS有很多可以描述单位的尺寸。比如<code>px</code>,<code>em</code>,<code>rem</code>,<code>vw</code>等等。平时也没有深究，一来是没时间，二来是在我学习清单中优先级过低。一直想彻底弄明白，一直耽搁到现在。现在花上一点时间来整理一下，彻底弄懂它。</p><h1 id="CSS长度单位"><a href="#CSS长度单位" class="headerlink" title="CSS长度单位"></a>CSS长度单位</h1><ul><li>绝对长度单位。<br>绝对长度单位表示为一个固定的值，不会改变。<strong>不利于页面渲染。</strong><ul><li>in,英寸</li><li>cm, 里面</li><li>mm, 毫米</li><li>pt</li><li>pc</li></ul></li><li>相对长度单位。<br>其长度单位会随着它的参考值的变化而变化。<ul><li>px,像素</li><li>em,元素的字体高度</li><li>%,百分比</li><li>rem,根元素的font-size</li><li>vm,视窗宽度，1vw=视窗宽度的1%</li><li>vh,视窗高度，1vh=视窗高度的1%</li></ul></li></ul><h1 id="物理像素-设备像素"><a href="#物理像素-设备像素" class="headerlink" title="物理像素(设备像素)"></a>物理像素(设备像素)</h1><p>比如有一个图片，细分，最小单位就是像素。也就是说，图片由许多的像素构成。像素是小方块，这些小方块都有一个明确的位置和被分配的色彩数值，小方格颜色和位置就决定该图像所呈现出来的样子。</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/25/16c27296fdd981a5?w=261&h=193&f=png&s=102964" alt=""><br><strong>一个设备生产出来，它们的像素就已经确定了。iPhone5的分辨率是<code>640x1136px</code>,代表屏幕由640行，1136列像素小方块组成。</strong></p><pre><code>为了理解像素和避免与CSS像素混淆，可以将物理像素当做物理小方块。比如iPhone5的像素是640X1136px,可以当做640*1136个小方块。</code></pre><h1 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h1><p>也叫做解析度，解像度。可以从显示分辨率与图像分辨率两个方向来分类。</p><ul><li>屏幕分辨率。是屏幕图像的精密度，是指显示器所能显示的像素有多少，即显示器可以可以显示的小方块有多少个。<ul><li><strong>显示器的可显示的小方块越多，画面就越精细，同样的屏幕区域内能显示的信息也越多</strong></li><li>可以把整个图像想象成是一个大型的棋盘，而分辨率的表示方式就是所有经线和纬线交叉点的数目。棋盘的小方块越多，可以放的棋子就越多。</li><li>显示分辨率一定的情况下，显示屏越小图像越清晰，反之，显示屏大小固定时，显示分辨率越高图像越清晰。(<strong>小方块一样多的情况下，显示屏越小越清晰；屏幕大小一样大的时候，小方块越多图形越清晰</strong>)<h1 id="CSS像素px"><a href="#CSS像素px" class="headerlink" title="CSS像素px"></a>CSS像素px</h1>CSS像素的单位也叫做<strong>px</strong>。它是图像显示的基本单元，既不是一个确定的物理量，也不是一个点或者小方块，而是一个抽象概念。所以在谈论像素时一定要清楚<strong>它的上下文！</strong></li></ul></li><li>为了保证阅读体验一致，CSS可以自动在不同设备之间可以调节。即一份代码可以在不同的大小的设备之间显示，并且可以保证阅读体验一致。</li><li>默认情况下一个CSS像素应该是等于一个物理像素的宽度。</li><li>但是在高PPI的设备上，CSS像素甚至在默认状态下就相当于多个物理像素的尺寸。比如iPhone的屏幕对比一般的手机屏幕会看起来更精细清晰一些。</li><li>在浏览器上通过<code>ctrl +/-</code>可以扩大缩小屏幕，其实就是屏幕分辩率的调低/调高。<code>ctrl +</code>屏幕放大，分辨率降低。</li><li>iPhone6,7,8都是两倍屏手机，即一个CSS像素等于2物理像素。iPhone6Plus等是三倍屏手机，一个CSS像素等于3物理像素。</li><li>以iPhone6为例，设计稿给出一个图片宽高为40*40。在实际开发中要除以2，宽高要写成20x20。因为iPhone6是两倍屏手机。</li></ul><h1 id="em"><a href="#em" class="headerlink" title="em"></a>em</h1><p>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，<strong>则相对于浏览器的默认字体尺寸,浏览器字体默认为16px</strong>。</p><ul><li>所以，1em = 16px。默认情况下。<h2 id="如何高效使用em呢"><a href="#如何高效使用em呢" class="headerlink" title="如何高效使用em呢"></a>如何高效使用em呢</h2></li><li>body里声明font-size:62.5%。即全局声明<code>1em = 16px * 62.5% = 10px</code></li><li>之后可以把<code>em</code>当做<code>px</code>使用。当然此时，<code>1em = 10px</code></li><li>如果在父容器里说明了<code>font-size:20px</code>,那么在子容器里的<code>1em</code>就等于<code>20px</code>。</li></ul><h1 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h1><p>rem单位是相对于字体大小的<strong>html元素</strong>，也称为根元素。</p><pre><code>html {  font-size: 10px; /* 不建议设置 font-size: 62.5%; 在 IE 9-11 上有偏差，具体表现为 1rem = 9.93px。 */}.sqaure {  width: 5rem;  /* 50px */  height: 5rem; /* 50px */}</code></pre><h1 id="em与rem"><a href="#em与rem" class="headerlink" title="em与rem"></a>em与rem</h1><ul><li>rem是相对于根元素（html）的字体大小，而em是相对于其父元素的字体大小。</li><li>em最多取到小数点的后三位<pre><code>&lt;style&gt;html{ font-size: 20px; }body{   font-size: 1.4rem;  /* 1rem = 28px */  padding: 0.7rem;  /* 0.7rem = 14px */} div{  padding: 1em;  /* 1em = 28px */}span{  font-size:1rem;  /* 1rem = 20px */  padding: 0.9em;  /* 1em = 18px */}&lt;/style&gt;</code></pre></li></ul><html>  <body>    <div>         <span></span>      </div>  </body></html>```上面的例子中，发现了一个有意思的情况。`em 会层层继承父元素的字体大小`，很容易造成字体大小的混乱。所以以后用`rem`会更好。<h1 id="rpx"><a href="#rpx" class="headerlink" title="rpx"></a>rpx</h1><p><strong>rpx 是微信小程序解决自适应屏幕尺寸的尺寸单位。微信小程序规定屏幕的宽度为750rpx。</strong></p><p>无论是在iPhone6上面还是其他机型上面都是750rpx的屏幕宽度，拿iPhone6来讲，屏幕宽度为375px，把它分为750rpx后， 1rpx = 0.5px = 1物理像素。</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/25/16c29bee71b0c4c4" alt=""></p><h1 id="vw-和-vh"><a href="#vw-和-vh" class="headerlink" title="vw 和 vh"></a>vw 和 vh</h1><ul><li><code>vw</code>,视窗宽度，1vw=视窗宽度的1%</li><li><code>vh</code>,视窗高度，1vh=视窗高度的1%</li><li>如果浏览器的高是900px,1vh求得的值为9px。同理，如果显示窗口宽度为750px,1vw求得的值为7.5px。</li></ul><h1 id="vmin-和-vmax"><a href="#vmin-和-vmax" class="headerlink" title="vmin 和 vmax"></a>vmin 和 vmax</h1><ul><li>vmin和vmax是相对于视口的高度和宽度两者之间的最小值或最大值。</li><li>浏览器的高为1100px、宽为700px，那么1vmin就是7px，1vmax就是11px</li><li>浏览器的高为800px，宽为1080px，那么1vmin也是8px，1vmax也是10.8px</li><li>vmin取宽度高度两者更小者/100</li><li>vmax取宽度高度两者更大者/100<h2 id="哪些地方可以用到"><a href="#哪些地方可以用到" class="headerlink" title="哪些地方可以用到"></a>哪些地方可以用到</h2></li><li>一个总是在屏幕上可见的元素。使用高度和宽度设置为低于100的vmin值将可以实现这个效果。</li><li>一个总是覆盖可视窗口的正方形(一直接触屏幕的四条边)<pre><code>.box {  height: 100vmax;  width: 100vmax;}</code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><a href="https://github.com/wujunchuan/wujunchuan.github.io/issues/15" target="_blank" rel="noopener">前端开发中像素的概念</a></li></ul><p><a href="http://www.360doc.com/content/19/0327/15/63018409_824523443.shtml" target="_blank" rel="noopener">最全的CSS尺寸单位介绍</a></p><p><a href="http://www.divcss5.com/css3-style/c33196.shtml" target="_blank" rel="noopener">CSS3中常见的单位</a><br><a href="http://www.mamicode.com/info-detail-2439333.html" target="_blank" rel="noopener">移动设备分辨率（终于弄懂了为什么移动端设计稿总是640px和750px）</a></p><p><a href="https://www.jianshu.com/p/e377208aaadd" target="_blank" rel="noopener">几个CSS的单位你需要了解一下</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack入门(3) - 核心内容</title>
      <link href="/2019/10/20/webpack-ru-men-3-he-xin-nei-rong/"/>
      <url>/2019/10/20/webpack-ru-men-3-he-xin-nei-rong/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5d19a847518825793f6fcd9f" target="_blank" rel="noopener">webpack入门(2)-安装，配置，环境</a>，上节传送门。</p><h1 id="Entry-入口"><a href="#Entry-入口" class="headerlink" title="Entry(入口)"></a>Entry(入口)</h1><p>简单提一下，Entry是webpack的入口文件，一开始运行webpack它会找到<code>webpack.config.js</code>里的<code>Entry</code>。它会从这开始着手，构建内部依赖图。入口点可以有一个或多个。</p><h2 id="entry的类型"><a href="#entry的类型" class="headerlink" title="entry的类型"></a>entry的类型</h2><ul><li>string类型<pre><code>一个入口entry:&#39;./src/main.js&#39;</code></pre></li><li>array类型<pre><code>配置了多个入口entry: [&#39;./src/main1.js&#39;, &#39;./src/main2.js&#39;]</code></pre></li><li>object类型<pre><code>对象类型entry: {  a: &#39;./src/main.js&#39;,  b: [&#39;./src/main1.js&#39;, &#39;./src/main2.js&#39;]}</code></pre></li><li>多个入口时，每个入口生成都会生成Chuck。</li><li>如果是array类型，则搭配output.library配置项使用时，只有数组里的最后一个入口文件会被导出。</li></ul><h2 id="配置动态Entry"><a href="#配置动态Entry" class="headerlink" title="配置动态Entry"></a>配置动态Entry</h2><p>假如项目里有多个页面需要为每个页面的入口配置一个entry，但这些页面数量可能会不断增长，这时entry的配置会受到其他因素的影响导致不能写成静态的值。解决办法就是把entry设置成一个函数去动态返回上面所说的配置：</p><pre><code>//同步函数entry: () =&gt; {    return {        a: &#39;./pages/a&#39;,        b: &#39;./pages/b&#39;    }}//异步函数entry: () =&gt; {    return new Promise((resolve) =&gt; {        resolve({            a: &#39;./pages/a&#39;,            b: &#39;./pages/b&#39;        })    })}</code></pre><h1 id="output"><a href="#output" class="headerlink" title="output"></a>output</h1><p>Output属性告诉webpack在哪里输出它所创建的bundles，也可指定bundles的名称，默认位置为./dist。整个应用结构都会被编译到指定的输出文件夹中去，你可以通过在配置中指定一个 output 字段，来配置这些处理过程。最基本的属性包括filename（文件名）和path（输出路径）。</p><h2 id="Chuck的名称"><a href="#Chuck的名称" class="headerlink" title="Chuck的名称"></a>Chuck的名称</h2><p>向上面的<code>main.js</code>中，<code>main</code>就是Chuck名称。<strong>Chunk的名称和Entry的配置有关。</strong></p><ul><li>如果entry是<code>string</code>类型或者是<code>array</code>类型，只会生成一个Chuck。</li><li>如果entry是一个<code>object</code>,就可能出现多个<code>chunk</code>,这时候的<code>chunk</code>值是<code>object</code>名称。比如上面的<code>a.js</code>,<code>b.js</code>。Chuck名称在<code>output</code>可以配置。<h2 id="多个入口时怎么配置filename"><a href="#多个入口时怎么配置filename" class="headerlink" title="多个入口时怎么配置filename"></a>多个入口时怎么配置filename</h2>当通过多个入口起点(entry point)、代码拆分(code splitting)或各种插件(plugin)创建多个 bundle的时候，可以有以下几种赋bundle名称的方式。</li><li>使用入口名称赋值,[name]为entry的key值,比如<code>a.bundle.js</code>,<code>b.bundle.js</code><pre><code>filename: &quot;[name].bundle.js&quot;</code></pre></li><li>使用内部 chunk id,从0开始<pre><code>filename: &quot;[id].bundle.js&quot;</code></pre></li><li>使用每次构建过程中，都会生成一段Hash值<pre><code>filename: &quot;[name].[hash].bundle.js&quot;</code></pre></li><li>使用基于每个 chunk 内容的 hash值，可以理解为版本号(Git里面的)或者md5值。<strong>文件内容发生改变，chunkhash就会改变。在这里可以用到：项目上线，只上线那些被改过的文件</strong><pre><code>filename: &quot;[chunkhash].bundle.js&quot;</code></pre><pre><code>取5位Hash值，默认为20位。filename: &quot;[chunkhash:5].bundle.js&quot;</code></pre><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2>output.path 配置输出文件存放在本地的目录，必须是 <code>string</code> 类型的<strong>绝对路径</strong>。通常通过 Node.js 的 path 模块去获取绝对路径：<pre><code>path: path.resolve(__dirname, &#39;dist_[hash]&#39;)</code></pre><code>__dirname</code>就是当前文件所在的文件夹的名字。<h2 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h2>对构建出的资源进行异步加载（图片，文件）。加载这些异步资源需要对应的 URL 地址。默认值是空字符串“ ”。<strong>简单说，就是静态文件托管在cdn上。</strong><br>如果你这么配置：<pre><code>output:{  filename:&#39;[name]_[chunkhash:8].js&#39;,  publicPath:&#39;https://www.qdtalk.com/assets/&#39;}</code></pre>打包编译之后，HTML页面就变成了这个：<pre><code>&lt;script src=&quot;https://www.qdtalk.com/assets/a_12345678.js&quot;&gt;&lt;/script&gt;</code></pre>上面只是举了output的几个常用参数。</li></ul><h1 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h1><p><code>Loader</code>在webpack中承担<strong>翻译</strong>的工作。<br>因为<code>webpack</code>自身只支持加载<code>js</code>和<code>json</code>文件，把源文件转化翻译后输出新结果，且一个文件还可以链式的经过<strong>多个翻译员翻译</strong>。</p><p>以处理SCSS文件为例：</p><ul><li><code>SCSS</code> 源代码会先交给 <code>sass-loader</code> 把 <code>SCSS</code> 转换成 <code>CSS</code>；</li><li>把 <code>sass-loader</code> 输出的 <code>CSS</code> 交给 <code>css-loader</code> 处理，找出 <code>CSS</code> 中依赖的资源、压缩 <code>CSS</code> 等；</li><li>把 <code>css-loader</code> 输出的 <code>CSS</code> 交给 <code>style-loader</code> 处理，转换成通过脚本加载的 JavaScript 代码。<h2 id="常用的Loader"><a href="#常用的Loader" class="headerlink" title="常用的Loader"></a>常用的Loader</h2></li><li>样式：<code>style-loader、css-loader、less-loader、sass-loader</code>等。</li><li>文件：<code>raw-loader、file-loader 、url-loader</code>等</li><li>编译：<code>babel-loader、coffee-loader 、ts-loader</code>等</li><li>校验测试：<code>mocha-loader、jshint-loader 、eslint-loader</code>等</li><li><code>vue-loader、coffee-loader、babel-loader</code>等可以将特定文件格式转成js模块、将其他语言转化为js语言和编译下一代js语言</li><li><code>file-loader、url-loader</code>等可以处理资源，<code>file-loader</code>可以复制和放置资源位置，并可以指定文件名模板，用hash命名更好利用缓存。</li><li><code>url-loader</code>可以将小于配置limit大小的文件转换成内敛Data Url的方式，减少请求。</li><li><code>raw-loader</code>可以将文件已字符串的形式返回</li><li><code>imports-loader、exports-loader</code>等可以向模块注入变量或者提供导出模块功能</li><li><code>expose-loader</code>:暴露对象为全局变量<h2 id="安装Loader"><a href="#安装Loader" class="headerlink" title="安装Loader"></a>安装Loader</h2>以安装css-loader和style.loader为例，直接在终端：<pre><code>npm install css-loader style-loader --save-dev</code></pre><h2 id="配置单个Loader"><a href="#配置单个Loader" class="headerlink" title="配置单个Loader"></a>配置单个Loader</h2><code>webpack.config.js</code>中<pre><code>module.exports = {  module: {      rules: [          {              test: /\.css$/,              use: &#39;css-loader&#39;          }      ]  }}</code></pre></li><li>test:后面接一个正则表达式，表示有那些后缀文件被处理。</li><li>use：表示应该用什么loader。</li></ul><h2 id="配置多个loader"><a href="#配置多个loader" class="headerlink" title="配置多个loader"></a>配置多个loader</h2><pre><code>module.exports = {    module: {        rules: [            {                test: /\.css$/,                use: [                    {                        loader: &#39;style-loader&#39;                    },                    {                        loader: &#39;css-loader&#39;                    }                ]            }        ]    }}</code></pre><h2 id="其他配置方法"><a href="#其他配置方法" class="headerlink" title="其他配置方法"></a>其他配置方法</h2><ul><li>直接在命令行<pre><code>webpack --module-bind &#39;txt=raw-loader&#39;</code></pre></li><li>内联<pre><code>import txt from &#39;raw-loader!./file.txt&#39;</code></pre>但这两种方法都不推荐。还是在<code>webpack.config.js</code>配参数更好。</li></ul><h2 id="几个重要的loader"><a href="#几个重要的loader" class="headerlink" title="几个重要的loader"></a>几个重要的loader</h2><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p><code>Babel</code> 可以让你使用<code>ES2015/16/17</code> 写代码而不用顾忌浏览器的问题，<code>Babel</code> 可以帮你转换代码。</p><ul><li>安装几个必要的<code>Babel</code>库,<pre><code>npm i --save-dev babel-loader babel-core babel-preset-env</code></pre>   babel-loader让webpack去处理一些使用了es6的js文件。<br>   babel-core 提供一系列API，其实是让babel-loader去调用babel-core的API。<br>   babel-preset-env 这个库可以根据环境的不同转换代码</li><li>配置babel规则。在<code>package.json</code>里面增加一个<code>babel属性</code>。作用是设置项目中的babel转码规则和使用到的babel插件，格式如下：<pre><code>&quot;babel&quot;:{&quot;presets&quot;: [&quot;evn&quot;],//设定转码规则&quot;plugins&quot;: []//要用到的插件}</code></pre>表示告诉npm，在本项目中将使用babel，并且使用<code>babel-preset-env</code>规则进行转码。</li><li>除了上一种写法外，还有另外一种方法(<strong>推荐写法</strong>)。在根目录下面新建<code>.babelrc</code>文件，然后做一下配置：<pre><code>{&quot;presets&quot;: [&quot;babel-preset-env&quot;]}</code></pre></li></ul><pre><code>- 上面已经配置好`babel`的规则，但是`webpack`依然不知道何时使用该规则。我们还要再接着在配置里写入</code></pre><p>use: ‘babel-loader’</p><pre><code>**但要注意的是**，只有`js`文件才可以使用`babel`。### 处理图片- `npm i --save-dev url-loader file-loader`- 在`webpack.config.js`里面修改配置：</code></pre><p>test: /.(png|jpe?g|gif|svg)(?.*)?$/,<br>use : [<br>  {<br>     loader: ‘url-loader’,<br>     options: {<br>      // 限制 图片大小 10000B，小于限制会将图片转换为 base64格式<br>         limit: 10000,<br>      // 超出限制，创建的文件格式<br>      // build/images/[图片名].[hash].[图片格式]<br>         name: ‘images/[name].[hash].[ext]’<br>    }<br>  }<br>]</p><pre><code># Plugins(插件)插件用来拓展webpack功能，可以用于执行范围更广的任务，包括**打包、优化、压缩、搭建服务器**等等，功能十分强大。**要是用一个插件，一般是先使用npm包管理器进行安装，然后在配置文件webpack.config.js中require引入，最后在这个文件下使用new来创建一个实例。**   Loader一次只能处理单个相同类型的文件，但是plugins可以对整个过程起作用。## 常用的plugin插件- webpack内置`UglifyJsPlugin`插件，压缩和混淆代码。- webpack内置`CommonsChunkPlugin`，提高打包效率，将第三方库和业务代码分开打包- `ProvidePlugin`：自动加载模块，代替`require`和`import`- `html-webpack-plugin`可以根据模板自动生成html代码，并自动引用css和js文件- `extract-text-webpack-plugin` 将js文件中引用的样式单独抽离成css文件- `DefinePlugin` 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。- `HotModuleReplacementPlugin `热更新- `optimize-css-assets-webpack-plugin` 不同组件中重复的css可以快速去重- `webpack-bundle-analyzer` 一个webpack的bundle文件分析工具，将bundle文件以可交互缩放的treemap的形式展示- `compression-webpack-plugin` 生产环境可采用gzip压缩JS和CSS- `happypack`：通过多进程模型，来加速代码构建## 一个简单的插件使用- `npm install --save-dev html-webpack-plugin`安装一个插件。有的插件webpack自带，如果没有，则需用npm安装。- `const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);`在webpack.config.js中引入。- new一个实例</code></pre><p>plugins: [</p><p>  new HtmlWebpackPlugin({<br>  template: ‘./src/index.html’, //以src目录下的index.html文件为模板生成html5新文件<br>  filename: ‘index.html’,//指定生成的HTML文件叫啥名<br>  inject: ‘head’,//指定把脚本script标签放在那里，这里放在<head>标签里。还可以放<body><br>  })<br>]</p><pre><code>## 利用html-webpack-plugin插件自动生成html文件### 为什么要自动生成HTML每次执行webpack打包生成js文件后，都必须在index.html中手动插入打包好的文件的路径。**但在真实生产环境中，一次运行webpack后，完整的index.html应该是被自动生成的。** 例如静态资源、js 脚本都被自动插入了。### 根目录下的index.html文件根目录下的index.html会被html-webpack-plugin作为最终生成的 html 文件的模板。打包后，相关引用关系和文件路径都会按照正确的配置被添加进去。### 配置</code></pre><p>const HtmlWebpackPlugin = require(“html-webpack-plugin”);</p><p>module.exports = {<br> entry: {<br>    app: “./src/app.js”<br>  },<br>  output: {<br>    publicPath: <strong>dirname + “/dist/“,<br>    path: path.resolve(</strong>dirname, “dist”),<br>  },<br>    plugins: [<br>    new HtmlWebpackPlugin({<br>      filename: “index.html”,<br>      template: “./index.html”,<br>      chunks: [“app”], // entry中的app入口才会被打包<br>      minify: {<br>        // 压缩选项<br>        collapseWhitespace: true<br>      }<br>    })<br>  ]<br>}</p><pre><code>最后执行打包命令，然后在dist目录下就给你自动生成了index.html文件。dist目录下的index.html文件是以根目录下的inde.html文件为模板的。# 其他几个核心概念## Module(模块)对于webpack，模块不仅仅是javascript模块，它包括了任何类型的源文件，不管是图片、字体、json文件都是一个个模块。**Webpack支持以下的方式引用模块：**- ES2015 import 方法- CommonJs require() 方法- AMD define 和 require 语法- css/sass/less文件中的 @import 语法- url(...)和 &lt;img src=&quot;&quot;&gt;的图片路径## Dependency Graph（依赖关系图）所谓的依赖关系图是webpack根据每个模块之间的依赖关系递归生成的一张内部逻辑图，有了这张依赖关系图，webpack就能按图索骥把所有需要模块打包成一个bundle文件了。## Mode(模式)分为开发模式`development`和生产模式`production` 。两种模式的区别在于一个是为生产环境编译打包，一个是为了开发环境编译打包。生产环境模式下，webpack会自动对代码进行压缩等优化，省去了配置的麻烦。## 结语webpack断断续续终于算是入门了。与其他技能点相比，webpack算是比较酸涩难懂。但是学无止境，我学webpack的还有很长的路要走。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack入门(2) - 安装，配置，环境搭建</title>
      <link href="/2019/10/20/webpack-ru-men-2-an-zhuang-pei-zhi-huan-jing-da-jian/"/>
      <url>/2019/10/20/webpack-ru-men-2-an-zhuang-pei-zhi-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5d1867c76fb9a07eec59dfa6" target="_blank" rel="noopener">webpack入门(1)-“图解什么是webpack”</a>传送门</p><h1 id="初始化和安装"><a href="#初始化和安装" class="headerlink" title="初始化和安装"></a>初始化和安装</h1><ul><li>在工作目录新建一个文件夹</li><li><code>npm init</code> 初始化一个文件夹,出现对话框按确定就行。</li><li><code>npm install --global webpack</code> 全局安装，在c盘下会生成node_modules文件夹中会包含webpack。<code>请注意，这不是推荐的做法。全局安装会将您锁定到特定版本的webpack，并且在使用不同版本的项目中可能会失败。</code>官方并不推荐全局安装。</li><li><code>npm install --save-dev webpack</code> 安装在本地开发环境中</li><li><code>npm install --save-dev webpack-cli</code> webpack4之后要安装cli。把cli安装到开发环境中。</li><li><code>-D</code>就是<code>--save-dev</code>的缩写</li></ul><h1 id="打包一个简单的文件"><a href="#打包一个简单的文件" class="headerlink" title="打包一个简单的文件"></a>打包一个简单的文件</h1><ul><li>在文件夹下新建一个<code>src</code>文件,下面新建一个<code>main.js</code>文件。</li><li>根目录下新建一个<code>webpack.config.js</code>文件。为什么要建这个文件，因为直接使用<code>webpack</code>，它会寻找<code>webpack.config.js</code>把它当成默认的配置去运行。此时它不需要指定任何参数，就能读取里面的内容。<pre><code>// webpack.config.jsmodule.exports = {  entry: __dirname + &#39;/src/main.js&#39;,//我指定了入口文件，在src/main.js  output: {       path: __dirname + &#39;/dist&#39;, //打包后指定存放的目录,放在dist      filename: &#39;bundle.js&#39; //打包后的文件叫bundle.js  }}</code></pre></li></ul><blockquote><p>__dirname是Node.js中一个全局变量，它指向当前执行脚本所在的目录。<br>有多个入口文件的时候：<br><img src="https://user-gold-cdn.xitu.io/2019/7/3/16bb7d1cd83ec193?w=965&h=626&f=png&s=77448" alt=""></p></blockquote><ul><li>如果你一开始你就不想运行默认的<code>webpack.config.js</code>,你想运行其他的配置文件,比如<code>config.js</code>文件。你可以运行<code>webpack --config config.js</code>,这样它就会寻找<code>config.js</code>，并且运行它。</li><li>运行<code>webpack</code>，它会自动的寻找<code>webpack.config.js</code>，找到其中的入口文件比如上面的<code>main.js</code>。</li><li>如果你想有些个性化的需求，你想看到打包的进度，打包的模块，模块的信息，打包的原因。你可以输入以下的命令。<ul><li><code>webpack --progress</code>可以看到打包的进度。</li><li><code>webpack --progress --display-modules</code> 可以看到打包有几个模块，模块的信息。</li><li><code>webpack ---progress --display-modules --display-reasons</code> 打包的原因显示出来。</li></ul></li><li>但是这种方法太过繁琐，你要在命令行输入这么多东西。那么有没有更轻松的方法呢？<strong>有的！</strong><ul><li>在你初始化的时候，系统会自动生成<code>package.json</code>。现在找到根目录下的<code>package.json</code>文件。<br><img src="https://user-gold-cdn.xitu.io/2019/7/1/16bad8c1ca6b5add?w=514&h=294&f=png&s=18781" alt=""></li><li>在里面的<code>scripts</code>下添加定义一个脚本，<pre><code>&quot;dev&quot;:&quot;webpack --config webpack.config.js --progress --display-modules --colors --display-reasons&quot;</code></pre></li><li>最后在命令行运行<code>npm run dev</code></li></ul>  <strong>因为scripts脚本提供了命令的“别名”，像上面的以一个“dev”命令代替了一连串的命令，使用起来更为方便</strong>,即便你没有在命令行输入以上的配置，你依然可以看到打包的进度；以看到打包有几个模块，模块的信息；字体为彩色；打包的原因。因为你在配置文件下定义了，就不需要了。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/7/3/16bb5173b3f3e78e?w=578&h=714&f=png&s=97412" alt=""></p><h1 id="更快捷的执行打包任务"><a href="#更快捷的执行打包任务" class="headerlink" title="更快捷的执行打包任务"></a>更快捷的执行打包任务</h1><ul><li>最原始的执行打包任务，可以使用命令<code>webpack main.js bundle.js</code>在这个例子当中，<code>main.js</code>是入口文件，<code>bundle.js</code> 打包完之后的文件。</li><li>第二种，我们可以在<code>webpack.config.js</code>里写配置。<pre><code>module.exports = {entry:  __dirname + &quot;/app/main.js&quot;,//唯一入口文件output: {  path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方  filename: &quot;bundle.js&quot;//打包后输出文件的文件名}}</code></pre>我们只需要输入<code>webpack</code>命令，webpack就能自己找到<code>webpack.config.js</code>，在找出入口，找到output,执行打包。</li><li>第三种，继承第二种。更简单快捷的执行打包。在<code>package.json</code>里找到“scripts”脚本，添加<pre><code>&quot;start&quot;: &quot;webpack --config webpack.config.js --progress --display-modules --colors --display-reasons&quot;</code></pre>然后我们只需要<code>npm start</code>就可以打包了。<pre class=" language-!"><code class="language-!">需要注意的是,“start”在npm中比较特殊，只需npm start 就可以执行命令。如果是非start,还要再在前面加上一个run ,比如npm run dev,npm run build</code></pre></li></ul><h1 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h1><h2 id="使用source-maps进行调试调试"><a href="#使用source-maps进行调试调试" class="headerlink" title="使用source maps进行调试调试"></a>使用source maps进行调试调试</h2><h3 id="为何要使用source-maps？"><a href="#为何要使用source-maps？" class="headerlink" title="为何要使用source maps？"></a>为何要使用source maps？</h3><p>因为<code>webpack</code>对源代码进行打包后，会对源代码进行压缩、精简、甚至变量名替换，在浏览器中，无法对代码逐行打断点进行调试，所有需要使用<code>source maps</code>进行调试，它使得我们在浏览器中可以看到源代码，进而逐行打断点调试。</p><h3 id="如何使用source-maps？"><a href="#如何使用source-maps？" class="headerlink" title="如何使用source maps？"></a>如何使用source maps？</h3><p>在配置中添加<code>devtool</code>属性，赋值为<code>source-map</code>或者<code>inline-source-map</code>即可，后者报错信息更加具体，会指示源代码中的具体错误位置，而<code>source-map</code>选项无法指示到源代码中的具体位置。</p><h2 id="使用开发工具"><a href="#使用开发工具" class="headerlink" title="使用开发工具"></a>使用开发工具</h2><p>用开发工具可以简化开发过程的工作。比如你写完代码后保存开发工具可以自动帮你执行一系列的命令。</p><h3 id="watch模式"><a href="#watch模式" class="headerlink" title="watch模式"></a>watch模式</h3><p>在使用<code>webpack-cli</code>进行打包时，通过命令<code>webpack --watch</code>即可开启<code>watch</code>模式，进入<code>watch</code>模式之后，一旦依赖树中的某一个模块发生了变化，<code>webpack</code>就会重新进行编译。</p><h3 id="使用webpack-dev-server"><a href="#使用webpack-dev-server" class="headerlink" title="使用webpack-dev-server"></a>使用webpack-dev-server</h3><p>浏览器监听你的代码的修改，并自动刷新显示修改后的结果。它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖。</p><ul><li>安装。<code>npm install --save-dev webpack-dev-server</code></li><li>修改配置文件，添加<code>devServer</code>属性<pre><code>// webpack.config.jsmodule.exports = {    devServer: {        contentBase: &#39;./dist&#39;,//本地服务器所加载的页面所在目录        historyApiFallback: true,//不跳转        inline: true //实时刷新    }};</code></pre></li><li>在<code>package.json</code> 添加脚本<pre><code>// package.json{    &quot;scripts&quot;: {        &quot;start&quot;: &quot;webpack-dev-server --open&quot;    }}</code></pre></li><li>运行命令<br><code>npm run start</code>即可在本地的8080端口查看结果。</li><li>搭建开发环境远不止这些内容，我只挑了我在学习过程中经常用到的地方，或者我觉得重要的地方。</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>webpack很难啃，我是在网上找资料看视频，一点一点摸索。网上的资料时间维度大，有的还在讲webpack1.0,有的在讲最新版的webpack,<strong>所以在整理的时候难免有出错的地方。欢迎在下方评论指出错误！</strong>  </p><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack入门(1) - 图解Webpack是什么</title>
      <link href="/2019/10/20/webpack-ru-men-1-tu-jie-webpack-shi-shi-me/"/>
      <url>/2019/10/20/webpack-ru-men-1-tu-jie-webpack-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>毫无疑问，Webpack在前端中有着独特的重要性，是你必须要熟悉的一个技能点。因为你在投简历浏览一些大公司的<strong>前端岗位</strong>时，Webpack毫无疑问是写明了至少要是<strong>熟悉Webpack</strong>。我在学Webpack期间，常常被它的配置，环境给绕晕了,现在重新开始学一遍，希望我可以掌握它。本着分享学习的态度，记录下我学习的过程，希望可以对一些初学Webpack的同学提供一点帮助。</p><h1 id="Webpack使用原因和定义"><a href="#Webpack使用原因和定义" class="headerlink" title="Webpack使用原因和定义"></a>Webpack使用原因和定义</h1><p>我相信很多刚开始学<code>Webpack</code>的同学在学之前一定疯狂的在各大论坛或者百度搜索“什么是<code>Webpack</code>”，因为我就是这么干的。但是一些大牛的文章在提及什么是<code>Webpack</code>的时候总是一笔带过，看完之后也是云里雾里，迷迷糊糊。现在我用自己的语言来解释什么是<code>Webpack</code>。在此之前，还要向大家解释为什么要使用<code>Webpack</code>:</p><h2 id="为什么要使用Webpack"><a href="#为什么要使用Webpack" class="headerlink" title="为什么要使用Webpack"></a>为什么要使用Webpack</h2><p>我们都知道一个大公司的网站往往做的都很炫酷，美观，功能很齐全。在这背后前端工程师花了很大的精力去做优化什么的。大型网站和大型项目中的背后都拥有着复杂的JS代码和很多依赖。<strong>为了简化开发的复杂度，往往对程序切割分裂为不同的模块。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/6/30/16ba776df3057afd?w=390&h=486&f=png&s=22381" alt=""><br>如图所示，把大型项目切割成很多不同的模块。那么，里面的箭头是怎么回事，我觉得可以理解为<code>require</code>。因为两个文件之间相互通联是靠<code>require</code>连接的。好比如，<code>html</code>文件利用<code>link</code>中引入样式一样。<code>webpack</code>整合了项目里的模块打包的更为精简。所以我们需要<code>webpack</code>。</p><ul><li>Webpack分析大型项目的结构</li><li>找到JS模块以及浏览器不能直接运行的模块(cjs,Sass,hbs等等)</li><li>将浏览器不能直接处理的文件转换和打包为合适的格式供浏览器直接处理。</li><li>这样前端工程师既可以更轻松系统的开发，浏览器也能更高效流畅的运行。</li></ul><h2 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/30/16ba78866fc440b7?w=1284&h=566&f=png&s=65325" alt=""><br>上面已经提到了<code>Webpack</code>的工作流程，我在举一个<strong>不怎么严谨</strong>的例子你们也许就能明白。<br><code>假如你去饭店吃饭，点完菜后你觉得把菜打包回寝室吃更爽一些。你点了很多菜，这些菜有麻辣的，酸辣的，甜的，还有水果，小糕点不同的口味。考虑到你的室友有的喜欢吃辣的，有的喜欢吃甜的，有的喜欢吃水果。如果全部的菜混在一起可能室友都不喜欢，你决定不混在一起，而是按照口味混在一起。把辣的菜混到一起，把甜的菜混到一起，把水果混到一起。这样你的室友就能够接受了。</code></p><p><img src="https://user-gold-cdn.xitu.io/2019/7/1/16bab1b71034272a?w=1097&h=606&f=png&s=70391" alt=""></p><p><code>结合上面webpack的工作流程，可以这样说：webpack分析大型项目的结构即分析这些菜是哪些口味；找到浏览器不能直接运行的模块，即分析哪些是你室友不能接受的口味；将浏览器不能直接处理的文件转换和打包为合适的格式供浏览器处理即将菜分类打包让你的室友可以接受。</code><br>结合上面的图，应该把<code>Webpack</code>的运行流程搞清楚了。</p><h1 id="webpack工作流程"><a href="#webpack工作流程" class="headerlink" title="webpack工作流程"></a>webpack工作流程</h1><p>用文字叙述不直观，我尽量用图形的方式来说明。首先先说明依赖就是本文第一张图里面的箭头。<br><img src="https://user-gold-cdn.xitu.io/2019/7/1/16bab14c0a750e74?w=570&h=796&f=png&s=82861" alt=""></p><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员都要掌握的Git</title>
      <link href="/2019/10/20/cheng-xu-yuan-du-yao-zhang-wo-de-git/"/>
      <url>/2019/10/20/cheng-xu-yuan-du-yao-zhang-wo-de-git/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是参考廖雪峰老师的Git资料再加上我自己对Git的理解，记录我的Git学习历程，作下此文是为以后学习，工作，开发中如果遇到问题可以回过头来参考参考。因为水平有限，难免会有出错的地方，欢迎指正。</p><h1 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h1><ul><li>官方话：Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。</li><li>引用廖雪峰老师的话，它能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以。</li></ul><h1 id="为什么要学习Git"><a href="#为什么要学习Git" class="headerlink" title="为什么要学习Git"></a>为什么要学习Git</h1><ul><li>面试要被问。可以应付面试。</li><li>很多公司开发都用Git来处理项目。现在不学，以后肯定还要学。</li><li>在我看来Git是现如今所有程序员都要掌握的，以后与同事共同开发项目必定要用到的，熟练掌握Git命令，可以提高开发的效率。。</li></ul><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><ul><li>Windows<br>直接在官网上去下载。下载完成后，随便在某个文件下右键如果有Git Bash Here就安装成功。安装后，还要在命令行输入<pre><code>$git config --global user.name &quot;你的名字&quot;$git config --global user.email &quot;你的邮箱&quot;</code></pre><code>global</code>表示全局，这台机器所有的Git仓库都会使用这个配置。允许单个仓库使用其他的名字和邮箱。</li><li>Mac<br>评论区指出Mac也可以像Windows一样，按上面的步骤安装。<br>也可以直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</li></ul><h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9d385970c7b6c?w=987&h=495&f=png&s=247329" alt=""></p><ul><li>本地仓库是对于远程仓库而言的。</li><li>本地仓库 = 工作区 + 版本区</li><li>工作区即磁盘上的文件集合。</li><li>版本区(版本库)即<code>.git</code>文件</li><li>版本库 = 暂存区(stage) + 分支(master) + 指针Head  <ul><li>以我使用最频繁的git命令为例，即提交到github为例。</li><li><code>git init</code> 原本本地仓库只包含着工作区，这是最常见的工作状态。此时，<code>git init</code>一下，表示在本地区域创建了一个<code>.git</code>文件,版本区建立。</li><li><code>git add .</code> 表示把工作区的所有文件全部提交到版本区里面的<strong>暂存区</strong></li><li>当然你也可以通过 <code>git add ./xxx/</code> 一条一条分批添加到暂存区。</li><li><code>git commit -m &quot;xxx&quot;</code> 把暂存区的<strong>所有</strong>文件提交到仓库区，暂存区空空荡荡。</li><li><code>git remote add origin https://github.com/name/name_cangku.git</code> 把本地仓库与远程仓库连接起来。</li><li><code>git push -u origin master</code> 把仓库区的文件提交到远程仓库里。</li><li>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。会有这样的信息<code>nothing to commit, working tree clean</code></li></ul></li></ul><h1 id="提交到GitHub"><a href="#提交到GitHub" class="headerlink" title="提交到GitHub"></a>提交到GitHub</h1><p>以前不熟悉git命令的时候，我提交项目到github上都是直接在网页上直接拉取文件提交上去的。有点羞耻。<br><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9c23ee01835ce?w=1501&h=643&f=png&s=101230" alt=""></p><ol><li><code>git init</code> .初始化，表示把这个文件变成Git可以管理的仓库。初始化后打开隐藏的文件可以看到有一个<code>.git</code>文件。</li><li><code>git add .</code> 后面的一个点表示把这个文件全部提交到暂存区。</li><li><code>git add ./readme.md/</code> 表示把这个文件下面的readme.md文件提交到暂存区。</li><li><code>git commit -m &quot;你要评论一点什么东西&quot;</code> <code>git  commit</code>的意思是把暂存区的全部文件提交到本地仓库。<code>-m</code>后接评论。</li><li><code>git remote add origin https://github.com/name/name_cangku.git</code>表示把你本地的仓库与GitHub上的远程仓库连接起来。只需要连接一次，以后提交的时候就可以不用谢这条命令了。<code>name</code>是你的github名字，<code>name_cangku</code>是你的仓库名。<strong>注意</strong>不要把后面的<code>.git</code>给漏掉了。因为我前面就是这么走过来的，绕了很多弯路。至于如何在GitHub上新建仓库，网上有很多教程，这里不再赘述了。</li><li><code>git push -u origin master</code> 把本地仓库提交到远程仓库。(最后一步)在你的远程仓库上刷新一下就可以看到你提交的文件了。</li><li>最后提到的是，在<code>git commit -m &quot;&quot;</code>之前，可以重复<code>git add</code>到暂存区。但是<code>git commit</code>会把你之前存放在暂存区的全部文件<strong>一次性</strong>全部提交到本地仓库。<h1 id="版本的回溯与前进"><a href="#版本的回溯与前进" class="headerlink" title="版本的回溯与前进"></a>版本的回溯与前进</h1>提交一个文件，有时候我们会提交很多次，在提交历史中，这样就产生了不同的版本。每次提交，Git会把他们串成一条时间线。如何回溯到我们提交的上一个版本，用<code>git reset --hard + 版本号</code>即可。 版本号可以用<code>git log</code>来查看，每一次的版本都会产生不一样的版本号。回溯之后，<code>git log</code>查看一下发现离我们最近的那个版本已经不见了。但是我还想要前进到最近的版本应该如何？只要<code>git reset --hard + 版本号</code>就行。退一步来讲，虽然我们可以通过<code>git reset --hard + 版本号</code>,靠记住版本号来可以在不同的版本之间来回穿梭。<strong>但是</strong>,有时候把版本号弄丢了怎么办？<code>git reflog</code>帮你记录了每一次的命令，这样就可以找到版本号了，这样你又可以通过<code>git reset</code>来版本穿梭了。<h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1></li></ol><ul><li>场景1：在工作区时，你修改了一个东西，你想撤销修改，<code>git checkout -- file</code>。廖雪峰老师指出撤销修改就回到和版本库一模一样的状态，即用版本库里的版本替换工作区的版本。 </li><li>场景2：你修改了一个内容，并且已经<code>git add</code>到暂存区了。想撤销怎么办？回溯版本，<code>git reset --hard + 版本号</code>,再<code>git checkout -- file</code>,替换工作区的版本。</li><li>场景3：你修改了一个内容，并且已经<code>git commit</code>到了<code>master</code>。跟场景2一样，版本回溯，再进行撤销。<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1></li><li>如果你<code>git add</code>一个文件到暂存区，然后在工作区又把文件删除了，Git会知道你删除了文件。如果你要把版本库里的文件删除，<code>git rm</code> 并且<code>git commit -m &quot;xxx&quot;</code>.</li><li>如果你误删了工作区的文件，怎么办？使用撤销命令，<code>git checkout --&lt;file&gt;</code>就可以。<strong>这再次证明了撤销命令其实就是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</strong><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1>分支，就像平行宇宙，廖雪峰老师如是说。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9e012079c4724?w=553&h=291&f=png&s=11351" alt=""><br>在没有其他分支插进来时，只有一个master主分支。每次你<code>git push -u origin master</code> 提交就是增加一条时间轴，master也会跟着移动。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9e11b1115072b?w=640&h=355&f=png&s=14404" alt=""><br>创建一个other的分支，通过other提交，虽然时间轴向前走了，但是主分支master还在原来的位置。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9e1ce1d3c3b03?w=675&h=359&f=png&s=16995" alt=""></p><p>理论分析完，看一下命令怎么写。</p><ul><li>创建分支<code>other</code>,切换到<code>other</code>分支。<pre><code>git branch othergit checkout other</code></pre></li><li>查看当前所有分支<pre><code>git branch</code></pre>```</li></ul><ul><li>other<br>master<br>```<br>当前的分支会有一个<code>*</code></li></ul><ul><li>用<code>other</code>提交<pre><code>git add ./xxx/git commit -m &quot;xxx&quot;</code></pre></li><li><code>other</code>分支完成，切换回<code>master</code><pre><code>git checkout master</code></pre></li><li>此时，master分支上并没有<code>other</code>的文件，因为分支还没有合并。</li><li><strong>合并分支</strong><pre><code>git merge other</code></pre></li><li>合并完成之后，就可以在master分支上查看到文件了。</li><li>删除<code>other</code>分支。<pre><code>git branch -d other</code></pre></li><li>我由此想到，在以后工作中，应该是一个开放小组共同开发一个项目，组长会创建很多分支，每一个分支可以交给一个人去开发某一个功能，一个小组共同开发而且不会相互干扰。谁的功能完成了，可以由组长合并一下完成了的分支。哦，完美！<h2 id="解决合并分支问题"><a href="#解决合并分支问题" class="headerlink" title="解决合并分支问题"></a>解决合并分支问题</h2></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/6/29/16ba102bd434afc6?w=610&h=393&f=png&s=17724" alt=""><br>假如有这样一种情况，分支<code>other</code>已经<code>commit</code>了，<strong>但是</strong>此时指针指回<code>master</code>时，并且<code>master</code>没有合并，而是<code>git add / commit</code> 提交了。这样，就产生了冲突，主分支<code>master</code>文件内容与<code>other</code>分支的内容不一样。合并不起来！所以，</p><ul><li>修改文件的内容，让其保持一致。</li><li><code>git add</code> <code>git commit</code> 提交。</li><li>分支合并了。<br><img src="https://user-gold-cdn.xitu.io/2019/6/29/16ba11a0ba73803d?w=658&h=349&f=png&s=21326" alt=""></li><li><code>git log --graph</code> 查看分支合并图</li><li><code>git branch -d other</code> 删除分支，任务结束。<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2></li><li><code>git merge --no-ff other</code> 禁用<code>Fast forward</code>模式，因为使用<code>Fast forward</code>模式，删除分支后，分支历史信息会丢失。</li></ul><h2 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h2><blockquote><p>廖雪峰老师提到，工作中每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。但如果你手上有分支在工作中，你的上级要你改另外的分支的BUG。你要把现在正在工作的分支保存下来，<code>git stash</code>,把当前工作现场“存储”起来，等以后恢复后继续工作。当你解决BUG后，<code>git checkout other</code>回到自己的分支。用<code>git stash list</code>查看你刚刚“存放”起来的工作去哪里了。此时你要恢复工作：</p></blockquote><ul><li><code>git stash apply</code>恢复却不删除<code>stash</code>内容，<code>git stash drop</code>删除<code>stash</code>内容。</li><li><code>git stash pop</code>恢复的同时把stash内容也删了.</li><li>此时，用<code>git stash list</code>查看，看不到任何<code>stash</code> 内容。  </li></ul><p><strong>总结：修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场</strong></p><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><ul><li><p><code>git branch -d + 分支</code>有可能会删除失败，因为Git会保护没有被合并的分支。</p></li><li><p><code>git branch -D + 分支</code> 强行删除，丢弃没被合并的分支。</p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2></li><li><p><code>git remote</code> 查看远程库的信息，会显示<code>origin</code>，远程仓库默认名称为<code>origin</code></p></li><li><p><code>git remote -v</code>显示更详细的信息 </p></li><li><p><code>git push -u origin master</code>推送<code>master</code>分支到<code>origin</code>远程仓库。</p></li><li><p><code>git push -u origin other</code> 推送<code>other</code>到<code>origin</code>远程仓库。</p><h2 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/29/16ba20c43f386f7c?w=520&h=313&f=png&s=12170" alt=""><br>产生上图的冲突时，</p></li><li><p><code>git pull</code> 把最新的提交从远程仓库中抓取下来，在本地合并，解决冲突。在进行<code>git pull</code></p></li><li><p>如果<code>git pull</code> 也失败了，还要指定分支之间的链接，这一步Git会提醒你怎么做。然后再<code>git pull</code>。              </p><blockquote><p><strong>廖雪峰老师的总结：多人协作的工作模式通常是这样：</strong></p></blockquote><ul><li><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p></li><li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code> 推送就能成功！</p></li><li><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><h2 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h2></li></ul></li><li><p><code>git rebase</code> 把分叉的提交历史“整理”成一条直线，看上去更直观.缺点是本地的分叉提交已经被修改过了。</p></li><li><p>最后在进行<code>git push -u origin master</code></p></li><li><p><code>rebase</code>的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><blockquote><p>比如一个APP要上线，通常在版本库中打一个标签(tag),<br>这样，就确定了打标签的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针。<br><code>tag</code>其实就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。比如<code>tag v2.1</code>就是把历史上的一个版本的东西叫做<code>v2.1</code></p></blockquote><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>步骤：</p></li><li><p><code>git branch</code>查看当前分支,<code>git checkout master</code>切换到<code>master</code>分支。</p></li><li><p><code>git tag &lt;name&gt;</code> 打标签，默认为<code>HEAD</code>。比如<code>git tag v1.0</code></p></li><li><p>默认标签是打在最新提交的<code>commit</code>上的。如果想要打标签在以前的<code>commit</code>上，要<code>git log</code>找到历史提交的<code>commit</code> id.</p></li><li><p>如果一个<code>commt id</code>是<code>du2n2d9</code>,执行<code>git tag v1.0 du2n2d9</code>就把这个版本打上了<code>v1.0</code>的标签了。</p></li><li><p><code>git tag</code> 查看所有标签，可以知道历史版本的<code>tag</code></p></li><li><p>标签不是按时间顺序列出，而是按字母排序的。</p></li><li><p><code>git show &lt;tagname&gt;</code> 查看标签信息。</p></li><li><p><code>git tag -a &lt;标签名&gt; -m &quot;&lt;说明&gt;&quot;</code>,创建带说明的标签。 <code>-a</code>指定标签名，<code>-m</code>指定说明文字。用<code>show</code>可以查看说明。</p><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2></li><li><p><code>git tag -d v1.0</code> 删除标签。因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p></li><li><p><code>git push origin &lt;tagname&gt;</code> 推送某个标签到远程</p></li><li><p><code>git push origin --tags</code> 一次性推送全部尚未推送到远程的本地标签</p></li><li><p>如果标签推送到远程。<code>git tag -d v1.0</code> 先删除本地标签v1.0。<code>git push origin :refs/tags/v1.0</code>删除远程标签v1.0</p></li></ul><h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><ul><li><code>git config --global color.ui true</code>让Git显示颜色，会让命令输出看起来更醒目</li><li>忽略特殊文件<br>创建一个<code>.gitignore</code>文件，把需要忽略的文件名填进去。Git就会自动忽略这些文件。我也在学习中遇到过这样的问题，比如<code>node_modules</code>文件就可以忽略。</li><li><blockquote><p>忽略文件原则：忽略操作系统自动生成的文件，比如缩略图等；<br>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；<br>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</p></blockquote></li><li>强制提交已忽略的的文件。<code>git add -f &lt;file&gt;</code></li><li><code>git check-ignore -v &lt;file&gt;</code>检查为什么Git会忽略该文件。</li><li><strong>给Git命令配别名</strong>,这个有点骚，就是你以后想输入<code>git rebase</code>时,你给它一个“外号”，就叫它<code>git nb</code>。以后你可以通过<code>git nb</code>来代替<code>git rebase</code>。具体怎么转换可以去<a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732837407424" target="_blank" rel="noopener">廖雪峰老师的网站</a>看。因为水平有限，我觉得先把正常的Git命令搞清楚来就很不错了。<h1 id="常用Git命令总结"><a href="#常用Git命令总结" class="headerlink" title="常用Git命令总结"></a>常用Git命令总结</h1></li><li><code>git config --global user.name &quot;你的名字&quot;</code> 让你全部的<code>Git</code>仓库绑定你的名字</li><li><code>git config --global user.email &quot;你的邮箱&quot;</code> 让你全部的<code>Git</code>仓库绑定你的邮箱</li><li><code>git init</code> 初始化你的仓库</li><li><code>git add .</code> 把工作区的文件全部提交到暂存区</li><li><code>git add ./&lt;file&gt;/</code> 把工作区的<code>&lt;file&gt;</code>文件提交到暂存区</li><li><code>git commit -m &quot;xxx&quot;</code> 把暂存区的所有文件提交到仓库区，<strong>暂存区空空荡荡</strong></li><li><code>git remote add origin https://github.com/name/name_cangku.git</code> 把本地仓库与远程仓库连接起来</li><li><code>git push -u origin master</code> 把仓库区的主分支<code>master</code>提交到远程仓库里</li><li><code>git push -u origin &lt;其他分支&gt;</code> 把其他分支提交到远程仓库</li><li><code>git status</code>查看当前仓库的状态</li><li><code>git diff</code> 查看文件修改的具体内容</li><li><code>git log</code> 显示从最近到最远的提交历史</li><li><code>git clone + 仓库地址</code>下载克隆文件</li><li><code>git reset --hard + 版本号</code> 回溯版本，版本号在<code>commit</code>的时候与<code>master</code>跟随在一起</li><li><code>git reflog</code> 显示命令历史</li><li><code>git checkout -- &lt;file&gt;</code> 撤销命令，用版本库里的文件替换掉工作区的文件。我觉得就像是<code>Git</code>世界的<code>ctrl + z</code></li><li><code>git rm</code> 删除版本库的文件</li><li><code>git branch</code> 查看当前所有分支</li><li><code>git branch &lt;分支名字&gt;</code> 创建分支</li><li><code>git checkout &lt;分支名字&gt;</code> 切换到分支</li><li><code>git merge &lt;分支名字&gt;</code> 合并分支</li><li><code>git branch -d &lt;分支名字&gt;</code> 删除分支,有可能会删除失败，因为<code>Git</code>会保护没有被合并的分支</li><li><code>git branch -D + &lt;分支名字&gt;</code> 强行删除，丢弃没被合并的分支</li><li><code>git log --graph</code> 查看分支合并图</li><li><code>git merge --no-ff &lt;分支名字&gt;</code> 合并分支的时候禁用<code>Fast forward</code>模式,因为这个模式会丢失分支历史信息</li><li><code>git stash</code> 当有其他任务插进来时，把当前工作现场“存储”起来,以后恢复后继续工作</li><li><code>git stash list</code> 查看你刚刚“存放”起来的工作去哪里了</li><li><code>git stash apply</code> 恢复却不删除<code>stash</code>内容</li><li><code>git stash drop</code> 删除<code>stash</code>内容</li><li><code>git stash pop</code> 恢复的同时把stash内容也删了</li><li><code>git remote</code> 查看远程库的信息，会显示<code>origin</code>，远程仓库默认名称为<code>origin</code></li><li><code>git remote -v</code> 显示更详细的信息</li><li><code>git pull</code> 把最新的提交从远程仓库中抓取下来，在本地合并,和<code>git push</code>相反</li><li><code>git rebase</code> 把分叉的提交历史“整理”成一条直线，看上去更直观</li><li><code>git tag</code> 查看所有标签，可以知道历史版本的tag</li><li><code>git tag &lt;name&gt;</code> 打标签，默认为<code>HEAD</code>。比如<code>git tag v1.0</code></li><li><code>git tag &lt;tagName&gt; &lt;版本号&gt;</code> 把版本号打上标签，版本号就是<code>commit</code>时，跟在旁边的一串字母数字</li><li><code>git show &lt;tagName&gt;</code> 查看标签信息</li><li><code>git tag -a &lt;tagName&gt; -m &quot;&lt;说明&gt;&quot;</code> 创建带说明的标签。 <code>-a</code>指定标签名，<code>-m</code>指定说明文字</li><li><code>git tag -d &lt;tagName&gt;</code> 删除标签</li><li><code>git push origin &lt;tagname&gt;</code> 推送某个标签到远程</li><li><code>git push origin --tags</code> 一次性推送全部尚未推送到远程的本地标签</li><li><code>git push origin :refs/tags/&lt;tagname&gt;</code> 删除远程标签<code>&lt;tagname&gt;</code></li><li><code>git config --global color.ui true</code> 让Git显示颜色，会让命令输出看起来更醒目</li><li><code>git add -f &lt;file&gt;</code> 强制提交已忽略的的文件</li><li><code>git check-ignore -v &lt;file&gt;</code> 检查为什么Git会忽略该文件<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1>廖雪峰老师讲Git讲的通俗易懂，对小白很友好。认认真真花上两天时间去整理，会有所收获的。<a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖老师的个人网站传送门</a></li></ul><p>欢迎访问我的<a href="https://zhongjunhaoz.github.io/">个人博客</a>，定时分享技术文章，一起前端学习！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>仿网易云音乐微信小程序</title>
      <link href="/2019/10/20/fang-wang-yi-yun-yin-le-wei-xin-xiao-cheng-xu/"/>
      <url>/2019/10/20/fang-wang-yi-yun-yin-le-wei-xin-xiao-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="项目部分截图-Gif"><a href="#项目部分截图-Gif" class="headerlink" title="项目部分截图(Gif)"></a>项目部分截图(Gif)</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/24/16b89bbee707dd70?w=405&h=692&f=gif&s=3289476" alt=""><br><img src="https://user-gold-cdn.xitu.io/2019/6/24/16b89f9bc0492380?w=405&h=692&f=gif&s=3465695" alt=""><br><img src="https://user-gold-cdn.xitu.io/2019/6/24/16b89c4f8e1eccb5?w=405&h=692&f=gif&s=4980551" alt=""></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一阵子学习了微信小程序，为了巩固所学的知识和提高实战经验，决定自己手撸一款小程序。因为听歌一直在用网易云音乐，所以突发奇想就做一款仿网易云音乐的小程序吧！开发中遇到了很多在学习中没有遇到过的坑，也很感谢在我改不出BUG时给予帮助的老师同学！本着学习和分享的目的，写下以下的文字,希望能给<strong>初学小程序的你</strong>带来一点帮助,大佬轻点喷。</p><hr><h1 id="开发前准备"><a href="#开发前准备" class="headerlink" title="开发前准备"></a>开发前准备</h1><ul><li>VScode代码编辑器。</li><li>微信开发者工具</li><li>ios网易云音乐(V5.9.1版本)</li><li>酷狗音乐小程序(提供了一些思路)</li><li><a href="[http://musicapi.leanapp.cn/">网易云音乐API</a></li><li>(<a href="https://www.iconfont.cn" target="_blank" rel="noopener">阿里巴巴矢量图标库</a>)提供一些图标icon</li></ul><hr><h1 id="tabBar部分"><a href="#tabBar部分" class="headerlink" title="tabBar部分"></a>tabBar部分</h1><h2 id="自定义tabBar"><a href="#自定义tabBar" class="headerlink" title="自定义tabBar"></a><strong>自定义tabBar</strong></h2><p>一般在开发中，微信小程序给我们的tabBar就能满足需求。但是，有些特别的需求必须使用自定义tabBar才能满足。<br>比如tabBar实现半透明。那么，如何才能自定义tabBar呢？<br>    1.首先,在 app.json里的”tabBar”里声明<br>    <code>&quot;tabBar&quot;: {    &quot;custom&quot;: true    }</code><br>    2.接着在项目的根目录下新建一个<code>custom-tab-bar</code>文件夹。里面包含<code>index.wxml index.js index.json index.wxss</code>四个文件。更多细节参考<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html" target="_blank" rel="noopener">微信小程序文档</a><br><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8a44df06fca6e?w=511&h=229&f=png&s=66834" alt=""></p><pre><code>&lt;!-- index.html --&gt;&lt;!-- 自定义tabbar页面 --&gt;&lt;cover-view class=&quot;tab-bar&quot;&gt;   &lt;cover-view class=&quot;tab-bar-border&quot;&gt;&lt;/cover-view&gt;&lt;!--tabBal边框样式  --&gt;&lt;!-- 乐库tabbar --&gt;  &lt;cover-view class=&#39;tab-bar-item&#39; &gt;    &lt;cover-image src=&#39;../images/music.png&#39; hidden=&#39;{{isShow_index}}&#39; bindtap=&#39;switchTab_index&#39;&gt;&lt;/cover-image&gt;    &lt;cover-image src=&#39;../images/selected-music.png&#39; hidden=&#39;{{!isShow_index}}&#39; bindtap=&#39;switchTab_index&#39;&gt;&lt;/cover-image&gt;    &lt;cover-view style=&quot;color:{{isShow_index ? selectedColor : color}}&quot;&gt;乐库&lt;/cover-view&gt;  &lt;/cover-view&gt;&lt;!-- 播放tabbar --&gt;    &lt;cover-view class=&#39;tab-bar-item&#39; bindtap=&#39;switchTab_playing&#39;&gt;    &lt;cover-image src=&#39;../images/selected-playing.png&#39; hidden=&#39;{{isShow_playing}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-image src=&#39;../images/playing.png&#39; hidden=&#39;{{!isShow_playing}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-view&gt;&lt;/cover-view&gt;  &lt;/cover-view&gt;&lt;!-- 我的tabbar --&gt;    &lt;cover-view class=&#39;tab-bar-item&#39; bindtap=&#39;switchTab_me&#39;&gt;    &lt;cover-image src=&#39;../images/me.png&#39; hidden=&#39;{{isShow_me}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-image src=&#39;../images/selected-me.png&#39; hidden=&#39;{{!isShow_me}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-view style=&quot;color:{{isShow_me ? selectedColor : color}}&quot;&gt;我的&lt;/cover-view&gt;  &lt;/cover-view&gt;&lt;/cover-view&gt;</code></pre><pre><code>// index.jsComponent({  data: {    isShow_index:true,    isShow_playing:false,    isShow_me:false,    selected: 0, //首页    color: &quot;#8D8D8D&quot;,    selectedColor: &quot;#C62F2F&quot;,    list: [{      pagePath: &quot;/pages/index/index&quot;,      iconPath: &quot;/images/music.png&quot;,      selectedIconPath: &quot;/images/selected-music.png&quot;,      text: &quot;乐库&quot;    }, {      pagePath: &quot;/pages/love/love&quot;,        iconPath: &quot;/images/selected-playing.png&quot;,      selectedIconPath: &quot;/images/playing.png&quot;,      text: &quot;&quot;    },      {        pagePath: &quot;/pages/me/me&quot;,        iconPath: &quot;/images/me.png&quot;,        selectedIconPath: &quot;/images/selected-me.png&quot;,        text: &quot;我的&quot;      }]  },  methods: {    switchTab_index:function(){      wx.switchTab({        url:&#39;/pages/index/index&#39;      })      this.setData({        isShow_index: true,        isShow_me: false,        isShow_playing: false      })    },    switchTab_playing: function () {      wx.switchTab({        url: &#39;/pages/love/love&#39;      })      this.setData({        isShow_playing: true,        isShow_index: false,        isShow_me: false      })    },    switchTab_me: function () {      wx.switchTab({        url: &#39;/pages/me/me&#39;      })      this.setData({        isShow_me:true,        isShow_playing: false,        isShow_index: false      })    }  }})</code></pre><h2 id="tabBar半透明"><a href="#tabBar半透明" class="headerlink" title="tabBar半透明"></a><strong>tabBar半透明</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8a6ee63e9f2da?w=405&h=94&f=gif&s=538191" alt=""></p><pre><code>/* custom-tab-bar/index.wxss */.tab-bar {  height:7%;  position: fixed;  bottom: 0;  left: 0;  right: 0;  height: 48px;  background:#FAFBFD;  opacity: 0.93;  display: flex;  padding-bottom: env(safe-area-inset-bottom);}</code></pre><h1 id="API封装"><a href="#API封装" class="headerlink" title="API封装"></a>API封装</h1><p>一般我们https请求都是通过<code>wx.request</code>来请求,但是这种方法只能请求一次数据,如果首页用<code>wx.request</code>来请求的话,代码看起来会很冗长和杂乱。不仅自己容易搞糊涂,其他人看代码时也会很累。因此为了代码的整洁干净,我在这里新建了一个文件专门存放API。一般在根目录下的<code>utils</code>文件夹下新建一个<code>api.js</code>,但我在根目录下新建了文件夹<code>API</code>,里面包含<code>api.js</code>。</p><pre><code>// api.jsconst API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const request = (url, data) =&gt; {   let _url = API_BASE_URL  + url;  return new Promise((resolve, reject) =&gt; {    wx.request({      url: _url,      method: &quot;get&quot;,      data: data,      header: {        &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;      },      success(request) {        resolve(request.data)      },      fail(error) {        reject(error)      }    })  });}module.exports ={  gethotsongs:(data) =&gt;{    return request(&#39;/search/hot&#39;,data)//热搜接口  },  searchSuggest:(data)=&gt;{    return request(&#39;/search/suggest&#39;,data)//搜索建议接口  },  searchResult:(data)=&gt;{    return request(&#39;/search&#39;,data)//搜索结果接口  },  getBanner:(data)=&gt;{    return request(&#39;/banner&#39;,data)//个性推荐轮播  },  getsongsheet:(data)=&gt;{    return request(&#39;/top/playlist&#39;,data)//热门歌单接口  },  getNewSong:(data)=&gt;{    return request(&#39;/personalized/newsong&#39;,data)//最新音乐接口  },  getDjRadios:(data)=&gt;{    return request(&#39;/dj/recommend&#39;,data)//电台推荐接口  },  getProgramRecommend:(data)=&gt;{    return request(&#39;/program/recommend&#39;,data)//推荐节目接口  },  getRecommendType:(data)=&gt;{    return request(&#39;/dj/recommend/type&#39;,data)//所有电台分类推荐  },  getRecommendMV:(data)=&gt;{    return request(&#39;/personalized/mv&#39;,data)//推荐MV  },  getNewMv:(data)=&gt;{    return request(&#39;/mv/first&#39;,data)//最新MV  },  getNewEst:(data)=&gt;{    return request(&#39;/album/newest&#39;,data)//最新专辑  },  getTopList:(data)=&gt;{    return request(&#39;/top/list&#39;,data)//排行榜  },  getDjList:(data)=&gt;{    return request(&#39;/dj/catelist&#39;,data) //电台分类  },  getPay:(data)=&gt;{    return request(&#39;/dj/paygift&#39;,data)//付费精品  },  getSonger:(data)=&gt;{    return request(&#39;/toplist/artist&#39;,data)//歌手排行  }}</code></pre><p><code>api.js</code>只能通过<code>module.exports</code>来暴露,那个页面要数据就从这拿。如果在哪个页面要用到它,还需要在头部引入一下:</p><p><code>const API = require(&#39;../../API/api&#39;)</code></p><p>以个性推荐轮播图为例，</p><pre><code>  getBanner: function() {    API.getBanner({      type: 2    }).then(res =&gt; {      if (res.code === 200) { //更加严谨        this.setData({          banner: res.banners        })      }    })  }</code></pre><p>  这样就把请求到的数据存储到<code>banner</code>中了。</p><hr><h1 id="搜索部分"><a href="#搜索部分" class="headerlink" title="搜索部分"></a>搜索部分</h1><h2 id="输入框样式"><a href="#输入框样式" class="headerlink" title="输入框样式"></a><strong>输入框样式</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8da289aa52854?w=436&h=97&f=png&s=7182" alt=""><br>我这里是引入了<code>WEUI</code>的样式，<br>1.下载<code>weui.wxss</code>,链接我找不到了，所以我放上了我的<a href="https://github.com/zhongjunhaoz/CloudMusic/blob/master/weui.wxss" target="_blank" rel="noopener">github</a>上的<code>weui.wxss</code>。<br>2.把下载好的<code>weui.wxss</code>放到根目录下。<br>3.在<code>app.wxss</code>中<code>@import &quot;weui.wxss&quot;;</code>引入一下就可以使用微信提供给我们的样式了。<br>4.<a href="https://weui.io/" target="_blank" rel="noopener"><code>WeUI</code>样式库</a></p><h2 id="热门搜索"><a href="#热门搜索" class="headerlink" title="热门搜索"></a><strong>热门搜索</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8daeda7452a8f?w=415&h=404&f=png&s=31051" alt=""><br>上面已经提到我从<code>api.js</code>中拿数据。</p><pre><code> // 从接口到获取到数据导入到hotsongs  gethotsongs() {    API.gethotsongs({ type: &#39;new&#39; }).then(res =&gt; {      wx.hideLoading()      if (res.code === 200) {  //严谨        this.setData({          hotsongs: res.result.hots        })      }    })  }</code></pre><h2 id="搜索历史"><a href="#搜索历史" class="headerlink" title="搜索历史"></a><strong>搜索历史</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dba723508edc?w=419&h=741&f=png&s=42298" alt=""><br>思路：当在输入框输入完成后–&gt;失去焦点–&gt; 利用<code>wx.setStorageSync</code>存进缓存中–&gt;<code>wx.getStorageSync</code>获取到并把它打印出来。</p><pre><code>  // input失去焦点函数  routeSearchResPage: function(e) {    console.log(e.detail.value)    let history = wx.getStorageSync(&quot;history&quot;) || [];    history.push(this.data.searchKey)    wx.setStorageSync(&quot;history&quot;, history);  },//每次显示变动就去获取缓存，给history，并for出来。  onShow: function () {    this.setData({      history: wx.getStorageSync(&quot;history&quot;) || []    })  },</code></pre><h2 id="清空搜索历史"><a href="#清空搜索历史" class="headerlink" title="清空搜索历史"></a><strong>清空搜索历史</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dbe42c2c2c33?w=405&h=487&f=gif&s=119001" alt=""><br>思路：×图标绑定事件-&gt;呼出对话框<code>wx.showModal</code>-&gt;确定则把<code>history</code>赋值为空</p><pre><code>    // 清空page对象data的history数组 重置缓存为[]  clearHistory: function() {    const that = this;    wx.showModal({      content: &#39;确认清空全部历史记录&#39;,      cancelColor:&#39;#DE655C&#39;,      confirmColor: &#39;#DE655C&#39;,      success(res) {        if (res.confirm) {          that.setData({            history: []          })          wx.setStorageSync(&quot;history&quot;, []) //把空数组给history,即清空历史记录        } else if (res.cancel) {        }      }    })  },</code></pre><h2 id="实时搜索建议"><a href="#实时搜索建议" class="headerlink" title="实时搜索建议"></a><strong>实时搜索建议</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dc5e9059003f?w=399&h=707&f=gif&s=62309" alt=""><br>思路：实时获取输入框的值-&gt;把值传给搜索建议API，发起网络请求-&gt;请求之后拿到搜索建议-&gt;打印结果并隐藏其他组件只保留搜索建议的组件(类似于Vue里的v-show)</p><pre><code> //获取input文本并且实时搜索,动态隐藏组件  getsearchKey:function(e){    console.log(e.detail.value) //打印出输入框的值    let that = this;    if(e.detail.cursor != that.data.cursor){ //实时获取输入框的值      that.setData({        searchKey: e.detail.value      })    }    if(e.value!=&quot;&quot;){ //组件的显示与隐藏      that.setData({        showView: false      })    } else{      that.setData({        showView: &quot;&quot;      })    }    if(e.detail.value!=&quot;&quot;){ //解决 如果输入框的值为空时，传值给搜索建议，会报错的bug      that.searchSuggest();    }    }</code></pre><pre><code>  // 搜索建议  searchSuggest(){    API.searchSuggest({ keywords: this.data.searchKey ,type:&#39;mobile&#39;}).then(res=&gt;{      if(res.code === 200){        this.setData({          searchsuggest:res.result.allMatch        })      }    })  }</code></pre><h2 id="点击热搜或历史，执行搜索"><a href="#点击热搜或历史，执行搜索" class="headerlink" title="点击热搜或历史，执行搜索"></a>点击热搜或历史，执行搜索</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8eefd6bdf126f?w=403&h=703&f=gif&s=257246" alt=""><br>思路：关键是<code>event</code>,点击通过<code>e.currentTarget.dataset.value</code>拿到所点击的值，再交给其他方法执行搜索行为。</p><pre><code>// 点击热门搜索值或搜索历史，填入搜索框  fill_value:function(e){    let that = this;    console.log(history)    // console.log(e.currentTarget.dataset.value)    that.setData({      searchKey: e.currentTarget.dataset.value,//点击吧=把值给searchKey,让他去搜索      inputValue: e.currentTarget.dataset.value,//在输入框显示内容      showView:false,//给false值，隐藏 热搜和历史 界面      showsongresult: false, //给false值，隐藏搜索建议页面    })    that.searchResult(); //执行搜索功能  }</code></pre><h2 id="搜索结果"><a href="#搜索结果" class="headerlink" title="搜索结果"></a><strong>搜索结果</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dd6660f63f9a?w=399&h=707&f=gif&s=63353" alt=""><br>思路：输入结束-&gt;确认键-&gt;调用<code>searchResult</code>请求到结果</p><pre><code>// 搜索完成点击确认  searchover:function(){    let that = this;    that.setData({      showsongresult: false    })    that.searchResult();  }</code></pre><pre><code>   // 搜索结果  searchResult(){    console.log(this.data.searchKey)    API.searchResult({ keywords: this.data.searchKey, type: 1, limit: 100, offset:2 }).then(res =&gt; {      if (res.code === 200) {        this.setData({          searchresult: res.result.songs        })      }    })  }</code></pre><hr><h1 id="乐库部分"><a href="#乐库部分" class="headerlink" title="乐库部分"></a>乐库部分</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8deb716cb19fc?w=1049&h=734&f=png&s=483647" alt=""><br>乐库部分其实没什么逻辑很难的部分，以结构和样式为主，在这里就不赘述了。可以到我的<a href="https://github.com/zhongjunhaoz/CloudMusic" target="_blank" rel="noopener">github</a>上查看。在这里分享一些小功能的实现和踩到的坑。</p><h2 id="个性推荐，主播电台切换"><a href="#个性推荐，主播电台切换" class="headerlink" title="个性推荐，主播电台切换"></a><strong>个性推荐，主播电台切换</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8e03ef5ad0dbc?w=403&h=669&f=gif&s=1612390" alt=""><br>1.个性推荐和主播电台是两个<code>swiper-item</code>所以他们才可以左右滑动，就像轮播图一样，不过轮播图放的是图片，而这里放的是整个页面。<br>2.我要实现的效果是左右滑动的同时，<code>个性推荐</code>和<code>主播电台</code>下面的白色方块也要跟着滑动。<br><strong>1. 第一种方法</strong><br>给包裹两个<code>swiper-item</code>的<code>swiper</code>添加一个<code>bindchange=&quot;changeline&quot;</code>事件，把事件对象<code>event</code>打印出来发现，<code>console.log(e.detail.current)</code>,当我们左右滑动的时候<code>cuurrent</code>的值会在<code>0</code>和<code>1</code>之间切换。所以我给白色方块添加</p><pre><code>class=&quot;{{changeline?'swiper_header_line_before':'swiper_header_line_after'}}&quot;</code></pre><pre><code>    if(e.detail.current === 0){    this.setData({       changeline:true      })    }else{    this.setData({       changeline:false      })    }</code></pre><p>当<code>current</code>为0，即页面在个性推荐时，让<code>changeline</code>为<code>true</code>;当<code>current</code>为1，即页面在主播电台时，让<code>changeline</code>为<code>false</code>;为<code>true</code>时，给白色方块加持<code>swiper_header_line_before</code>的样式，为<code>false</code>时，加持<code>swiper_header_line_after</code>的样式。这样就可以跟随<code>swiper-item</code>的滑动而切换了。<strong>但是，这种切换方式太僵硬了</strong>，没有那种流畅的切换效果，而且不适合多<code>swiper-item</code>页面。<br><strong>2. 第二种方法</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8e8d9a71ab12a?w=436&h=295&f=png&s=23978" alt=""><br>让一半宽度，四分之一宽度设置为变量是为了兼容不同的手机型号。因为写死数据肯定会有BUG，所以才要计算宽度。</p><pre><code>&lt;view class=&quot;weui-navbar-slider&quot; style=&quot;transform:translateX({{slideOffset}}px);&quot;&gt;&lt;/view&gt;</code></pre><pre><code>.weui-navbar-slider{  width:28px;  height: 5px;  background: #ffffff;  border-radius:10rpx;  transition: transform .6s; }</code></pre><p><code>slideOffset</code>为变量，动态接受从<code>data</code>传来的数据。</p><pre><code>onLoad:function(){    wx.getSystemInfo({      success: function (res) {        // console.log(res.windowWidth)        // console.log(res.windowWidth / 2 / 2)        half = res.windowWidth / 2 ;        quarter = res.windowWidth / 2 / 2;        that.setData({          slideOffset: quarter - 14 //onLoad的时候让 quarter - 14 给slideOffset，即一开始就让他在个性推荐的下面，否则onLoad的时候一开始在0的位置        })      }    })}  changeline:function(e){    // console.log(e)    // console.log(e.detail.current)    let current = e.detail.current; //获取swiper的current值    if(e.detail.current === 0){      this.setData({        slideOffset: quarter - 14      })    }    if(e.detail.current === 1){      this.setData({        slideOffset: (quarter - 14) + half      })    }    if(e.detail.current === null){      this.setData({        slideOffset: quarter - 14      })    }  }</code></pre><h2 id="MV播放"><a href="#MV播放" class="headerlink" title="MV播放"></a>MV播放</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8ea3d1f4e6c01?w=403&h=669&f=gif&s=2204017" alt=""><br>主要是结构和样式，我直接上代码了。</p><pre><code>&lt;!-- play_mv.wxml --&gt;&lt;view class=&quot;mv_box&quot;&gt;    &lt;video src=&quot;{{mv.brs['480']}}&quot; class=&quot;mv&quot; autoplay=&quot;{{autoplay}}&quot; loop=&quot;{{loop}}&quot; direction=&quot;{{0}}&quot; show-fullscreen-btn=&quot;{{showfullscreenbtn}}&quot;    show-center-play-btn=&quot;{{showcenterplaybtn}}&quot; enable-progress-gesture=&quot;{{enableprogressgesture}}&quot; show-mute-btn=&quot;{{showmutebtn}}&quot; title=&quot;{{mv.name}}&quot;    play-btn-position=&quot;{{center}}&quot; object-fit=&quot;{{objectfit}}&quot;&gt;&lt;/video&gt;&lt;/view&gt;&lt;view class=&quot;mv_name&quot;&gt;{{mv.name}}&lt;/view&gt;&lt;view class=&quot;mv_time&quot;&gt; 发行:  {{mv.publishTime}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_times&quot;&gt;播放次数:  {{mv.playCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc&quot;&gt;{{mv.desc}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;点赞: {{mv.likeCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;收藏: {{mv.subCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;评论: {{mv.commentCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;分享: {{mv.shareCount}}&lt;/view&gt;</code></pre><pre><code>/* play/play_mv.wxss */.mv_box{    width: 100%;    height: 480rpx;    margin-top:-2rpx;}.mv{    width: 100%;    height: 100%;    border-radius:15rpx;}.mv_name{    margin-top:20rpx;    margin-left:20rpx;}.mv_time{    font-size: 12px;    margin-left:20rpx;    color:#979798;    display:initial;}.mv_times{    margin-left: 100rpx;}.mv_desc{    display: block;    color:#6A6B6C;}.mv_other{    display: block;}</code></pre><pre><code>// play_mv.jsconst API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const app = getApp();Page({  data: {    mv: [],    autoplay: true,    loop: true,    showfullscreenbtn: true,    showcenterplaybtn: true,    enableprogressgesture: true,    showmutebtn: true,    objectfit: &#39;contain&#39;,  },  onLoad: function (options) {    // console.log(mv_url);    const mvid = options.id; // onLoad()后获取到歌曲视频之类的id    // 请求MV的地址，失败则播放出错，成功则传值给createBgAudio(后台播放管理器，让其后台播放)    wx.request({      url: API_BASE_URL + &#39;/mv/detail&#39;,      data: {        mvid: mvid          },      success: res =&gt; {        console.log(res.data.data.brs[&#39;480&#39;])        console.log(&#39;歌曲音频url:&#39;, res)        if (res.data.data.brs === null) {  //如果是MV 电台 广告 之类的就提示播放出错，并返回首页          console.log(&#39;播放出错&#39;)          wx.showModal({            content: &#39;服务器开了点小差~~&#39;,            cancelColor: &#39;#DE655C&#39;,            confirmColor: &#39;#DE655C&#39;,            showCancel: false,            confirmText: &#39;返回&#39;,            complete() {              wx.switchTab({                url: &#39;/pages/index/index&#39;              })            }          })        } else {          this.setData({            mv: res.data.data          })        }      }    })  },})</code></pre><h2 id="歌手榜"><a href="#歌手榜" class="headerlink" title="歌手榜"></a>歌手榜</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8eaed5f5e5b3b?w=795&h=695&f=png&s=242469" alt=""></p><pre><code>// 歌手榜的jsconst API = require(&#39;../../API/api&#39;);const app = getApp();Page({  data: {    songers: [], //歌手榜  },  onLoad: function (options) {    wx.showLoading({      title: &#39;加载中&#39;,    });    this.getSonger();  },  getSonger: function () {    API.getSonger({}).then(res =&gt; {      wx.hideLoading()      this.setData({        songers: res.list.artists.slice(0, 100)      })    })  },  handleSheet: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性    const sheetId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面      url: `./moremore_songer?id=${sheetId}`    })  },})</code></pre><pre><code>&lt;!-- 歌手榜结构 --&gt;&lt;view wx:for=&quot;{{songers}}&quot; wx:key=&quot;&quot; class=&#39;songer_box&#39; data-id=&quot;{{item.id}}&quot; bindtap=&#39;handleSheet&#39;&gt;  &lt;view class=&#39;songer_index_box&#39;&gt;    &lt;text class=&#39;songer_index&#39;&gt;{{index + 1}}&lt;/text&gt;  &lt;/view&gt;  &lt;view class=&#39;songer_img_box&#39;&gt;  &lt;image src=&quot;{{item.picUrl}}&quot; class=&#39;songer_img&#39;&gt;&lt;/image&gt;  &lt;/view&gt;  &lt;view class=&#39;songer_name_box&#39;&gt;  &lt;text class=&#39;songer_name&#39;&gt;{{item.name}}&lt;/text&gt;  &lt;text class=&#39;songer_score&#39;&gt;{{item.score}}热度&lt;/text&gt;  &lt;/view&gt;&lt;/view&gt;</code></pre><pre><code>// 歌手下级路由歌曲列表const API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const app = getApp();Page({  data: {    songList: []  },  onLoad: function (options) {    wx.showLoading({      title: &#39;加载中&#39;,    });    const sheetId = options.id;    wx.request({      url: API_BASE_URL + &#39;/artists&#39;,      data: {        id: sheetId          },      success: res =&gt; {        const waitForPlay = new Array;        for (let i = 0; i &lt;= res.data.hotSongs.length - 1; i++) { //循环打印出其id          waitForPlay.push(res.data.hotSongs[i].id) //循环push ID 到waitForPlay数组          app.globalData.waitForPlaying = waitForPlay  //让waitForPlay数组给全局数组          // console.log(app.globalData.waitForPlaying)        }        wx.hideLoading()        console.log(res.data.hotSongs)        this.setData({          songList: res.data.hotSongs        })      }    })  },  handlePlayAudio: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性    const audioId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面      url: `../../play/play?id=${audioId}`    })  }})</code></pre><pre><code>&lt;!-- more/more_songer/moremore_songer.wxml歌手下面的歌曲 --&gt;&lt;view class=&#39;search_result_songs&#39;&gt;  &lt;view wx:for=&quot;{{songList}}&quot; wx:key=&quot;&quot; class=&#39;search_result_song_item songer_box&#39; data-id=&quot;{{item.id}}&quot; bindtap=&#39;handlePlayAudio&#39;&gt;    &lt;view class=&#39;songer_index_box&#39;&gt;      &lt;text class=&#39;songer_index&#39;&gt;{{index + 1}}&lt;/text&gt;    &lt;/view&gt;    &lt;view class=&#39;songer_img_box&#39;&gt;      &lt;view class=&#39;search_result_song_song_name&#39;&gt;{{item.name}}&lt;/view&gt;      &lt;view class=&#39;search_result_song_song_art-album&#39;&gt;{{item.ar[0].name}} - {{item.al.name}}&lt;/view&gt;    &lt;/view&gt;  &lt;/view&gt;&lt;/view&gt;</code></pre><h2 id="推荐歌单"><a href="#推荐歌单" class="headerlink" title="推荐歌单"></a>推荐歌单</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8eb96b06ef0b4?w=800&h=642&f=png&s=373779" alt=""><br>因为样式与排行榜类似，所以只放出图片，源码可以到我的<a href="https://github.com/zhongjunhaoz/CloudMusic/tree/master/more/more_sheet" target="_blank" rel="noopener">github</a>上查看。</p><h2 id="榜单排行"><a href="#榜单排行" class="headerlink" title="榜单排行"></a>榜单排行</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8ebf82357b4e6?w=735&h=623&f=png&s=222179" alt=""><br><a href="https://github.com/zhongjunhaoz/CloudMusic/tree/master/more" target="_blank" rel="noopener">请查看源码</a></p><h2 id="换一换功能"><a href="#换一换功能" class="headerlink" title="换一换功能"></a>换一换功能</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8ec5afa3172e5?w=403&h=386&f=gif&s=301154" alt=""><br>思路：绑定点击事件-&gt;选取随机的三个数-&gt;给空值-&gt;push三个随机数进数组中-&gt;重新赋值。</p><pre><code>  // 换一换  change_1:function(){    let maxNum = this.data.more_recommend_create.length  //计算数据长度    let r1 = parseInt(Math.random() * (maxNum - 0) + 0); //取【0-数据长度】内的整数随机数    let r2 = parseInt(Math.random() * (maxNum - 0) + 0);    let r3 = parseInt(Math.random() * (maxNum - 0) + 0);    this.setData({      recommend_create: []    })    //重新取3组数据    this.data.recommend_create.push(this.data.more_recommend_create[r1])    this.data.recommend_create.push(this.data.more_recommend_create[r2])    this.data.recommend_create.push(this.data.more_recommend_create[r3])    //重新赋值    this.setData({      recommend_create: this.data.recommend_create    })  }</code></pre><h1 id="播放界面"><a href="#播放界面" class="headerlink" title="播放界面"></a>播放界面</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8f088b494cb9c?w=403&h=703&f=gif&s=3753267" alt=""><br>图片太大，因此加快了播放。</p><h2 id="播放功能"><a href="#播放功能" class="headerlink" title="播放功能"></a>播放功能</h2><p><strong>思路：利用<code>data-id=&quot;&quot;</code>获取到歌曲ID放在<code>event</code>中-&gt; 通过<code>event</code>对象事件获取ID并跳转到播放页面 -&gt;<code>wx.request</code>获取到歌曲的音频地址及detail-&gt;背景音频管理器 <code>wx.getBackgroundAudioManager()</code>-&gt;播放</strong><br>以歌手榜下级路由歌曲列表为例，  </p><pre><code>&lt;view wx:for=&quot;{{songList}}&quot; wx:key=&quot;&quot; class=&#39;search_result_song_item songer_box&#39; data-id=&quot;{{item.id}}&quot; bindtap=&#39;handlePlayAudio&#39;&gt;</code></pre><pre><code>  handlePlayAudio: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性    const audioId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面      url: `../../play/play?id=${audioId}`    })  }</code></pre><pre><code>  // play.jsconst API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const app = getApp();Page({  data: {    isPlay: &#39;&#39;,    song:[],    innerAudioContext: {},    show:true,    showLyric:true,    songid:[],    history_songId:[]  },  onLoad: function (options) {    const audioid = options.id; // onLoad()后获取到歌曲视频之类的id    this.play(audioid); //把从wxml获取到的值传给play()  },  play: function (audioid){    const audioId = audioid;    app.globalData.songId = audioId;  //让每一个要播放的歌曲ID给全局变量的songId    const innerAudioContext = wx.createInnerAudioContext();    this.setData({      innerAudioContext,      isPlay: true    })    // 请求歌曲音频的地址，失败则播放出错，成功则传值给createBgAudio(后台播放管理器，让其后台播放)    wx.request({      url: API_BASE_URL + &#39;/song/url&#39;,      data: {        id: audioId      },      success: res =&gt; {        if (res.data.data[0].url === null) {  //如果是MV 电台 广告 之类的就提示播放出错，并返回首页          wx.showModal({            content: &#39;服务器开了点小差~~&#39;,            cancelColor: &#39;#DE655C&#39;,            confirmColor: &#39;#DE655C&#39;,            showCancel: false,            confirmText: &#39;返回&#39;,            complete() {              wx.switchTab({                url: &#39;/pages/index/index&#39;              })            }          })        } else {          this.createBgAudio(res.data.data[0]);        }      }    })    //获取到歌曲音频，则显示出歌曲的名字，歌手的信息，即获取歌曲详情；如果失败，则播放出错。    wx.request({      url: API_BASE_URL + &#39;/song/detail&#39;,      data: {        ids: audioId    //必选参数ids      },      success: res =&gt; {        if (res.data.songs.length === 0) {          wx.showModal({            content: &#39;服务器开了点小差~~&#39;,            cancelColor: &#39;#DE655C&#39;,            confirmColor: &#39;#DE655C&#39;,            showCancel: false,            confirmText: &#39;返回&#39;,            complete() {              wx.switchTab({                url: &#39;/pages/index/index&#39;              })            }          })        } else {          this.setData({            song: res.data.songs[0],  //获取到歌曲的详细内容，传给song          })          app.globalData.songName = res.data.songs[0].name;        }      },    })  },  createBgAudio(res) {    const bgAudioManage = wx.getBackgroundAudioManager(); //获取全局唯一的背景音频管理器。并把它给实例bgAudioManage    app.globalData.bgAudioManage = bgAudioManage;         //把实例bgAudioManage(背景音频管理器) 给 全局    bgAudioManage.title = &#39;title&#39;;                        //把title 音频标题 给实例    bgAudioManage.src = res.url;                          // res.url 在createBgAudio 为 mp3音频  url为空，播放出错    const history_songId = this.data.history_songId    const historySong = {      id: app.globalData.songId,      songName:app.globalData.songName    }    history_songId.push(historySong)    bgAudioManage.onPlay(res =&gt; {                         // 监听背景音频播放事件      this.setData({        isPlay: true,        history_songId      })    });    bgAudioManage.onEnded(() =&gt; {                  //监听背景音乐自然结束事件，结束后自动播放下一首。自然结束，调用go_lastSong()函数，即歌曲结束自动播放下一首歌      this.go_lastSong();    })    wx.setStorageSync(&#39;historyId&#39;, history_songId); //把historyId存入缓存  },})</code></pre><h2 id="暂停-播放"><a href="#暂停-播放" class="headerlink" title="暂停/播放"></a>暂停/播放</h2><pre><code>    &lt;!-- 暂停播放图标 --&gt;  &lt;view class=&quot;play_suspend&quot;&gt;    &lt;view class=&quot;icon_playing&quot;&gt;&lt;image bindtap=&quot;handleToggleBGAudio&quot; src=&quot;../images/suspend.png&quot; hidden=&quot;{{!isPlay}}&quot; class=&quot;{{'img_play_suspend'}}&quot; /&gt;  &lt;!-- 暂停图标--&gt;    &lt;image bindtap=&quot;handleToggleBGAudio&quot; src=&quot;../images/play.png&quot; hidden=&quot;{{isPlay}}&quot; class=&quot;{{'img_play_suspend'}}&quot; /&gt;&lt;/view&gt; &lt;!--播放图标--&gt;  &lt;/view&gt;</code></pre><pre><code>  // 播放和暂停  handleToggleBGAudio() {    // const innerAudioContext = app.globalData.innerAudioContext;    const bgAudioManage = app.globalData.bgAudioManage;    const {isPlay} = this.data;    if (isPlay) {      bgAudioManage.pause();      // innerAudioContext.pause();handleToggleBGAudio    } else {      bgAudioManage.play();      // innerAudioContext.play();    }    this.setData({      isPlay: !isPlay    })    console.log(this.data.isPlay)  }</code></pre><h2 id="上一首-下一首-随机播放"><a href="#上一首-下一首-随机播放" class="headerlink" title="上一首/下一首(随机播放)"></a>上一首/下一首(随机播放)</h2><p>  <strong>思路：点击歌单或歌手页，获取到对应的歌单/歌手id-&gt;<code>wx.request</code>请求数据获取到所有的歌单内/歌手热门歌曲音频地址-&gt;给全局变量globalData-&gt;点击上一首/下一首随机获取到全局变量的一则数据-&gt;给play()方法-&gt;播放</strong></p><pre><code>  &lt;!--歌单--&gt;    onLoad: function (options) {    wx.showLoading({      title: &#39;加载中&#39;,    });    const sheetId = options.id;    wx.request({      url: API_BASE_URL + &#39;/playlist/detail&#39;,      data: {        id: sheetId          },      success: res =&gt; {        const waitForPlay = new Array;        for (let i = 0; i &lt;= res.data.playlist.trackIds.length - 1;i++){ //循环打印出其id          waitForPlay.push(res.data.playlist.trackIds[i].id) //循环push ID 到waitForPlay数组          app.globalData.waitForPlaying = waitForPlay  //让waitForPlay数组给全局数组        }        wx.hideLoading()        this.setData({          songList: res.data.playlist.tracks        })        }    })  }</code></pre><pre><code>  &lt;view class=&quot;icon_playing &quot;&gt;&lt;image src=&quot;../images/lastSong.png&quot; class=&quot; icon_play&quot; bindtap=&quot;go_lastSong&quot; /&gt;&lt;/view&gt;  &lt;view class=&quot;icon_playing &quot;&gt;&lt;image src=&quot;../images/nextSong.png&quot; class=&quot; icon_play&quot; bindtap=&quot;go_lastSong&quot; /&gt;&lt;/view&gt;</code></pre><pre><code>    go_lastSong:function(){     let that = this;    const lastSongId = app.globalData.waitForPlaying;    const songId = lastSongId[Math.floor(Math.random() * lastSongId.length)]; //随机选取lastSongId数组的一个元素    that.data.songid = songId;    this.play(songId)//传进play()方法中    app.globalData.songId=songId;  }</code></pre><h2 id="歌词-封面切换"><a href="#歌词-封面切换" class="headerlink" title="歌词/封面切换"></a>歌词/封面切换</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b8f5e9d2a1e22b?w=403&h=703&f=gif&s=1127200" alt=""><br>  因为网易云API的歌词接口崩溃，请求不到歌词，所以我只能把歌词写死为<code>纯音乐，请欣赏</code>。类似于<code>v-show</code>。</p><pre><code>   &lt;!-- 封面 --&gt;  &lt;!-- 一开始onload时,showLyric=true, 显示为转动的图标，点击图标，切换为歌词--&gt;  &lt;view class=&quot;sing-show&quot; bindtap=&quot;showLyric&quot; &gt;    &lt;view class=&quot;moveCircle {{isPlay ? 'play' : ''}}&quot; hidden=&quot;{{!showLyric}}&quot;&gt;      &lt;image src=&quot;{{song.al.picUrl}}&quot; class=&quot;coverImg {{isPlay ? 'play' : ''}}&quot; hidden=&quot;{{!showLyric}}&quot;/&gt;    &lt;/view&gt;    &lt;text  hidden=&quot;{{showLyric}}&quot; class=&quot;songLyric&quot;&gt;纯音乐，请欣赏&lt;/text&gt;  &lt;/view&gt;</code></pre><pre><code>    // 点击切换歌词和封面  showLyric(){    const {showLyric} = this.data;    this.setData({      showLyric: !showLyric    })  }</code></pre><h2 id="破产版的孤独星球动效"><a href="#破产版的孤独星球动效" class="headerlink" title="破产版的孤独星球动效"></a>破产版的孤独星球动效</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8f4e771e9a04d?w=403&h=703&f=gif&s=1629412" alt=""><br>封面旋转：</p><pre><code>@keyframes rotate {  0%{    transform: rotate(0);  }  100%{    transform: rotate(360deg);  }}</code></pre><p>扩散的圆形线条：<br>其实就是外面套一个盒子，盒子宽高变大以及透明度逐渐变低。</p><pre><code>@keyframes moveCircle {  0%{    width: 400rpx;    height: 400rpx;    border: 1px solid rgba(255, 255, 255, 1)  }  30%{    width: 510rpx;    height: 510rpx;    border: 1px solid rgba(255, 255, 255, 0.8)  }  50%{    width: 610rpx;    height: 610rpx;    border: 1px solid rgba(255, 255, 255, 0.6)  }  80%{    width: 700rpx;    height: 700rpx;    border: 1px solid rgba(255, 255, 255, 0.4)  }  99%{    width: 375px;    height: 375px;    border: 1px solid rgba(255, 255, 255, 0.1)  }  100%{    width: 0px;    height: 0px;    border: 1px solid rgba(255, 255, 255, 0)  }}</code></pre><h2 id="背景毛玻璃"><a href="#背景毛玻璃" class="headerlink" title="背景毛玻璃"></a>背景毛玻璃</h2><pre><code>&lt;!-- play.wxml --&gt;&lt;image src=&quot;{{song.al.picUrl}}&quot; class=&quot;background_img&quot; &gt;&lt;/image&gt;</code></pre><pre><code>/* 播放界面毛玻璃效果 */.background_img{   position: fixed;  top: 0;  left: 0;  bottom: 0;  width: 100%;  height: 100%;  filter: blur(20px);  z-index: -1;  transform: scale(1.5); /*和网易云音乐对比了一下，发现也是放大1.5倍*/}</code></pre><hr><h1 id="播放tabBar"><a href="#播放tabBar" class="headerlink" title="播放tabBar"></a>播放tabBar</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b8f674f2bdc7a5?w=403&h=731&f=gif&s=1441605" alt=""><br>思路是参考酷狗音乐小程序。这个tabBar的js，wxml与播放功能界面的js，wxml相同。因为音乐播放是用<code>wx.getBackgroundAudioManager()</code>背景音频播放器管理的，所以才能同步。</p><hr><h1 id="我的tabBar"><a href="#我的tabBar" class="headerlink" title="我的tabBar"></a>我的tabBar</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b8f828b086f094?w=418&h=735&f=png&s=154747" alt=""></p><h2 id="播放历史"><a href="#播放历史" class="headerlink" title="播放历史"></a>播放历史</h2><p>思路：play.js中一旦播放成功就把歌名及歌曲ID传入全局变量-&gt;push到play.js里的数组中-&gt;<code>wx.setStorageSync</code>把数据存入缓存-&gt;在需要的页面<code>wx.getStorageSync</code>获取到缓存。</p><pre><code>&lt;!--play.js--&gt;const history_songId = this.data.history_songIdconst historySong = {      // id: res.id      id: app.globalData.songId,      songName:app.globalData.songName    }    history_songId.push(historySong)    wx.setStorageSync(&#39;historyId&#39;, history_songId); //把historyId存入缓存</code></pre><pre><code>&lt;!--me.js--&gt; onShow:function(){    var history = wx.getStorageSync(&#39;historyId&#39;);    // console.log(history)     this.setData({      hidden:true,      //  historyId: app.globalData.songName       historyId: history    })    console.log(this.data.historyId)  }</code></pre><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  做项目的过程总的来说痛并快乐，因为改不出BUG的样子真的很狼狈，但实现了某一个功能的那一刻真的很欣慰。再次感谢给予帮助的老师同学。如果你喜欢这篇文章或者可以帮到你，不妨点个赞吧！同时也非常希望看到这篇文章的你在下方给出建议！最后奉上<a href="https://github.com/zhongjunhaoz/CloudMusic" target="_blank" rel="noopener"><strong>源码</strong></a>，有需要的可以自取。最后，说点题外话，因为我是2020届毕业生，现在面临实习压力，有没有大佬捞一下。</p><p>  欢迎访问我的<a href="https://zhongjunhaoz.github.io/">个人博客</a>，定时分享技术文章，一起前端学习！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
