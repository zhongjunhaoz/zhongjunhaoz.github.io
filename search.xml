<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>仿网易云音乐微信小程序</title>
      <link href="/2019/10/20/fang-wang-yi-yun-yin-le-wei-xin-xiao-cheng-xu/"/>
      <url>/2019/10/20/fang-wang-yi-yun-yin-le-wei-xin-xiao-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="项目部分截图-Gif"><a href="#项目部分截图-Gif" class="headerlink" title="项目部分截图(Gif)"></a>项目部分截图(Gif)</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/24/16b89bbee707dd70?w=405&h=692&f=gif&s=3289476" alt=""><br><img src="https://user-gold-cdn.xitu.io/2019/6/24/16b89f9bc0492380?w=405&h=692&f=gif&s=3465695" alt=""><br><img src="https://user-gold-cdn.xitu.io/2019/6/24/16b89c4f8e1eccb5?w=405&h=692&f=gif&s=4980551" alt=""></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一阵子学习了微信小程序，为了巩固所学的知识和提高实战经验，决定自己手撸一款小程序。因为听歌一直在用网易云音乐，所以突发奇想就做一款仿网易云音乐的小程序吧！开发中遇到了很多在学习中没有遇到过的坑，也很感谢在我改不出BUG时给予帮助的老师同学！本着学习和分享的目的，写下以下的文字,希望能给<strong>初学小程序的你</strong>带来一点帮助,大佬轻点喷。</p><hr><h1 id="开发前准备"><a href="#开发前准备" class="headerlink" title="开发前准备"></a>开发前准备</h1><ul><li>VScode代码编辑器。</li><li>微信开发者工具</li><li>ios网易云音乐(V5.9.1版本)</li><li>酷狗音乐小程序(提供了一些思路)</li><li><a href="[http://musicapi.leanapp.cn/">网易云音乐API</a></li><li>(<a href="https://www.iconfont.cn" target="_blank" rel="noopener">阿里巴巴矢量图标库</a>)提供一些图标icon</li></ul><hr><h1 id="tabBar部分"><a href="#tabBar部分" class="headerlink" title="tabBar部分"></a>tabBar部分</h1><h2 id="自定义tabBar"><a href="#自定义tabBar" class="headerlink" title="自定义tabBar"></a><strong>自定义tabBar</strong></h2><p>一般在开发中，微信小程序给我们的tabBar就能满足需求。但是，有些特别的需求必须使用自定义tabBar才能满足。<br>比如tabBar实现半透明。那么，如何才能自定义tabBar呢？<br>    1.首先,在 app.json里的”tabBar”里声明<br>    <code>&quot;tabBar&quot;: {    &quot;custom&quot;: true    }</code><br>    2.接着在项目的根目录下新建一个<code>custom-tab-bar</code>文件夹。里面包含<code>index.wxml index.js index.json index.wxss</code>四个文件。更多细节参考<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html" target="_blank" rel="noopener">微信小程序文档</a><br><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8a44df06fca6e?w=511&h=229&f=png&s=66834" alt=""></p><pre><code>&lt;!-- index.html --&gt;&lt;!-- 自定义tabbar页面 --&gt;&lt;cover-view class=&quot;tab-bar&quot;&gt;   &lt;cover-view class=&quot;tab-bar-border&quot;&gt;&lt;/cover-view&gt;&lt;!--tabBal边框样式  --&gt;&lt;!-- 乐库tabbar --&gt;  &lt;cover-view class=&#39;tab-bar-item&#39; &gt;    &lt;cover-image src=&#39;../images/music.png&#39; hidden=&#39;{{isShow_index}}&#39; bindtap=&#39;switchTab_index&#39;&gt;&lt;/cover-image&gt;    &lt;cover-image src=&#39;../images/selected-music.png&#39; hidden=&#39;{{!isShow_index}}&#39; bindtap=&#39;switchTab_index&#39;&gt;&lt;/cover-image&gt;    &lt;cover-view style=&quot;color:{{isShow_index ? selectedColor : color}}&quot;&gt;乐库&lt;/cover-view&gt;  &lt;/cover-view&gt;&lt;!-- 播放tabbar --&gt;    &lt;cover-view class=&#39;tab-bar-item&#39; bindtap=&#39;switchTab_playing&#39;&gt;    &lt;cover-image src=&#39;../images/selected-playing.png&#39; hidden=&#39;{{isShow_playing}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-image src=&#39;../images/playing.png&#39; hidden=&#39;{{!isShow_playing}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-view&gt;&lt;/cover-view&gt;  &lt;/cover-view&gt;&lt;!-- 我的tabbar --&gt;    &lt;cover-view class=&#39;tab-bar-item&#39; bindtap=&#39;switchTab_me&#39;&gt;    &lt;cover-image src=&#39;../images/me.png&#39; hidden=&#39;{{isShow_me}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-image src=&#39;../images/selected-me.png&#39; hidden=&#39;{{!isShow_me}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-view style=&quot;color:{{isShow_me ? selectedColor : color}}&quot;&gt;我的&lt;/cover-view&gt;  &lt;/cover-view&gt;&lt;/cover-view&gt;</code></pre><pre><code>// index.jsComponent({  data: {    isShow_index:true,    isShow_playing:false,    isShow_me:false,    selected: 0, //首页    color: &quot;#8D8D8D&quot;,    selectedColor: &quot;#C62F2F&quot;,    list: [{      pagePath: &quot;/pages/index/index&quot;,      iconPath: &quot;/images/music.png&quot;,      selectedIconPath: &quot;/images/selected-music.png&quot;,      text: &quot;乐库&quot;    }, {      pagePath: &quot;/pages/love/love&quot;,        iconPath: &quot;/images/selected-playing.png&quot;,      selectedIconPath: &quot;/images/playing.png&quot;,      text: &quot;&quot;    },      {        pagePath: &quot;/pages/me/me&quot;,        iconPath: &quot;/images/me.png&quot;,        selectedIconPath: &quot;/images/selected-me.png&quot;,        text: &quot;我的&quot;      }]  },  methods: {    switchTab_index:function(){      wx.switchTab({        url:&#39;/pages/index/index&#39;      })      this.setData({        isShow_index: true,        isShow_me: false,        isShow_playing: false      })    },    switchTab_playing: function () {      wx.switchTab({        url: &#39;/pages/love/love&#39;      })      this.setData({        isShow_playing: true,        isShow_index: false,        isShow_me: false      })    },    switchTab_me: function () {      wx.switchTab({        url: &#39;/pages/me/me&#39;      })      this.setData({        isShow_me:true,        isShow_playing: false,        isShow_index: false      })    }  }})</code></pre><h2 id="tabBar半透明"><a href="#tabBar半透明" class="headerlink" title="tabBar半透明"></a><strong>tabBar半透明</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8a6ee63e9f2da?w=405&h=94&f=gif&s=538191" alt=""></p><pre><code>/* custom-tab-bar/index.wxss */.tab-bar {  height:7%;  position: fixed;  bottom: 0;  left: 0;  right: 0;  height: 48px;  background:#FAFBFD;  opacity: 0.93;  display: flex;  padding-bottom: env(safe-area-inset-bottom);}</code></pre><h1 id="API封装"><a href="#API封装" class="headerlink" title="API封装"></a>API封装</h1><p>一般我们https请求都是通过<code>wx.request</code>来请求,但是这种方法只能请求一次数据,如果首页用<code>wx.request</code>来请求的话,代码看起来会很冗长和杂乱。不仅自己容易搞糊涂,其他人看代码时也会很累。因此为了代码的整洁干净,我在这里新建了一个文件专门存放API。一般在根目录下的<code>utils</code>文件夹下新建一个<code>api.js</code>,但我在根目录下新建了文件夹<code>API</code>,里面包含<code>api.js</code>。</p><pre><code>// api.jsconst API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const request = (url, data) =&gt; {   let _url = API_BASE_URL  + url;  return new Promise((resolve, reject) =&gt; {    wx.request({      url: _url,      method: &quot;get&quot;,      data: data,      header: {        &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;      },      success(request) {        resolve(request.data)      },      fail(error) {        reject(error)      }    })  });}module.exports ={  gethotsongs:(data) =&gt;{    return request(&#39;/search/hot&#39;,data)//热搜接口  },  searchSuggest:(data)=&gt;{    return request(&#39;/search/suggest&#39;,data)//搜索建议接口  },  searchResult:(data)=&gt;{    return request(&#39;/search&#39;,data)//搜索结果接口  },  getBanner:(data)=&gt;{    return request(&#39;/banner&#39;,data)//个性推荐轮播  },  getsongsheet:(data)=&gt;{    return request(&#39;/top/playlist&#39;,data)//热门歌单接口  },  getNewSong:(data)=&gt;{    return request(&#39;/personalized/newsong&#39;,data)//最新音乐接口  },  getDjRadios:(data)=&gt;{    return request(&#39;/dj/recommend&#39;,data)//电台推荐接口  },  getProgramRecommend:(data)=&gt;{    return request(&#39;/program/recommend&#39;,data)//推荐节目接口  },  getRecommendType:(data)=&gt;{    return request(&#39;/dj/recommend/type&#39;,data)//所有电台分类推荐  },  getRecommendMV:(data)=&gt;{    return request(&#39;/personalized/mv&#39;,data)//推荐MV  },  getNewMv:(data)=&gt;{    return request(&#39;/mv/first&#39;,data)//最新MV  },  getNewEst:(data)=&gt;{    return request(&#39;/album/newest&#39;,data)//最新专辑  },  getTopList:(data)=&gt;{    return request(&#39;/top/list&#39;,data)//排行榜  },  getDjList:(data)=&gt;{    return request(&#39;/dj/catelist&#39;,data) //电台分类  },  getPay:(data)=&gt;{    return request(&#39;/dj/paygift&#39;,data)//付费精品  },  getSonger:(data)=&gt;{    return request(&#39;/toplist/artist&#39;,data)//歌手排行  }}</code></pre><p><code>api.js</code>只能通过<code>module.exports</code>来暴露,那个页面要数据就从这拿。如果在哪个页面要用到它,还需要在头部引入一下:</p><p><code>const API = require(&#39;../../API/api&#39;)</code></p><p>以个性推荐轮播图为例，</p><pre><code>  getBanner: function() {    API.getBanner({      type: 2    }).then(res =&gt; {      if (res.code === 200) { //更加严谨        this.setData({          banner: res.banners        })      }    })  }</code></pre><p>  这样就把请求到的数据存储到<code>banner</code>中了。</p><hr><h1 id="搜索部分"><a href="#搜索部分" class="headerlink" title="搜索部分"></a>搜索部分</h1><h2 id="输入框样式"><a href="#输入框样式" class="headerlink" title="输入框样式"></a><strong>输入框样式</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8da289aa52854?w=436&h=97&f=png&s=7182" alt=""><br>我这里是引入了<code>WEUI</code>的样式，<br>1.下载<code>weui.wxss</code>,链接我找不到了，所以我放上了我的<a href="https://github.com/zhongjunhaoz/CloudMusic/blob/master/weui.wxss" target="_blank" rel="noopener">github</a>上的<code>weui.wxss</code>。<br>2.把下载好的<code>weui.wxss</code>放到根目录下。<br>3.在<code>app.wxss</code>中<code>@import &quot;weui.wxss&quot;;</code>引入一下就可以使用微信提供给我们的样式了。<br>4.<a href="https://weui.io/" target="_blank" rel="noopener"><code>WeUI</code>样式库</a></p><h2 id="热门搜索"><a href="#热门搜索" class="headerlink" title="热门搜索"></a><strong>热门搜索</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8daeda7452a8f?w=415&h=404&f=png&s=31051" alt=""><br>上面已经提到我从<code>api.js</code>中拿数据。</p><pre><code> // 从接口到获取到数据导入到hotsongs  gethotsongs() {    API.gethotsongs({ type: &#39;new&#39; }).then(res =&gt; {      wx.hideLoading()      if (res.code === 200) {  //严谨        this.setData({          hotsongs: res.result.hots        })      }    })  }</code></pre><h2 id="搜索历史"><a href="#搜索历史" class="headerlink" title="搜索历史"></a><strong>搜索历史</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dba723508edc?w=419&h=741&f=png&s=42298" alt=""><br>思路：当在输入框输入完成后–&gt;失去焦点–&gt; 利用<code>wx.setStorageSync</code>存进缓存中–&gt;<code>wx.getStorageSync</code>获取到并把它打印出来。</p><pre><code>  // input失去焦点函数  routeSearchResPage: function(e) {    console.log(e.detail.value)    let history = wx.getStorageSync(&quot;history&quot;) || [];    history.push(this.data.searchKey)    wx.setStorageSync(&quot;history&quot;, history);  },//每次显示变动就去获取缓存，给history，并for出来。  onShow: function () {    this.setData({      history: wx.getStorageSync(&quot;history&quot;) || []    })  },</code></pre><h2 id="清空搜索历史"><a href="#清空搜索历史" class="headerlink" title="清空搜索历史"></a><strong>清空搜索历史</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dbe42c2c2c33?w=405&h=487&f=gif&s=119001" alt=""><br>思路：×图标绑定事件-&gt;呼出对话框<code>wx.showModal</code>-&gt;确定则把<code>history</code>赋值为空</p><pre><code>    // 清空page对象data的history数组 重置缓存为[]  clearHistory: function() {    const that = this;    wx.showModal({      content: &#39;确认清空全部历史记录&#39;,      cancelColor:&#39;#DE655C&#39;,      confirmColor: &#39;#DE655C&#39;,      success(res) {        if (res.confirm) {          that.setData({            history: []          })          wx.setStorageSync(&quot;history&quot;, []) //把空数组给history,即清空历史记录        } else if (res.cancel) {        }      }    })  },</code></pre><h2 id="实时搜索建议"><a href="#实时搜索建议" class="headerlink" title="实时搜索建议"></a><strong>实时搜索建议</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dc5e9059003f?w=399&h=707&f=gif&s=62309" alt=""><br>思路：实时获取输入框的值-&gt;把值传给搜索建议API，发起网络请求-&gt;请求之后拿到搜索建议-&gt;打印结果并隐藏其他组件只保留搜索建议的组件(类似于Vue里的v-show)</p><pre><code> //获取input文本并且实时搜索,动态隐藏组件  getsearchKey:function(e){    console.log(e.detail.value) //打印出输入框的值    let that = this;    if(e.detail.cursor != that.data.cursor){ //实时获取输入框的值      that.setData({        searchKey: e.detail.value      })    }    if(e.value!=&quot;&quot;){ //组件的显示与隐藏      that.setData({        showView: false      })    } else{      that.setData({        showView: &quot;&quot;      })    }    if(e.detail.value!=&quot;&quot;){ //解决 如果输入框的值为空时，传值给搜索建议，会报错的bug      that.searchSuggest();    }    }</code></pre><pre><code>  // 搜索建议  searchSuggest(){    API.searchSuggest({ keywords: this.data.searchKey ,type:&#39;mobile&#39;}).then(res=&gt;{      if(res.code === 200){        this.setData({          searchsuggest:res.result.allMatch        })      }    })  }</code></pre><h2 id="点击热搜或历史，执行搜索"><a href="#点击热搜或历史，执行搜索" class="headerlink" title="点击热搜或历史，执行搜索"></a>点击热搜或历史，执行搜索</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8eefd6bdf126f?w=403&h=703&f=gif&s=257246" alt=""><br>思路：关键是<code>event</code>,点击通过<code>e.currentTarget.dataset.value</code>拿到所点击的值，再交给其他方法执行搜索行为。</p><pre><code>// 点击热门搜索值或搜索历史，填入搜索框  fill_value:function(e){    let that = this;    console.log(history)    // console.log(e.currentTarget.dataset.value)    that.setData({      searchKey: e.currentTarget.dataset.value,//点击吧=把值给searchKey,让他去搜索      inputValue: e.currentTarget.dataset.value,//在输入框显示内容      showView:false,//给false值，隐藏 热搜和历史 界面      showsongresult: false, //给false值，隐藏搜索建议页面    })    that.searchResult(); //执行搜索功能  }</code></pre><h2 id="搜索结果"><a href="#搜索结果" class="headerlink" title="搜索结果"></a><strong>搜索结果</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dd6660f63f9a?w=399&h=707&f=gif&s=63353" alt=""><br>思路：输入结束-&gt;确认键-&gt;调用<code>searchResult</code>请求到结果</p><pre><code>// 搜索完成点击确认  searchover:function(){    let that = this;    that.setData({      showsongresult: false    })    that.searchResult();  }</code></pre><pre><code>   // 搜索结果  searchResult(){    console.log(this.data.searchKey)    API.searchResult({ keywords: this.data.searchKey, type: 1, limit: 100, offset:2 }).then(res =&gt; {      if (res.code === 200) {        this.setData({          searchresult: res.result.songs        })      }    })  }</code></pre><hr><h1 id="乐库部分"><a href="#乐库部分" class="headerlink" title="乐库部分"></a>乐库部分</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8deb716cb19fc?w=1049&h=734&f=png&s=483647" alt=""><br>乐库部分其实没什么逻辑很难的部分，以结构和样式为主，在这里就不赘述了。可以到我的<a href="https://github.com/zhongjunhaoz/CloudMusic" target="_blank" rel="noopener">github</a>上查看。在这里分享一些小功能的实现和踩到的坑。</p><h2 id="个性推荐，主播电台切换"><a href="#个性推荐，主播电台切换" class="headerlink" title="个性推荐，主播电台切换"></a><strong>个性推荐，主播电台切换</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8e03ef5ad0dbc?w=403&h=669&f=gif&s=1612390" alt=""><br>1.个性推荐和主播电台是两个<code>swiper-item</code>所以他们才可以左右滑动，就像轮播图一样，不过轮播图放的是图片，而这里放的是整个页面。<br>2.我要实现的效果是左右滑动的同时，<code>个性推荐</code>和<code>主播电台</code>下面的白色方块也要跟着滑动。<br><strong>1. 第一种方法</strong><br>给包裹两个<code>swiper-item</code>的<code>swiper</code>添加一个<code>bindchange=&quot;changeline&quot;</code>事件，把事件对象<code>event</code>打印出来发现，<code>console.log(e.detail.current)</code>,当我们左右滑动的时候<code>cuurrent</code>的值会在<code>0</code>和<code>1</code>之间切换。所以我给白色方块添加</p><pre><code>class=&quot;{{changeline?'swiper_header_line_before':'swiper_header_line_after'}}&quot;</code></pre><pre><code>    if(e.detail.current === 0){    this.setData({       changeline:true      })    }else{    this.setData({       changeline:false      })    }</code></pre><p>当<code>current</code>为0，即页面在个性推荐时，让<code>changeline</code>为<code>true</code>;当<code>current</code>为1，即页面在主播电台时，让<code>changeline</code>为<code>false</code>;为<code>true</code>时，给白色方块加持<code>swiper_header_line_before</code>的样式，为<code>false</code>时，加持<code>swiper_header_line_after</code>的样式。这样就可以跟随<code>swiper-item</code>的滑动而切换了。<strong>但是，这种切换方式太僵硬了</strong>，没有那种流畅的切换效果，而且不适合多<code>swiper-item</code>页面。<br><strong>2. 第二种方法</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8e8d9a71ab12a?w=436&h=295&f=png&s=23978" alt=""><br>让一半宽度，四分之一宽度设置为变量是为了兼容不同的手机型号。因为写死数据肯定会有BUG，所以才要计算宽度。</p><pre><code>&lt;view class=&quot;weui-navbar-slider&quot; style=&quot;transform:translateX({{slideOffset}}px);&quot;&gt;&lt;/view&gt;</code></pre><pre><code>.weui-navbar-slider{  width:28px;  height: 5px;  background: #ffffff;  border-radius:10rpx;  transition: transform .6s; }</code></pre><p><code>slideOffset</code>为变量，动态接受从<code>data</code>传来的数据。</p><pre><code>onLoad:function(){    wx.getSystemInfo({      success: function (res) {        // console.log(res.windowWidth)        // console.log(res.windowWidth / 2 / 2)        half = res.windowWidth / 2 ;        quarter = res.windowWidth / 2 / 2;        that.setData({          slideOffset: quarter - 14 //onLoad的时候让 quarter - 14 给slideOffset，即一开始就让他在个性推荐的下面，否则onLoad的时候一开始在0的位置        })      }    })}  changeline:function(e){    // console.log(e)    // console.log(e.detail.current)    let current = e.detail.current; //获取swiper的current值    if(e.detail.current === 0){      this.setData({        slideOffset: quarter - 14      })    }    if(e.detail.current === 1){      this.setData({        slideOffset: (quarter - 14) + half      })    }    if(e.detail.current === null){      this.setData({        slideOffset: quarter - 14      })    }  }</code></pre><h2 id="MV播放"><a href="#MV播放" class="headerlink" title="MV播放"></a>MV播放</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8ea3d1f4e6c01?w=403&h=669&f=gif&s=2204017" alt=""><br>主要是结构和样式，我直接上代码了。</p><pre><code>&lt;!-- play_mv.wxml --&gt;&lt;view class=&quot;mv_box&quot;&gt;    &lt;video src=&quot;{{mv.brs['480']}}&quot; class=&quot;mv&quot; autoplay=&quot;{{autoplay}}&quot; loop=&quot;{{loop}}&quot; direction=&quot;{{0}}&quot; show-fullscreen-btn=&quot;{{showfullscreenbtn}}&quot;    show-center-play-btn=&quot;{{showcenterplaybtn}}&quot; enable-progress-gesture=&quot;{{enableprogressgesture}}&quot; show-mute-btn=&quot;{{showmutebtn}}&quot; title=&quot;{{mv.name}}&quot;    play-btn-position=&quot;{{center}}&quot; object-fit=&quot;{{objectfit}}&quot;&gt;&lt;/video&gt;&lt;/view&gt;&lt;view class=&quot;mv_name&quot;&gt;{{mv.name}}&lt;/view&gt;&lt;view class=&quot;mv_time&quot;&gt; 发行:  {{mv.publishTime}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_times&quot;&gt;播放次数:  {{mv.playCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc&quot;&gt;{{mv.desc}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;点赞: {{mv.likeCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;收藏: {{mv.subCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;评论: {{mv.commentCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;分享: {{mv.shareCount}}&lt;/view&gt;</code></pre><pre><code>/* play/play_mv.wxss */.mv_box{    width: 100%;    height: 480rpx;    margin-top:-2rpx;}.mv{    width: 100%;    height: 100%;    border-radius:15rpx;}.mv_name{    margin-top:20rpx;    margin-left:20rpx;}.mv_time{    font-size: 12px;    margin-left:20rpx;    color:#979798;    display:initial;}.mv_times{    margin-left: 100rpx;}.mv_desc{    display: block;    color:#6A6B6C;}.mv_other{    display: block;}</code></pre><pre><code>// play_mv.jsconst API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const app = getApp();Page({  data: {    mv: [],    autoplay: true,    loop: true,    showfullscreenbtn: true,    showcenterplaybtn: true,    enableprogressgesture: true,    showmutebtn: true,    objectfit: &#39;contain&#39;,  },  onLoad: function (options) {    // console.log(mv_url);    const mvid = options.id; // onLoad()后获取到歌曲视频之类的id    // 请求MV的地址，失败则播放出错，成功则传值给createBgAudio(后台播放管理器，让其后台播放)    wx.request({      url: API_BASE_URL + &#39;/mv/detail&#39;,      data: {        mvid: mvid          },      success: res =&gt; {        console.log(res.data.data.brs[&#39;480&#39;])        console.log(&#39;歌曲音频url:&#39;, res)        if (res.data.data.brs === null) {  //如果是MV 电台 广告 之类的就提示播放出错，并返回首页          console.log(&#39;播放出错&#39;)          wx.showModal({            content: &#39;服务器开了点小差~~&#39;,            cancelColor: &#39;#DE655C&#39;,            confirmColor: &#39;#DE655C&#39;,            showCancel: false,            confirmText: &#39;返回&#39;,            complete() {              wx.switchTab({                url: &#39;/pages/index/index&#39;              })            }          })        } else {          this.setData({            mv: res.data.data          })        }      }    })  },})</code></pre><h2 id="歌手榜"><a href="#歌手榜" class="headerlink" title="歌手榜"></a>歌手榜</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8eaed5f5e5b3b?w=795&h=695&f=png&s=242469" alt=""></p><pre><code>// 歌手榜的jsconst API = require(&#39;../../API/api&#39;);const app = getApp();Page({  data: {    songers: [], //歌手榜  },  onLoad: function (options) {    wx.showLoading({      title: &#39;加载中&#39;,    });    this.getSonger();  },  getSonger: function () {    API.getSonger({}).then(res =&gt; {      wx.hideLoading()      this.setData({        songers: res.list.artists.slice(0, 100)      })    })  },  handleSheet: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性    const sheetId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面      url: `./moremore_songer?id=${sheetId}`    })  },})</code></pre><pre><code>&lt;!-- 歌手榜结构 --&gt;&lt;view wx:for=&quot;{{songers}}&quot; wx:key=&quot;&quot; class=&#39;songer_box&#39; data-id=&quot;{{item.id}}&quot; bindtap=&#39;handleSheet&#39;&gt;  &lt;view class=&#39;songer_index_box&#39;&gt;    &lt;text class=&#39;songer_index&#39;&gt;{{index + 1}}&lt;/text&gt;  &lt;/view&gt;  &lt;view class=&#39;songer_img_box&#39;&gt;  &lt;image src=&quot;{{item.picUrl}}&quot; class=&#39;songer_img&#39;&gt;&lt;/image&gt;  &lt;/view&gt;  &lt;view class=&#39;songer_name_box&#39;&gt;  &lt;text class=&#39;songer_name&#39;&gt;{{item.name}}&lt;/text&gt;  &lt;text class=&#39;songer_score&#39;&gt;{{item.score}}热度&lt;/text&gt;  &lt;/view&gt;&lt;/view&gt;</code></pre><pre><code>// 歌手下级路由歌曲列表const API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const app = getApp();Page({  data: {    songList: []  },  onLoad: function (options) {    wx.showLoading({      title: &#39;加载中&#39;,    });    const sheetId = options.id;    wx.request({      url: API_BASE_URL + &#39;/artists&#39;,      data: {        id: sheetId          },      success: res =&gt; {        const waitForPlay = new Array;        for (let i = 0; i &lt;= res.data.hotSongs.length - 1; i++) { //循环打印出其id          waitForPlay.push(res.data.hotSongs[i].id) //循环push ID 到waitForPlay数组          app.globalData.waitForPlaying = waitForPlay  //让waitForPlay数组给全局数组          // console.log(app.globalData.waitForPlaying)        }        wx.hideLoading()        console.log(res.data.hotSongs)        this.setData({          songList: res.data.hotSongs        })      }    })  },  handlePlayAudio: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性    const audioId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面      url: `../../play/play?id=${audioId}`    })  }})</code></pre><pre><code>&lt;!-- more/more_songer/moremore_songer.wxml歌手下面的歌曲 --&gt;&lt;view class=&#39;search_result_songs&#39;&gt;  &lt;view wx:for=&quot;{{songList}}&quot; wx:key=&quot;&quot; class=&#39;search_result_song_item songer_box&#39; data-id=&quot;{{item.id}}&quot; bindtap=&#39;handlePlayAudio&#39;&gt;    &lt;view class=&#39;songer_index_box&#39;&gt;      &lt;text class=&#39;songer_index&#39;&gt;{{index + 1}}&lt;/text&gt;    &lt;/view&gt;    &lt;view class=&#39;songer_img_box&#39;&gt;      &lt;view class=&#39;search_result_song_song_name&#39;&gt;{{item.name}}&lt;/view&gt;      &lt;view class=&#39;search_result_song_song_art-album&#39;&gt;{{item.ar[0].name}} - {{item.al.name}}&lt;/view&gt;    &lt;/view&gt;  &lt;/view&gt;&lt;/view&gt;</code></pre><h2 id="推荐歌单"><a href="#推荐歌单" class="headerlink" title="推荐歌单"></a>推荐歌单</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8eb96b06ef0b4?w=800&h=642&f=png&s=373779" alt=""><br>因为样式与排行榜类似，所以只放出图片，源码可以到我的<a href="https://github.com/zhongjunhaoz/CloudMusic/tree/master/more/more_sheet" target="_blank" rel="noopener">github</a>上查看。</p><h2 id="榜单排行"><a href="#榜单排行" class="headerlink" title="榜单排行"></a>榜单排行</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8ebf82357b4e6?w=735&h=623&f=png&s=222179" alt=""><br><a href="https://github.com/zhongjunhaoz/CloudMusic/tree/master/more" target="_blank" rel="noopener">请查看源码</a></p><h2 id="换一换功能"><a href="#换一换功能" class="headerlink" title="换一换功能"></a>换一换功能</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8ec5afa3172e5?w=403&h=386&f=gif&s=301154" alt=""><br>思路：绑定点击事件-&gt;选取随机的三个数-&gt;给空值-&gt;push三个随机数进数组中-&gt;重新赋值。</p><pre><code>  // 换一换  change_1:function(){    let maxNum = this.data.more_recommend_create.length  //计算数据长度    let r1 = parseInt(Math.random() * (maxNum - 0) + 0); //取【0-数据长度】内的整数随机数    let r2 = parseInt(Math.random() * (maxNum - 0) + 0);    let r3 = parseInt(Math.random() * (maxNum - 0) + 0);    this.setData({      recommend_create: []    })    //重新取3组数据    this.data.recommend_create.push(this.data.more_recommend_create[r1])    this.data.recommend_create.push(this.data.more_recommend_create[r2])    this.data.recommend_create.push(this.data.more_recommend_create[r3])    //重新赋值    this.setData({      recommend_create: this.data.recommend_create    })  }</code></pre><h1 id="播放界面"><a href="#播放界面" class="headerlink" title="播放界面"></a>播放界面</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8f088b494cb9c?w=403&h=703&f=gif&s=3753267" alt=""><br>图片太大，因此加快了播放。</p><h2 id="播放功能"><a href="#播放功能" class="headerlink" title="播放功能"></a>播放功能</h2><p><strong>思路：利用<code>data-id=&quot;&quot;</code>获取到歌曲ID放在<code>event</code>中-&gt; 通过<code>event</code>对象事件获取ID并跳转到播放页面 -&gt;<code>wx.request</code>获取到歌曲的音频地址及detail-&gt;背景音频管理器 <code>wx.getBackgroundAudioManager()</code>-&gt;播放</strong><br>以歌手榜下级路由歌曲列表为例，  </p><pre><code>&lt;view wx:for=&quot;{{songList}}&quot; wx:key=&quot;&quot; class=&#39;search_result_song_item songer_box&#39; data-id=&quot;{{item.id}}&quot; bindtap=&#39;handlePlayAudio&#39;&gt;</code></pre><pre><code>  handlePlayAudio: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性    const audioId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面      url: `../../play/play?id=${audioId}`    })  }</code></pre><pre><code>  // play.jsconst API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const app = getApp();Page({  data: {    isPlay: &#39;&#39;,    song:[],    innerAudioContext: {},    show:true,    showLyric:true,    songid:[],    history_songId:[]  },  onLoad: function (options) {    const audioid = options.id; // onLoad()后获取到歌曲视频之类的id    this.play(audioid); //把从wxml获取到的值传给play()  },  play: function (audioid){    const audioId = audioid;    app.globalData.songId = audioId;  //让每一个要播放的歌曲ID给全局变量的songId    const innerAudioContext = wx.createInnerAudioContext();    this.setData({      innerAudioContext,      isPlay: true    })    // 请求歌曲音频的地址，失败则播放出错，成功则传值给createBgAudio(后台播放管理器，让其后台播放)    wx.request({      url: API_BASE_URL + &#39;/song/url&#39;,      data: {        id: audioId      },      success: res =&gt; {        if (res.data.data[0].url === null) {  //如果是MV 电台 广告 之类的就提示播放出错，并返回首页          wx.showModal({            content: &#39;服务器开了点小差~~&#39;,            cancelColor: &#39;#DE655C&#39;,            confirmColor: &#39;#DE655C&#39;,            showCancel: false,            confirmText: &#39;返回&#39;,            complete() {              wx.switchTab({                url: &#39;/pages/index/index&#39;              })            }          })        } else {          this.createBgAudio(res.data.data[0]);        }      }    })    //获取到歌曲音频，则显示出歌曲的名字，歌手的信息，即获取歌曲详情；如果失败，则播放出错。    wx.request({      url: API_BASE_URL + &#39;/song/detail&#39;,      data: {        ids: audioId    //必选参数ids      },      success: res =&gt; {        if (res.data.songs.length === 0) {          wx.showModal({            content: &#39;服务器开了点小差~~&#39;,            cancelColor: &#39;#DE655C&#39;,            confirmColor: &#39;#DE655C&#39;,            showCancel: false,            confirmText: &#39;返回&#39;,            complete() {              wx.switchTab({                url: &#39;/pages/index/index&#39;              })            }          })        } else {          this.setData({            song: res.data.songs[0],  //获取到歌曲的详细内容，传给song          })          app.globalData.songName = res.data.songs[0].name;        }      },    })  },  createBgAudio(res) {    const bgAudioManage = wx.getBackgroundAudioManager(); //获取全局唯一的背景音频管理器。并把它给实例bgAudioManage    app.globalData.bgAudioManage = bgAudioManage;         //把实例bgAudioManage(背景音频管理器) 给 全局    bgAudioManage.title = &#39;title&#39;;                        //把title 音频标题 给实例    bgAudioManage.src = res.url;                          // res.url 在createBgAudio 为 mp3音频  url为空，播放出错    const history_songId = this.data.history_songId    const historySong = {      id: app.globalData.songId,      songName:app.globalData.songName    }    history_songId.push(historySong)    bgAudioManage.onPlay(res =&gt; {                         // 监听背景音频播放事件      this.setData({        isPlay: true,        history_songId      })    });    bgAudioManage.onEnded(() =&gt; {                  //监听背景音乐自然结束事件，结束后自动播放下一首。自然结束，调用go_lastSong()函数，即歌曲结束自动播放下一首歌      this.go_lastSong();    })    wx.setStorageSync(&#39;historyId&#39;, history_songId); //把historyId存入缓存  },})</code></pre><h2 id="暂停-播放"><a href="#暂停-播放" class="headerlink" title="暂停/播放"></a>暂停/播放</h2><pre><code>    &lt;!-- 暂停播放图标 --&gt;  &lt;view class=&quot;play_suspend&quot;&gt;    &lt;view class=&quot;icon_playing&quot;&gt;&lt;image bindtap=&quot;handleToggleBGAudio&quot; src=&quot;../images/suspend.png&quot; hidden=&quot;{{!isPlay}}&quot; class=&quot;{{'img_play_suspend'}}&quot; /&gt;  &lt;!-- 暂停图标--&gt;    &lt;image bindtap=&quot;handleToggleBGAudio&quot; src=&quot;../images/play.png&quot; hidden=&quot;{{isPlay}}&quot; class=&quot;{{'img_play_suspend'}}&quot; /&gt;&lt;/view&gt; &lt;!--播放图标--&gt;  &lt;/view&gt;</code></pre><pre><code>  // 播放和暂停  handleToggleBGAudio() {    // const innerAudioContext = app.globalData.innerAudioContext;    const bgAudioManage = app.globalData.bgAudioManage;    const {isPlay} = this.data;    if (isPlay) {      bgAudioManage.pause();      // innerAudioContext.pause();handleToggleBGAudio    } else {      bgAudioManage.play();      // innerAudioContext.play();    }    this.setData({      isPlay: !isPlay    })    console.log(this.data.isPlay)  }</code></pre><h2 id="上一首-下一首-随机播放"><a href="#上一首-下一首-随机播放" class="headerlink" title="上一首/下一首(随机播放)"></a>上一首/下一首(随机播放)</h2><p>  <strong>思路：点击歌单或歌手页，获取到对应的歌单/歌手id-&gt;<code>wx.request</code>请求数据获取到所有的歌单内/歌手热门歌曲音频地址-&gt;给全局变量globalData-&gt;点击上一首/下一首随机获取到全局变量的一则数据-&gt;给play()方法-&gt;播放</strong></p><pre><code>  &lt;!--歌单--&gt;    onLoad: function (options) {    wx.showLoading({      title: &#39;加载中&#39;,    });    const sheetId = options.id;    wx.request({      url: API_BASE_URL + &#39;/playlist/detail&#39;,      data: {        id: sheetId          },      success: res =&gt; {        const waitForPlay = new Array;        for (let i = 0; i &lt;= res.data.playlist.trackIds.length - 1;i++){ //循环打印出其id          waitForPlay.push(res.data.playlist.trackIds[i].id) //循环push ID 到waitForPlay数组          app.globalData.waitForPlaying = waitForPlay  //让waitForPlay数组给全局数组        }        wx.hideLoading()        this.setData({          songList: res.data.playlist.tracks        })        }    })  }</code></pre><pre><code>  &lt;view class=&quot;icon_playing &quot;&gt;&lt;image src=&quot;../images/lastSong.png&quot; class=&quot; icon_play&quot; bindtap=&quot;go_lastSong&quot; /&gt;&lt;/view&gt;  &lt;view class=&quot;icon_playing &quot;&gt;&lt;image src=&quot;../images/nextSong.png&quot; class=&quot; icon_play&quot; bindtap=&quot;go_lastSong&quot; /&gt;&lt;/view&gt;</code></pre><pre><code>    go_lastSong:function(){     let that = this;    const lastSongId = app.globalData.waitForPlaying;    const songId = lastSongId[Math.floor(Math.random() * lastSongId.length)]; //随机选取lastSongId数组的一个元素    that.data.songid = songId;    this.play(songId)//传进play()方法中    app.globalData.songId=songId;  }</code></pre><h2 id="歌词-封面切换"><a href="#歌词-封面切换" class="headerlink" title="歌词/封面切换"></a>歌词/封面切换</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b8f5e9d2a1e22b?w=403&h=703&f=gif&s=1127200" alt=""><br>  因为网易云API的歌词接口崩溃，请求不到歌词，所以我只能把歌词写死为<code>纯音乐，请欣赏</code>。类似于<code>v-show</code>。</p><pre><code>   &lt;!-- 封面 --&gt;  &lt;!-- 一开始onload时,showLyric=true, 显示为转动的图标，点击图标，切换为歌词--&gt;  &lt;view class=&quot;sing-show&quot; bindtap=&quot;showLyric&quot; &gt;    &lt;view class=&quot;moveCircle {{isPlay ? 'play' : ''}}&quot; hidden=&quot;{{!showLyric}}&quot;&gt;      &lt;image src=&quot;{{song.al.picUrl}}&quot; class=&quot;coverImg {{isPlay ? 'play' : ''}}&quot; hidden=&quot;{{!showLyric}}&quot;/&gt;    &lt;/view&gt;    &lt;text  hidden=&quot;{{showLyric}}&quot; class=&quot;songLyric&quot;&gt;纯音乐，请欣赏&lt;/text&gt;  &lt;/view&gt;</code></pre><pre><code>    // 点击切换歌词和封面  showLyric(){    const {showLyric} = this.data;    this.setData({      showLyric: !showLyric    })  }</code></pre><h2 id="破产版的孤独星球动效"><a href="#破产版的孤独星球动效" class="headerlink" title="破产版的孤独星球动效"></a>破产版的孤独星球动效</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8f4e771e9a04d?w=403&h=703&f=gif&s=1629412" alt=""><br>封面旋转：</p><pre><code>@keyframes rotate {  0%{    transform: rotate(0);  }  100%{    transform: rotate(360deg);  }}</code></pre><p>扩散的圆形线条：<br>其实就是外面套一个盒子，盒子宽高变大以及透明度逐渐变低。</p><pre><code>@keyframes moveCircle {  0%{    width: 400rpx;    height: 400rpx;    border: 1px solid rgba(255, 255, 255, 1)  }  30%{    width: 510rpx;    height: 510rpx;    border: 1px solid rgba(255, 255, 255, 0.8)  }  50%{    width: 610rpx;    height: 610rpx;    border: 1px solid rgba(255, 255, 255, 0.6)  }  80%{    width: 700rpx;    height: 700rpx;    border: 1px solid rgba(255, 255, 255, 0.4)  }  99%{    width: 375px;    height: 375px;    border: 1px solid rgba(255, 255, 255, 0.1)  }  100%{    width: 0px;    height: 0px;    border: 1px solid rgba(255, 255, 255, 0)  }}</code></pre><h2 id="背景毛玻璃"><a href="#背景毛玻璃" class="headerlink" title="背景毛玻璃"></a>背景毛玻璃</h2><pre><code>&lt;!-- play.wxml --&gt;&lt;image src=&quot;{{song.al.picUrl}}&quot; class=&quot;background_img&quot; &gt;&lt;/image&gt;</code></pre><pre><code>/* 播放界面毛玻璃效果 */.background_img{   position: fixed;  top: 0;  left: 0;  bottom: 0;  width: 100%;  height: 100%;  filter: blur(20px);  z-index: -1;  transform: scale(1.5); /*和网易云音乐对比了一下，发现也是放大1.5倍*/}</code></pre><hr><h1 id="播放tabBar"><a href="#播放tabBar" class="headerlink" title="播放tabBar"></a>播放tabBar</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b8f674f2bdc7a5?w=403&h=731&f=gif&s=1441605" alt=""><br>思路是参考酷狗音乐小程序。这个tabBar的js，wxml与播放功能界面的js，wxml相同。因为音乐播放是用<code>wx.getBackgroundAudioManager()</code>背景音频播放器管理的，所以才能同步。</p><hr><h1 id="我的tabBar"><a href="#我的tabBar" class="headerlink" title="我的tabBar"></a>我的tabBar</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b8f828b086f094?w=418&h=735&f=png&s=154747" alt=""></p><h2 id="播放历史"><a href="#播放历史" class="headerlink" title="播放历史"></a>播放历史</h2><p>思路：play.js中一旦播放成功就把歌名及歌曲ID传入全局变量-&gt;push到play.js里的数组中-&gt;<code>wx.setStorageSync</code>把数据存入缓存-&gt;在需要的页面<code>wx.getStorageSync</code>获取到缓存。</p><pre><code>&lt;!--play.js--&gt;const history_songId = this.data.history_songIdconst historySong = {      // id: res.id      id: app.globalData.songId,      songName:app.globalData.songName    }    history_songId.push(historySong)    wx.setStorageSync(&#39;historyId&#39;, history_songId); //把historyId存入缓存</code></pre><pre><code>&lt;!--me.js--&gt; onShow:function(){    var history = wx.getStorageSync(&#39;historyId&#39;);    // console.log(history)     this.setData({      hidden:true,      //  historyId: app.globalData.songName       historyId: history    })    console.log(this.data.historyId)  }</code></pre><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  做项目的过程总的来说痛并快乐，因为改不出BUG的样子真的很狼狈，但实现了某一个功能的那一刻真的很欣慰。再次感谢给予帮助的老师同学。如果你喜欢这篇文章或者可以帮到你，不妨点个赞吧！同时也非常希望看到这篇文章的你在下方给出建议！最后奉上<a href="https://github.com/zhongjunhaoz/CloudMusic" target="_blank" rel="noopener"><strong>源码</strong></a>，有需要的可以自取。最后，说点题外话，因为我是2020届毕业生，现在面临实习压力，有没有大佬捞一下。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/10/19/hello-world/"/>
      <url>/2019/10/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
