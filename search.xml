<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一文搞懂CSS中的字体单位大小</title>
      <link href="/2019/10/20/yi-wen-gao-dong-css-zhong-de-zi-ti-dan-wei-da-xiao/"/>
      <url>/2019/10/20/yi-wen-gao-dong-css-zhong-de-zi-ti-dan-wei-da-xiao/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习的过程中,发现CSS有很多可以描述单位的尺寸。比如<code>px</code>,<code>em</code>,<code>rem</code>,<code>vw</code>等等。平时也没有深究，一来是没时间，二来是在我学习清单中优先级过低。一直想彻底弄明白，一直耽搁到现在。现在花上一点时间来整理一下，彻底弄懂它。</p><h1 id="CSS长度单位"><a href="#CSS长度单位" class="headerlink" title="CSS长度单位"></a>CSS长度单位</h1><ul><li>绝对长度单位。<br>绝对长度单位表示为一个固定的值，不会改变。<strong>不利于页面渲染。</strong><ul><li>in,英寸</li><li>cm, 里面</li><li>mm, 毫米</li><li>pt</li><li>pc</li></ul></li><li>相对长度单位。<br>其长度单位会随着它的参考值的变化而变化。<ul><li>px,像素</li><li>em,元素的字体高度</li><li>%,百分比</li><li>rem,根元素的font-size</li><li>vm,视窗宽度，1vw=视窗宽度的1%</li><li>vh,视窗高度，1vh=视窗高度的1%</li></ul></li></ul><h1 id="物理像素-设备像素"><a href="#物理像素-设备像素" class="headerlink" title="物理像素(设备像素)"></a>物理像素(设备像素)</h1><p>比如有一个图片，细分，最小单位就是像素。也就是说，图片由许多的像素构成。像素是小方块，这些小方块都有一个明确的位置和被分配的色彩数值，小方格颜色和位置就决定该图像所呈现出来的样子。</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/25/16c27296fdd981a5?w=261&h=193&f=png&s=102964" alt=""><br><strong>一个设备生产出来，它们的像素就已经确定了。iPhone5的分辨率是<code>640x1136px</code>,代表屏幕由640行，1136列像素小方块组成。</strong></p><pre><code>为了理解像素和避免与CSS像素混淆，可以将物理像素当做物理小方块。比如iPhone5的像素是640X1136px,可以当做640*1136个小方块。</code></pre><h1 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h1><p>也叫做解析度，解像度。可以从显示分辨率与图像分辨率两个方向来分类。</p><ul><li>屏幕分辨率。是屏幕图像的精密度，是指显示器所能显示的像素有多少，即显示器可以可以显示的小方块有多少个。<ul><li><strong>显示器的可显示的小方块越多，画面就越精细，同样的屏幕区域内能显示的信息也越多</strong></li><li>可以把整个图像想象成是一个大型的棋盘，而分辨率的表示方式就是所有经线和纬线交叉点的数目。棋盘的小方块越多，可以放的棋子就越多。</li><li>显示分辨率一定的情况下，显示屏越小图像越清晰，反之，显示屏大小固定时，显示分辨率越高图像越清晰。(<strong>小方块一样多的情况下，显示屏越小越清晰；屏幕大小一样大的时候，小方块越多图形越清晰</strong>)<h1 id="CSS像素px"><a href="#CSS像素px" class="headerlink" title="CSS像素px"></a>CSS像素px</h1>CSS像素的单位也叫做<strong>px</strong>。它是图像显示的基本单元，既不是一个确定的物理量，也不是一个点或者小方块，而是一个抽象概念。所以在谈论像素时一定要清楚<strong>它的上下文！</strong></li></ul></li><li>为了保证阅读体验一致，CSS可以自动在不同设备之间可以调节。即一份代码可以在不同的大小的设备之间显示，并且可以保证阅读体验一致。</li><li>默认情况下一个CSS像素应该是等于一个物理像素的宽度。</li><li>但是在高PPI的设备上，CSS像素甚至在默认状态下就相当于多个物理像素的尺寸。比如iPhone的屏幕对比一般的手机屏幕会看起来更精细清晰一些。</li><li>在浏览器上通过<code>ctrl +/-</code>可以扩大缩小屏幕，其实就是屏幕分辩率的调低/调高。<code>ctrl +</code>屏幕放大，分辨率降低。</li><li>iPhone6,7,8都是两倍屏手机，即一个CSS像素等于2物理像素。iPhone6Plus等是三倍屏手机，一个CSS像素等于3物理像素。</li><li>以iPhone6为例，设计稿给出一个图片宽高为40*40。在实际开发中要除以2，宽高要写成20x20。因为iPhone6是两倍屏手机。</li></ul><h1 id="em"><a href="#em" class="headerlink" title="em"></a>em</h1><p>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，<strong>则相对于浏览器的默认字体尺寸,浏览器字体默认为16px</strong>。</p><ul><li>所以，1em = 16px。默认情况下。<h2 id="如何高效使用em呢"><a href="#如何高效使用em呢" class="headerlink" title="如何高效使用em呢"></a>如何高效使用em呢</h2></li><li>body里声明font-size:62.5%。即全局声明<code>1em = 16px * 62.5% = 10px</code></li><li>之后可以把<code>em</code>当做<code>px</code>使用。当然此时，<code>1em = 10px</code></li><li>如果在父容器里说明了<code>font-size:20px</code>,那么在子容器里的<code>1em</code>就等于<code>20px</code>。</li></ul><h1 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h1><p>rem单位是相对于字体大小的<strong>html元素</strong>，也称为根元素。</p><pre><code>html {  font-size: 10px; /* 不建议设置 font-size: 62.5%; 在 IE 9-11 上有偏差，具体表现为 1rem = 9.93px。 */}.sqaure {  width: 5rem;  /* 50px */  height: 5rem; /* 50px */}</code></pre><h1 id="em与rem"><a href="#em与rem" class="headerlink" title="em与rem"></a>em与rem</h1><ul><li>rem是相对于根元素（html）的字体大小，而em是相对于其父元素的字体大小。</li><li>em最多取到小数点的后三位<pre><code>&lt;style&gt;html{ font-size: 20px; }body{   font-size: 1.4rem;  /* 1rem = 28px */  padding: 0.7rem;  /* 0.7rem = 14px */} div{  padding: 1em;  /* 1em = 28px */}span{  font-size:1rem;  /* 1rem = 20px */  padding: 0.9em;  /* 1em = 18px */}&lt;/style&gt;</code></pre></li></ul><html>  <body>    <div>         <span></span>      </div>  </body></html>```上面的例子中，发现了一个有意思的情况。`em 会层层继承父元素的字体大小`，很容易造成字体大小的混乱。所以以后用`rem`会更好。<h1 id="rpx"><a href="#rpx" class="headerlink" title="rpx"></a>rpx</h1><p><strong>rpx 是微信小程序解决自适应屏幕尺寸的尺寸单位。微信小程序规定屏幕的宽度为750rpx。</strong></p><p>无论是在iPhone6上面还是其他机型上面都是750rpx的屏幕宽度，拿iPhone6来讲，屏幕宽度为375px，把它分为750rpx后， 1rpx = 0.5px = 1物理像素。</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/25/16c29bee71b0c4c4" alt=""></p><h1 id="vw-和-vh"><a href="#vw-和-vh" class="headerlink" title="vw 和 vh"></a>vw 和 vh</h1><ul><li><code>vw</code>,视窗宽度，1vw=视窗宽度的1%</li><li><code>vh</code>,视窗高度，1vh=视窗高度的1%</li><li>如果浏览器的高是900px,1vh求得的值为9px。同理，如果显示窗口宽度为750px,1vw求得的值为7.5px。</li></ul><h1 id="vmin-和-vmax"><a href="#vmin-和-vmax" class="headerlink" title="vmin 和 vmax"></a>vmin 和 vmax</h1><ul><li>vmin和vmax是相对于视口的高度和宽度两者之间的最小值或最大值。</li><li>浏览器的高为1100px、宽为700px，那么1vmin就是7px，1vmax就是11px</li><li>浏览器的高为800px，宽为1080px，那么1vmin也是8px，1vmax也是10.8px</li><li>vmin取宽度高度两者更小者/100</li><li>vmax取宽度高度两者更大者/100<h2 id="哪些地方可以用到"><a href="#哪些地方可以用到" class="headerlink" title="哪些地方可以用到"></a>哪些地方可以用到</h2></li><li>一个总是在屏幕上可见的元素。使用高度和宽度设置为低于100的vmin值将可以实现这个效果。</li><li>一个总是覆盖可视窗口的正方形(一直接触屏幕的四条边)<pre><code>.box {  height: 100vmax;  width: 100vmax;}</code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><a href="https://github.com/wujunchuan/wujunchuan.github.io/issues/15" target="_blank" rel="noopener">前端开发中像素的概念</a></li></ul><p><a href="http://www.360doc.com/content/19/0327/15/63018409_824523443.shtml" target="_blank" rel="noopener">最全的CSS尺寸单位介绍</a></p><p><a href="http://www.divcss5.com/css3-style/c33196.shtml" target="_blank" rel="noopener">CSS3中常见的单位</a><br><a href="http://www.mamicode.com/info-detail-2439333.html" target="_blank" rel="noopener">移动设备分辨率（终于弄懂了为什么移动端设计稿总是640px和750px）</a></p><p><a href="https://www.jianshu.com/p/e377208aaadd" target="_blank" rel="noopener">几个CSS的单位你需要了解一下</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack入门(3) - 核心内容</title>
      <link href="/2019/10/20/webpack-ru-men-3-he-xin-nei-rong/"/>
      <url>/2019/10/20/webpack-ru-men-3-he-xin-nei-rong/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5d19a847518825793f6fcd9f" target="_blank" rel="noopener">webpack入门(2)-安装，配置，环境</a>，上节传送门。</p><h1 id="Entry-入口"><a href="#Entry-入口" class="headerlink" title="Entry(入口)"></a>Entry(入口)</h1><p>简单提一下，Entry是webpack的入口文件，一开始运行webpack它会找到<code>webpack.config.js</code>里的<code>Entry</code>。它会从这开始着手，构建内部依赖图。入口点可以有一个或多个。</p><h2 id="entry的类型"><a href="#entry的类型" class="headerlink" title="entry的类型"></a>entry的类型</h2><ul><li>string类型<pre><code>一个入口entry:&#39;./src/main.js&#39;</code></pre></li><li>array类型<pre><code>配置了多个入口entry: [&#39;./src/main1.js&#39;, &#39;./src/main2.js&#39;]</code></pre></li><li>object类型<pre><code>对象类型entry: {  a: &#39;./src/main.js&#39;,  b: [&#39;./src/main1.js&#39;, &#39;./src/main2.js&#39;]}</code></pre></li><li>多个入口时，每个入口生成都会生成Chuck。</li><li>如果是array类型，则搭配output.library配置项使用时，只有数组里的最后一个入口文件会被导出。</li></ul><h2 id="配置动态Entry"><a href="#配置动态Entry" class="headerlink" title="配置动态Entry"></a>配置动态Entry</h2><p>假如项目里有多个页面需要为每个页面的入口配置一个entry，但这些页面数量可能会不断增长，这时entry的配置会受到其他因素的影响导致不能写成静态的值。解决办法就是把entry设置成一个函数去动态返回上面所说的配置：</p><pre><code>//同步函数entry: () =&gt; {    return {        a: &#39;./pages/a&#39;,        b: &#39;./pages/b&#39;    }}//异步函数entry: () =&gt; {    return new Promise((resolve) =&gt; {        resolve({            a: &#39;./pages/a&#39;,            b: &#39;./pages/b&#39;        })    })}</code></pre><h1 id="output"><a href="#output" class="headerlink" title="output"></a>output</h1><p>Output属性告诉webpack在哪里输出它所创建的bundles，也可指定bundles的名称，默认位置为./dist。整个应用结构都会被编译到指定的输出文件夹中去，你可以通过在配置中指定一个 output 字段，来配置这些处理过程。最基本的属性包括filename（文件名）和path（输出路径）。</p><h2 id="Chuck的名称"><a href="#Chuck的名称" class="headerlink" title="Chuck的名称"></a>Chuck的名称</h2><p>向上面的<code>main.js</code>中，<code>main</code>就是Chuck名称。<strong>Chunk的名称和Entry的配置有关。</strong></p><ul><li>如果entry是<code>string</code>类型或者是<code>array</code>类型，只会生成一个Chuck。</li><li>如果entry是一个<code>object</code>,就可能出现多个<code>chunk</code>,这时候的<code>chunk</code>值是<code>object</code>名称。比如上面的<code>a.js</code>,<code>b.js</code>。Chuck名称在<code>output</code>可以配置。<h2 id="多个入口时怎么配置filename"><a href="#多个入口时怎么配置filename" class="headerlink" title="多个入口时怎么配置filename"></a>多个入口时怎么配置filename</h2>当通过多个入口起点(entry point)、代码拆分(code splitting)或各种插件(plugin)创建多个 bundle的时候，可以有以下几种赋bundle名称的方式。</li><li>使用入口名称赋值,[name]为entry的key值,比如<code>a.bundle.js</code>,<code>b.bundle.js</code><pre><code>filename: &quot;[name].bundle.js&quot;</code></pre></li><li>使用内部 chunk id,从0开始<pre><code>filename: &quot;[id].bundle.js&quot;</code></pre></li><li>使用每次构建过程中，都会生成一段Hash值<pre><code>filename: &quot;[name].[hash].bundle.js&quot;</code></pre></li><li>使用基于每个 chunk 内容的 hash值，可以理解为版本号(Git里面的)或者md5值。<strong>文件内容发生改变，chunkhash就会改变。在这里可以用到：项目上线，只上线那些被改过的文件</strong><pre><code>filename: &quot;[chunkhash].bundle.js&quot;</code></pre><pre><code>取5位Hash值，默认为20位。filename: &quot;[chunkhash:5].bundle.js&quot;</code></pre><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2>output.path 配置输出文件存放在本地的目录，必须是 <code>string</code> 类型的<strong>绝对路径</strong>。通常通过 Node.js 的 path 模块去获取绝对路径：<pre><code>path: path.resolve(__dirname, &#39;dist_[hash]&#39;)</code></pre><code>__dirname</code>就是当前文件所在的文件夹的名字。<h2 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h2>对构建出的资源进行异步加载（图片，文件）。加载这些异步资源需要对应的 URL 地址。默认值是空字符串“ ”。<strong>简单说，就是静态文件托管在cdn上。</strong><br>如果你这么配置：<pre><code>output:{  filename:&#39;[name]_[chunkhash:8].js&#39;,  publicPath:&#39;https://www.qdtalk.com/assets/&#39;}</code></pre>打包编译之后，HTML页面就变成了这个：<pre><code>&lt;script src=&quot;https://www.qdtalk.com/assets/a_12345678.js&quot;&gt;&lt;/script&gt;</code></pre>上面只是举了output的几个常用参数。</li></ul><h1 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h1><p><code>Loader</code>在webpack中承担<strong>翻译</strong>的工作。<br>因为<code>webpack</code>自身只支持加载<code>js</code>和<code>json</code>文件，把源文件转化翻译后输出新结果，且一个文件还可以链式的经过<strong>多个翻译员翻译</strong>。</p><p>以处理SCSS文件为例：</p><ul><li><code>SCSS</code> 源代码会先交给 <code>sass-loader</code> 把 <code>SCSS</code> 转换成 <code>CSS</code>；</li><li>把 <code>sass-loader</code> 输出的 <code>CSS</code> 交给 <code>css-loader</code> 处理，找出 <code>CSS</code> 中依赖的资源、压缩 <code>CSS</code> 等；</li><li>把 <code>css-loader</code> 输出的 <code>CSS</code> 交给 <code>style-loader</code> 处理，转换成通过脚本加载的 JavaScript 代码。<h2 id="常用的Loader"><a href="#常用的Loader" class="headerlink" title="常用的Loader"></a>常用的Loader</h2></li><li>样式：<code>style-loader、css-loader、less-loader、sass-loader</code>等。</li><li>文件：<code>raw-loader、file-loader 、url-loader</code>等</li><li>编译：<code>babel-loader、coffee-loader 、ts-loader</code>等</li><li>校验测试：<code>mocha-loader、jshint-loader 、eslint-loader</code>等</li><li><code>vue-loader、coffee-loader、babel-loader</code>等可以将特定文件格式转成js模块、将其他语言转化为js语言和编译下一代js语言</li><li><code>file-loader、url-loader</code>等可以处理资源，<code>file-loader</code>可以复制和放置资源位置，并可以指定文件名模板，用hash命名更好利用缓存。</li><li><code>url-loader</code>可以将小于配置limit大小的文件转换成内敛Data Url的方式，减少请求。</li><li><code>raw-loader</code>可以将文件已字符串的形式返回</li><li><code>imports-loader、exports-loader</code>等可以向模块注入变量或者提供导出模块功能</li><li><code>expose-loader</code>:暴露对象为全局变量<h2 id="安装Loader"><a href="#安装Loader" class="headerlink" title="安装Loader"></a>安装Loader</h2>以安装css-loader和style.loader为例，直接在终端：<pre><code>npm install css-loader style-loader --save-dev</code></pre><h2 id="配置单个Loader"><a href="#配置单个Loader" class="headerlink" title="配置单个Loader"></a>配置单个Loader</h2><code>webpack.config.js</code>中<pre><code>module.exports = {  module: {      rules: [          {              test: /\.css$/,              use: &#39;css-loader&#39;          }      ]  }}</code></pre></li><li>test:后面接一个正则表达式，表示有那些后缀文件被处理。</li><li>use：表示应该用什么loader。</li></ul><h2 id="配置多个loader"><a href="#配置多个loader" class="headerlink" title="配置多个loader"></a>配置多个loader</h2><pre><code>module.exports = {    module: {        rules: [            {                test: /\.css$/,                use: [                    {                        loader: &#39;style-loader&#39;                    },                    {                        loader: &#39;css-loader&#39;                    }                ]            }        ]    }}</code></pre><h2 id="其他配置方法"><a href="#其他配置方法" class="headerlink" title="其他配置方法"></a>其他配置方法</h2><ul><li>直接在命令行<pre><code>webpack --module-bind &#39;txt=raw-loader&#39;</code></pre></li><li>内联<pre><code>import txt from &#39;raw-loader!./file.txt&#39;</code></pre>但这两种方法都不推荐。还是在<code>webpack.config.js</code>配参数更好。</li></ul><h2 id="几个重要的loader"><a href="#几个重要的loader" class="headerlink" title="几个重要的loader"></a>几个重要的loader</h2><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p><code>Babel</code> 可以让你使用<code>ES2015/16/17</code> 写代码而不用顾忌浏览器的问题，<code>Babel</code> 可以帮你转换代码。</p><ul><li>安装几个必要的<code>Babel</code>库,<pre><code>npm i --save-dev babel-loader babel-core babel-preset-env</code></pre>   babel-loader让webpack去处理一些使用了es6的js文件。<br>   babel-core 提供一系列API，其实是让babel-loader去调用babel-core的API。<br>   babel-preset-env 这个库可以根据环境的不同转换代码</li><li>配置babel规则。在<code>package.json</code>里面增加一个<code>babel属性</code>。作用是设置项目中的babel转码规则和使用到的babel插件，格式如下：<pre><code>&quot;babel&quot;:{&quot;presets&quot;: [&quot;evn&quot;],//设定转码规则&quot;plugins&quot;: []//要用到的插件}</code></pre>表示告诉npm，在本项目中将使用babel，并且使用<code>babel-preset-env</code>规则进行转码。</li><li>除了上一种写法外，还有另外一种方法(<strong>推荐写法</strong>)。在根目录下面新建<code>.babelrc</code>文件，然后做一下配置：<pre><code>{&quot;presets&quot;: [&quot;babel-preset-env&quot;]}</code></pre></li></ul><pre><code>- 上面已经配置好`babel`的规则，但是`webpack`依然不知道何时使用该规则。我们还要再接着在配置里写入</code></pre><p>use: ‘babel-loader’</p><pre><code>**但要注意的是**，只有`js`文件才可以使用`babel`。### 处理图片- `npm i --save-dev url-loader file-loader`- 在`webpack.config.js`里面修改配置：</code></pre><p>test: /.(png|jpe?g|gif|svg)(?.*)?$/,<br>use : [<br>  {<br>     loader: ‘url-loader’,<br>     options: {<br>      // 限制 图片大小 10000B，小于限制会将图片转换为 base64格式<br>         limit: 10000,<br>      // 超出限制，创建的文件格式<br>      // build/images/[图片名].[hash].[图片格式]<br>         name: ‘images/[name].[hash].[ext]’<br>    }<br>  }<br>]</p><pre><code># Plugins(插件)插件用来拓展webpack功能，可以用于执行范围更广的任务，包括**打包、优化、压缩、搭建服务器**等等，功能十分强大。**要是用一个插件，一般是先使用npm包管理器进行安装，然后在配置文件webpack.config.js中require引入，最后在这个文件下使用new来创建一个实例。**   Loader一次只能处理单个相同类型的文件，但是plugins可以对整个过程起作用。## 常用的plugin插件- webpack内置`UglifyJsPlugin`插件，压缩和混淆代码。- webpack内置`CommonsChunkPlugin`，提高打包效率，将第三方库和业务代码分开打包- `ProvidePlugin`：自动加载模块，代替`require`和`import`- `html-webpack-plugin`可以根据模板自动生成html代码，并自动引用css和js文件- `extract-text-webpack-plugin` 将js文件中引用的样式单独抽离成css文件- `DefinePlugin` 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。- `HotModuleReplacementPlugin `热更新- `optimize-css-assets-webpack-plugin` 不同组件中重复的css可以快速去重- `webpack-bundle-analyzer` 一个webpack的bundle文件分析工具，将bundle文件以可交互缩放的treemap的形式展示- `compression-webpack-plugin` 生产环境可采用gzip压缩JS和CSS- `happypack`：通过多进程模型，来加速代码构建## 一个简单的插件使用- `npm install --save-dev html-webpack-plugin`安装一个插件。有的插件webpack自带，如果没有，则需用npm安装。- `const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);`在webpack.config.js中引入。- new一个实例</code></pre><p>plugins: [</p><p>  new HtmlWebpackPlugin({<br>  template: ‘./src/index.html’, //以src目录下的index.html文件为模板生成html5新文件<br>  filename: ‘index.html’,//指定生成的HTML文件叫啥名<br>  inject: ‘head’,//指定把脚本script标签放在那里，这里放在<head>标签里。还可以放<body><br>  })<br>]</p><pre><code>## 利用html-webpack-plugin插件自动生成html文件### 为什么要自动生成HTML每次执行webpack打包生成js文件后，都必须在index.html中手动插入打包好的文件的路径。**但在真实生产环境中，一次运行webpack后，完整的index.html应该是被自动生成的。** 例如静态资源、js 脚本都被自动插入了。### 根目录下的index.html文件根目录下的index.html会被html-webpack-plugin作为最终生成的 html 文件的模板。打包后，相关引用关系和文件路径都会按照正确的配置被添加进去。### 配置</code></pre><p>const HtmlWebpackPlugin = require(“html-webpack-plugin”);</p><p>module.exports = {<br> entry: {<br>    app: “./src/app.js”<br>  },<br>  output: {<br>    publicPath: <strong>dirname + “/dist/“,<br>    path: path.resolve(</strong>dirname, “dist”),<br>  },<br>    plugins: [<br>    new HtmlWebpackPlugin({<br>      filename: “index.html”,<br>      template: “./index.html”,<br>      chunks: [“app”], // entry中的app入口才会被打包<br>      minify: {<br>        // 压缩选项<br>        collapseWhitespace: true<br>      }<br>    })<br>  ]<br>}</p><pre><code>最后执行打包命令，然后在dist目录下就给你自动生成了index.html文件。dist目录下的index.html文件是以根目录下的inde.html文件为模板的。# 其他几个核心概念## Module(模块)对于webpack，模块不仅仅是javascript模块，它包括了任何类型的源文件，不管是图片、字体、json文件都是一个个模块。**Webpack支持以下的方式引用模块：**- ES2015 import 方法- CommonJs require() 方法- AMD define 和 require 语法- css/sass/less文件中的 @import 语法- url(...)和 &lt;img src=&quot;&quot;&gt;的图片路径## Dependency Graph（依赖关系图）所谓的依赖关系图是webpack根据每个模块之间的依赖关系递归生成的一张内部逻辑图，有了这张依赖关系图，webpack就能按图索骥把所有需要模块打包成一个bundle文件了。## Mode(模式)分为开发模式`development`和生产模式`production` 。两种模式的区别在于一个是为生产环境编译打包，一个是为了开发环境编译打包。生产环境模式下，webpack会自动对代码进行压缩等优化，省去了配置的麻烦。## 结语webpack断断续续终于算是入门了。与其他技能点相比，webpack算是比较酸涩难懂。但是学无止境，我学webpack的还有很长的路要走。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack入门(2) - 安装，配置，环境搭建</title>
      <link href="/2019/10/20/webpack-ru-men-2-an-zhuang-pei-zhi-huan-jing-da-jian/"/>
      <url>/2019/10/20/webpack-ru-men-2-an-zhuang-pei-zhi-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5d1867c76fb9a07eec59dfa6" target="_blank" rel="noopener">webpack入门(1)-“图解什么是webpack”</a>传送门</p><h1 id="初始化和安装"><a href="#初始化和安装" class="headerlink" title="初始化和安装"></a>初始化和安装</h1><ul><li>在工作目录新建一个文件夹</li><li><code>npm init</code> 初始化一个文件夹,出现对话框按确定就行。</li><li><code>npm install --global webpack</code> 全局安装，在c盘下会生成node_modules文件夹中会包含webpack。<code>请注意，这不是推荐的做法。全局安装会将您锁定到特定版本的webpack，并且在使用不同版本的项目中可能会失败。</code>官方并不推荐全局安装。</li><li><code>npm install --save-dev webpack</code> 安装在本地开发环境中</li><li><code>npm install --save-dev webpack-cli</code> webpack4之后要安装cli。把cli安装到开发环境中。</li><li><code>-D</code>就是<code>--save-dev</code>的缩写</li></ul><h1 id="打包一个简单的文件"><a href="#打包一个简单的文件" class="headerlink" title="打包一个简单的文件"></a>打包一个简单的文件</h1><ul><li>在文件夹下新建一个<code>src</code>文件,下面新建一个<code>main.js</code>文件。</li><li>根目录下新建一个<code>webpack.config.js</code>文件。为什么要建这个文件，因为直接使用<code>webpack</code>，它会寻找<code>webpack.config.js</code>把它当成默认的配置去运行。此时它不需要指定任何参数，就能读取里面的内容。<pre><code>// webpack.config.jsmodule.exports = {  entry: __dirname + &#39;/src/main.js&#39;,//我指定了入口文件，在src/main.js  output: {       path: __dirname + &#39;/dist&#39;, //打包后指定存放的目录,放在dist      filename: &#39;bundle.js&#39; //打包后的文件叫bundle.js  }}</code></pre></li></ul><blockquote><p>__dirname是Node.js中一个全局变量，它指向当前执行脚本所在的目录。<br>有多个入口文件的时候：<br><img src="https://user-gold-cdn.xitu.io/2019/7/3/16bb7d1cd83ec193?w=965&h=626&f=png&s=77448" alt=""></p></blockquote><ul><li>如果你一开始你就不想运行默认的<code>webpack.config.js</code>,你想运行其他的配置文件,比如<code>config.js</code>文件。你可以运行<code>webpack --config config.js</code>,这样它就会寻找<code>config.js</code>，并且运行它。</li><li>运行<code>webpack</code>，它会自动的寻找<code>webpack.config.js</code>，找到其中的入口文件比如上面的<code>main.js</code>。</li><li>如果你想有些个性化的需求，你想看到打包的进度，打包的模块，模块的信息，打包的原因。你可以输入以下的命令。<ul><li><code>webpack --progress</code>可以看到打包的进度。</li><li><code>webpack --progress --display-modules</code> 可以看到打包有几个模块，模块的信息。</li><li><code>webpack ---progress --display-modules --display-reasons</code> 打包的原因显示出来。</li></ul></li><li>但是这种方法太过繁琐，你要在命令行输入这么多东西。那么有没有更轻松的方法呢？<strong>有的！</strong><ul><li>在你初始化的时候，系统会自动生成<code>package.json</code>。现在找到根目录下的<code>package.json</code>文件。<br><img src="https://user-gold-cdn.xitu.io/2019/7/1/16bad8c1ca6b5add?w=514&h=294&f=png&s=18781" alt=""></li><li>在里面的<code>scripts</code>下添加定义一个脚本，<pre><code>&quot;dev&quot;:&quot;webpack --config webpack.config.js --progress --display-modules --colors --display-reasons&quot;</code></pre></li><li>最后在命令行运行<code>npm run dev</code></li></ul>  <strong>因为scripts脚本提供了命令的“别名”，像上面的以一个“dev”命令代替了一连串的命令，使用起来更为方便</strong>,即便你没有在命令行输入以上的配置，你依然可以看到打包的进度；以看到打包有几个模块，模块的信息；字体为彩色；打包的原因。因为你在配置文件下定义了，就不需要了。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/7/3/16bb5173b3f3e78e?w=578&h=714&f=png&s=97412" alt=""></p><h1 id="更快捷的执行打包任务"><a href="#更快捷的执行打包任务" class="headerlink" title="更快捷的执行打包任务"></a>更快捷的执行打包任务</h1><ul><li>最原始的执行打包任务，可以使用命令<code>webpack main.js bundle.js</code>在这个例子当中，<code>main.js</code>是入口文件，<code>bundle.js</code> 打包完之后的文件。</li><li>第二种，我们可以在<code>webpack.config.js</code>里写配置。<pre><code>module.exports = {entry:  __dirname + &quot;/app/main.js&quot;,//唯一入口文件output: {  path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方  filename: &quot;bundle.js&quot;//打包后输出文件的文件名}}</code></pre>我们只需要输入<code>webpack</code>命令，webpack就能自己找到<code>webpack.config.js</code>，在找出入口，找到output,执行打包。</li><li>第三种，继承第二种。更简单快捷的执行打包。在<code>package.json</code>里找到“scripts”脚本，添加<pre><code>&quot;start&quot;: &quot;webpack --config webpack.config.js --progress --display-modules --colors --display-reasons&quot;</code></pre>然后我们只需要<code>npm start</code>就可以打包了。<pre class=" language-!"><code class="language-!">需要注意的是,“start”在npm中比较特殊，只需npm start 就可以执行命令。如果是非start,还要再在前面加上一个run ,比如npm run dev,npm run build</code></pre></li></ul><h1 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h1><h2 id="使用source-maps进行调试调试"><a href="#使用source-maps进行调试调试" class="headerlink" title="使用source maps进行调试调试"></a>使用source maps进行调试调试</h2><h3 id="为何要使用source-maps？"><a href="#为何要使用source-maps？" class="headerlink" title="为何要使用source maps？"></a>为何要使用source maps？</h3><p>因为<code>webpack</code>对源代码进行打包后，会对源代码进行压缩、精简、甚至变量名替换，在浏览器中，无法对代码逐行打断点进行调试，所有需要使用<code>source maps</code>进行调试，它使得我们在浏览器中可以看到源代码，进而逐行打断点调试。</p><h3 id="如何使用source-maps？"><a href="#如何使用source-maps？" class="headerlink" title="如何使用source maps？"></a>如何使用source maps？</h3><p>在配置中添加<code>devtool</code>属性，赋值为<code>source-map</code>或者<code>inline-source-map</code>即可，后者报错信息更加具体，会指示源代码中的具体错误位置，而<code>source-map</code>选项无法指示到源代码中的具体位置。</p><h2 id="使用开发工具"><a href="#使用开发工具" class="headerlink" title="使用开发工具"></a>使用开发工具</h2><p>用开发工具可以简化开发过程的工作。比如你写完代码后保存开发工具可以自动帮你执行一系列的命令。</p><h3 id="watch模式"><a href="#watch模式" class="headerlink" title="watch模式"></a>watch模式</h3><p>在使用<code>webpack-cli</code>进行打包时，通过命令<code>webpack --watch</code>即可开启<code>watch</code>模式，进入<code>watch</code>模式之后，一旦依赖树中的某一个模块发生了变化，<code>webpack</code>就会重新进行编译。</p><h3 id="使用webpack-dev-server"><a href="#使用webpack-dev-server" class="headerlink" title="使用webpack-dev-server"></a>使用webpack-dev-server</h3><p>浏览器监听你的代码的修改，并自动刷新显示修改后的结果。它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖。</p><ul><li>安装。<code>npm install --save-dev webpack-dev-server</code></li><li>修改配置文件，添加<code>devServer</code>属性<pre><code>// webpack.config.jsmodule.exports = {    devServer: {        contentBase: &#39;./dist&#39;,//本地服务器所加载的页面所在目录        historyApiFallback: true,//不跳转        inline: true //实时刷新    }};</code></pre></li><li>在<code>package.json</code> 添加脚本<pre><code>// package.json{    &quot;scripts&quot;: {        &quot;start&quot;: &quot;webpack-dev-server --open&quot;    }}</code></pre></li><li>运行命令<br><code>npm run start</code>即可在本地的8080端口查看结果。</li><li>搭建开发环境远不止这些内容，我只挑了我在学习过程中经常用到的地方，或者我觉得重要的地方。</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>webpack很难啃，我是在网上找资料看视频，一点一点摸索。网上的资料时间维度大，有的还在讲webpack1.0,有的在讲最新版的webpack,<strong>所以在整理的时候难免有出错的地方。欢迎在下方评论指出错误！</strong>  </p><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack入门(1) - 图解Webpack是什么</title>
      <link href="/2019/10/20/webpack-ru-men-1-tu-jie-webpack-shi-shi-me/"/>
      <url>/2019/10/20/webpack-ru-men-1-tu-jie-webpack-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>毫无疑问，Webpack在前端中有着独特的重要性，是你必须要熟悉的一个技能点。因为你在投简历浏览一些大公司的<strong>前端岗位</strong>时，Webpack毫无疑问是写明了至少要是<strong>熟悉Webpack</strong>。我在学Webpack期间，常常被它的配置，环境给绕晕了,现在重新开始学一遍，希望我可以掌握它。本着分享学习的态度，记录下我学习的过程，希望可以对一些初学Webpack的同学提供一点帮助。</p><h1 id="Webpack使用原因和定义"><a href="#Webpack使用原因和定义" class="headerlink" title="Webpack使用原因和定义"></a>Webpack使用原因和定义</h1><p>我相信很多刚开始学<code>Webpack</code>的同学在学之前一定疯狂的在各大论坛或者百度搜索“什么是<code>Webpack</code>”，因为我就是这么干的。但是一些大牛的文章在提及什么是<code>Webpack</code>的时候总是一笔带过，看完之后也是云里雾里，迷迷糊糊。现在我用自己的语言来解释什么是<code>Webpack</code>。在此之前，还要向大家解释为什么要使用<code>Webpack</code>:</p><h2 id="为什么要使用Webpack"><a href="#为什么要使用Webpack" class="headerlink" title="为什么要使用Webpack"></a>为什么要使用Webpack</h2><p>我们都知道一个大公司的网站往往做的都很炫酷，美观，功能很齐全。在这背后前端工程师花了很大的精力去做优化什么的。大型网站和大型项目中的背后都拥有着复杂的JS代码和很多依赖。<strong>为了简化开发的复杂度，往往对程序切割分裂为不同的模块。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/6/30/16ba776df3057afd?w=390&h=486&f=png&s=22381" alt=""><br>如图所示，把大型项目切割成很多不同的模块。那么，里面的箭头是怎么回事，我觉得可以理解为<code>require</code>。因为两个文件之间相互通联是靠<code>require</code>连接的。好比如，<code>html</code>文件利用<code>link</code>中引入样式一样。<code>webpack</code>整合了项目里的模块打包的更为精简。所以我们需要<code>webpack</code>。</p><ul><li>Webpack分析大型项目的结构</li><li>找到JS模块以及浏览器不能直接运行的模块(cjs,Sass,hbs等等)</li><li>将浏览器不能直接处理的文件转换和打包为合适的格式供浏览器直接处理。</li><li>这样前端工程师既可以更轻松系统的开发，浏览器也能更高效流畅的运行。</li></ul><h2 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/30/16ba78866fc440b7?w=1284&h=566&f=png&s=65325" alt=""><br>上面已经提到了<code>Webpack</code>的工作流程，我在举一个<strong>不怎么严谨</strong>的例子你们也许就能明白。<br><code>假如你去饭店吃饭，点完菜后你觉得把菜打包回寝室吃更爽一些。你点了很多菜，这些菜有麻辣的，酸辣的，甜的，还有水果，小糕点不同的口味。考虑到你的室友有的喜欢吃辣的，有的喜欢吃甜的，有的喜欢吃水果。如果全部的菜混在一起可能室友都不喜欢，你决定不混在一起，而是按照口味混在一起。把辣的菜混到一起，把甜的菜混到一起，把水果混到一起。这样你的室友就能够接受了。</code></p><p><img src="https://user-gold-cdn.xitu.io/2019/7/1/16bab1b71034272a?w=1097&h=606&f=png&s=70391" alt=""></p><p><code>结合上面webpack的工作流程，可以这样说：webpack分析大型项目的结构即分析这些菜是哪些口味；找到浏览器不能直接运行的模块，即分析哪些是你室友不能接受的口味；将浏览器不能直接处理的文件转换和打包为合适的格式供浏览器处理即将菜分类打包让你的室友可以接受。</code><br>结合上面的图，应该把<code>Webpack</code>的运行流程搞清楚了。</p><h1 id="webpack工作流程"><a href="#webpack工作流程" class="headerlink" title="webpack工作流程"></a>webpack工作流程</h1><p>用文字叙述不直观，我尽量用图形的方式来说明。首先先说明依赖就是本文第一张图里面的箭头。<br><img src="https://user-gold-cdn.xitu.io/2019/7/1/16bab14c0a750e74?w=570&h=796&f=png&s=82861" alt=""></p><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员都要掌握的Git</title>
      <link href="/2019/10/20/cheng-xu-yuan-du-yao-zhang-wo-de-git/"/>
      <url>/2019/10/20/cheng-xu-yuan-du-yao-zhang-wo-de-git/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是参考廖雪峰老师的Git资料再加上我自己对Git的理解，记录我的Git学习历程，作下此文是为以后学习，工作，开发中如果遇到问题可以回过头来参考参考。因为水平有限，难免会有出错的地方，欢迎指正。</p><h1 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h1><ul><li>官方话：Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。</li><li>引用廖雪峰老师的话，它能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以。</li></ul><h1 id="为什么要学习Git"><a href="#为什么要学习Git" class="headerlink" title="为什么要学习Git"></a>为什么要学习Git</h1><ul><li>面试要被问。可以应付面试。</li><li>很多公司开发都用Git来处理项目。现在不学，以后肯定还要学。</li><li>在我看来Git是现如今所有程序员都要掌握的，以后与同事共同开发项目必定要用到的，熟练掌握Git命令，可以提高开发的效率。。</li></ul><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><ul><li>Windows<br>直接在官网上去下载。下载完成后，随便在某个文件下右键如果有Git Bash Here就安装成功。安装后，还要在命令行输入<pre><code>$git config --global user.name &quot;你的名字&quot;$git config --global user.email &quot;你的邮箱&quot;</code></pre><code>global</code>表示全局，这台机器所有的Git仓库都会使用这个配置。允许单个仓库使用其他的名字和邮箱。</li><li>Mac<br>评论区指出Mac也可以像Windows一样，按上面的步骤安装。<br>也可以直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</li></ul><h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9d385970c7b6c?w=987&h=495&f=png&s=247329" alt=""></p><ul><li>本地仓库是对于远程仓库而言的。</li><li>本地仓库 = 工作区 + 版本区</li><li>工作区即磁盘上的文件集合。</li><li>版本区(版本库)即<code>.git</code>文件</li><li>版本库 = 暂存区(stage) + 分支(master) + 指针Head  <ul><li>以我使用最频繁的git命令为例，即提交到github为例。</li><li><code>git init</code> 原本本地仓库只包含着工作区，这是最常见的工作状态。此时，<code>git init</code>一下，表示在本地区域创建了一个<code>.git</code>文件,版本区建立。</li><li><code>git add .</code> 表示把工作区的所有文件全部提交到版本区里面的<strong>暂存区</strong></li><li>当然你也可以通过 <code>git add ./xxx/</code> 一条一条分批添加到暂存区。</li><li><code>git commit -m &quot;xxx&quot;</code> 把暂存区的<strong>所有</strong>文件提交到仓库区，暂存区空空荡荡。</li><li><code>git remote add origin https://github.com/name/name_cangku.git</code> 把本地仓库与远程仓库连接起来。</li><li><code>git push -u origin master</code> 把仓库区的文件提交到远程仓库里。</li><li>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。会有这样的信息<code>nothing to commit, working tree clean</code></li></ul></li></ul><h1 id="提交到GitHub"><a href="#提交到GitHub" class="headerlink" title="提交到GitHub"></a>提交到GitHub</h1><p>以前不熟悉git命令的时候，我提交项目到github上都是直接在网页上直接拉取文件提交上去的。有点羞耻。<br><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9c23ee01835ce?w=1501&h=643&f=png&s=101230" alt=""></p><ol><li><code>git init</code> .初始化，表示把这个文件变成Git可以管理的仓库。初始化后打开隐藏的文件可以看到有一个<code>.git</code>文件。</li><li><code>git add .</code> 后面的一个点表示把这个文件全部提交到暂存区。</li><li><code>git add ./readme.md/</code> 表示把这个文件下面的readme.md文件提交到暂存区。</li><li><code>git commit -m &quot;你要评论一点什么东西&quot;</code> <code>git  commit</code>的意思是把暂存区的全部文件提交到本地仓库。<code>-m</code>后接评论。</li><li><code>git remote add origin https://github.com/name/name_cangku.git</code>表示把你本地的仓库与GitHub上的远程仓库连接起来。只需要连接一次，以后提交的时候就可以不用谢这条命令了。<code>name</code>是你的github名字，<code>name_cangku</code>是你的仓库名。<strong>注意</strong>不要把后面的<code>.git</code>给漏掉了。因为我前面就是这么走过来的，绕了很多弯路。至于如何在GitHub上新建仓库，网上有很多教程，这里不再赘述了。</li><li><code>git push -u origin master</code> 把本地仓库提交到远程仓库。(最后一步)在你的远程仓库上刷新一下就可以看到你提交的文件了。</li><li>最后提到的是，在<code>git commit -m &quot;&quot;</code>之前，可以重复<code>git add</code>到暂存区。但是<code>git commit</code>会把你之前存放在暂存区的全部文件<strong>一次性</strong>全部提交到本地仓库。<h1 id="版本的回溯与前进"><a href="#版本的回溯与前进" class="headerlink" title="版本的回溯与前进"></a>版本的回溯与前进</h1>提交一个文件，有时候我们会提交很多次，在提交历史中，这样就产生了不同的版本。每次提交，Git会把他们串成一条时间线。如何回溯到我们提交的上一个版本，用<code>git reset --hard + 版本号</code>即可。 版本号可以用<code>git log</code>来查看，每一次的版本都会产生不一样的版本号。回溯之后，<code>git log</code>查看一下发现离我们最近的那个版本已经不见了。但是我还想要前进到最近的版本应该如何？只要<code>git reset --hard + 版本号</code>就行。退一步来讲，虽然我们可以通过<code>git reset --hard + 版本号</code>,靠记住版本号来可以在不同的版本之间来回穿梭。<strong>但是</strong>,有时候把版本号弄丢了怎么办？<code>git reflog</code>帮你记录了每一次的命令，这样就可以找到版本号了，这样你又可以通过<code>git reset</code>来版本穿梭了。<h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1></li></ol><ul><li>场景1：在工作区时，你修改了一个东西，你想撤销修改，<code>git checkout -- file</code>。廖雪峰老师指出撤销修改就回到和版本库一模一样的状态，即用版本库里的版本替换工作区的版本。 </li><li>场景2：你修改了一个内容，并且已经<code>git add</code>到暂存区了。想撤销怎么办？回溯版本，<code>git reset --hard + 版本号</code>,再<code>git checkout -- file</code>,替换工作区的版本。</li><li>场景3：你修改了一个内容，并且已经<code>git commit</code>到了<code>master</code>。跟场景2一样，版本回溯，再进行撤销。<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1></li><li>如果你<code>git add</code>一个文件到暂存区，然后在工作区又把文件删除了，Git会知道你删除了文件。如果你要把版本库里的文件删除，<code>git rm</code> 并且<code>git commit -m &quot;xxx&quot;</code>.</li><li>如果你误删了工作区的文件，怎么办？使用撤销命令，<code>git checkout --&lt;file&gt;</code>就可以。<strong>这再次证明了撤销命令其实就是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</strong><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1>分支，就像平行宇宙，廖雪峰老师如是说。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9e012079c4724?w=553&h=291&f=png&s=11351" alt=""><br>在没有其他分支插进来时，只有一个master主分支。每次你<code>git push -u origin master</code> 提交就是增加一条时间轴，master也会跟着移动。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9e11b1115072b?w=640&h=355&f=png&s=14404" alt=""><br>创建一个other的分支，通过other提交，虽然时间轴向前走了，但是主分支master还在原来的位置。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9e1ce1d3c3b03?w=675&h=359&f=png&s=16995" alt=""></p><p>理论分析完，看一下命令怎么写。</p><ul><li>创建分支<code>other</code>,切换到<code>other</code>分支。<pre><code>git branch othergit checkout other</code></pre></li><li>查看当前所有分支<pre><code>git branch</code></pre>```</li></ul><ul><li>other<br>master<br>```<br>当前的分支会有一个<code>*</code></li></ul><ul><li>用<code>other</code>提交<pre><code>git add ./xxx/git commit -m &quot;xxx&quot;</code></pre></li><li><code>other</code>分支完成，切换回<code>master</code><pre><code>git checkout master</code></pre></li><li>此时，master分支上并没有<code>other</code>的文件，因为分支还没有合并。</li><li><strong>合并分支</strong><pre><code>git merge other</code></pre></li><li>合并完成之后，就可以在master分支上查看到文件了。</li><li>删除<code>other</code>分支。<pre><code>git branch -d other</code></pre></li><li>我由此想到，在以后工作中，应该是一个开放小组共同开发一个项目，组长会创建很多分支，每一个分支可以交给一个人去开发某一个功能，一个小组共同开发而且不会相互干扰。谁的功能完成了，可以由组长合并一下完成了的分支。哦，完美！<h2 id="解决合并分支问题"><a href="#解决合并分支问题" class="headerlink" title="解决合并分支问题"></a>解决合并分支问题</h2></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/6/29/16ba102bd434afc6?w=610&h=393&f=png&s=17724" alt=""><br>假如有这样一种情况，分支<code>other</code>已经<code>commit</code>了，<strong>但是</strong>此时指针指回<code>master</code>时，并且<code>master</code>没有合并，而是<code>git add / commit</code> 提交了。这样，就产生了冲突，主分支<code>master</code>文件内容与<code>other</code>分支的内容不一样。合并不起来！所以，</p><ul><li>修改文件的内容，让其保持一致。</li><li><code>git add</code> <code>git commit</code> 提交。</li><li>分支合并了。<br><img src="https://user-gold-cdn.xitu.io/2019/6/29/16ba11a0ba73803d?w=658&h=349&f=png&s=21326" alt=""></li><li><code>git log --graph</code> 查看分支合并图</li><li><code>git branch -d other</code> 删除分支，任务结束。<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2></li><li><code>git merge --no-ff other</code> 禁用<code>Fast forward</code>模式，因为使用<code>Fast forward</code>模式，删除分支后，分支历史信息会丢失。</li></ul><h2 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h2><blockquote><p>廖雪峰老师提到，工作中每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。但如果你手上有分支在工作中，你的上级要你改另外的分支的BUG。你要把现在正在工作的分支保存下来，<code>git stash</code>,把当前工作现场“存储”起来，等以后恢复后继续工作。当你解决BUG后，<code>git checkout other</code>回到自己的分支。用<code>git stash list</code>查看你刚刚“存放”起来的工作去哪里了。此时你要恢复工作：</p></blockquote><ul><li><code>git stash apply</code>恢复却不删除<code>stash</code>内容，<code>git stash drop</code>删除<code>stash</code>内容。</li><li><code>git stash pop</code>恢复的同时把stash内容也删了.</li><li>此时，用<code>git stash list</code>查看，看不到任何<code>stash</code> 内容。  </li></ul><p><strong>总结：修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场</strong></p><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><ul><li><p><code>git branch -d + 分支</code>有可能会删除失败，因为Git会保护没有被合并的分支。</p></li><li><p><code>git branch -D + 分支</code> 强行删除，丢弃没被合并的分支。</p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2></li><li><p><code>git remote</code> 查看远程库的信息，会显示<code>origin</code>，远程仓库默认名称为<code>origin</code></p></li><li><p><code>git remote -v</code>显示更详细的信息 </p></li><li><p><code>git push -u origin master</code>推送<code>master</code>分支到<code>origin</code>远程仓库。</p></li><li><p><code>git push -u origin other</code> 推送<code>other</code>到<code>origin</code>远程仓库。</p><h2 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/29/16ba20c43f386f7c?w=520&h=313&f=png&s=12170" alt=""><br>产生上图的冲突时，</p></li><li><p><code>git pull</code> 把最新的提交从远程仓库中抓取下来，在本地合并，解决冲突。在进行<code>git pull</code></p></li><li><p>如果<code>git pull</code> 也失败了，还要指定分支之间的链接，这一步Git会提醒你怎么做。然后再<code>git pull</code>。              </p><blockquote><p><strong>廖雪峰老师的总结：多人协作的工作模式通常是这样：</strong></p></blockquote><ul><li><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p></li><li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code> 推送就能成功！</p></li><li><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><h2 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h2></li></ul></li><li><p><code>git rebase</code> 把分叉的提交历史“整理”成一条直线，看上去更直观.缺点是本地的分叉提交已经被修改过了。</p></li><li><p>最后在进行<code>git push -u origin master</code></p></li><li><p><code>rebase</code>的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><blockquote><p>比如一个APP要上线，通常在版本库中打一个标签(tag),<br>这样，就确定了打标签的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针。<br><code>tag</code>其实就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。比如<code>tag v2.1</code>就是把历史上的一个版本的东西叫做<code>v2.1</code></p></blockquote><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>步骤：</p></li><li><p><code>git branch</code>查看当前分支,<code>git checkout master</code>切换到<code>master</code>分支。</p></li><li><p><code>git tag &lt;name&gt;</code> 打标签，默认为<code>HEAD</code>。比如<code>git tag v1.0</code></p></li><li><p>默认标签是打在最新提交的<code>commit</code>上的。如果想要打标签在以前的<code>commit</code>上，要<code>git log</code>找到历史提交的<code>commit</code> id.</p></li><li><p>如果一个<code>commt id</code>是<code>du2n2d9</code>,执行<code>git tag v1.0 du2n2d9</code>就把这个版本打上了<code>v1.0</code>的标签了。</p></li><li><p><code>git tag</code> 查看所有标签，可以知道历史版本的<code>tag</code></p></li><li><p>标签不是按时间顺序列出，而是按字母排序的。</p></li><li><p><code>git show &lt;tagname&gt;</code> 查看标签信息。</p></li><li><p><code>git tag -a &lt;标签名&gt; -m &quot;&lt;说明&gt;&quot;</code>,创建带说明的标签。 <code>-a</code>指定标签名，<code>-m</code>指定说明文字。用<code>show</code>可以查看说明。</p><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2></li><li><p><code>git tag -d v1.0</code> 删除标签。因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p></li><li><p><code>git push origin &lt;tagname&gt;</code> 推送某个标签到远程</p></li><li><p><code>git push origin --tags</code> 一次性推送全部尚未推送到远程的本地标签</p></li><li><p>如果标签推送到远程。<code>git tag -d v1.0</code> 先删除本地标签v1.0。<code>git push origin :refs/tags/v1.0</code>删除远程标签v1.0</p></li></ul><h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><ul><li><code>git config --global color.ui true</code>让Git显示颜色，会让命令输出看起来更醒目</li><li>忽略特殊文件<br>创建一个<code>.gitignore</code>文件，把需要忽略的文件名填进去。Git就会自动忽略这些文件。我也在学习中遇到过这样的问题，比如<code>node_modules</code>文件就可以忽略。</li><li><blockquote><p>忽略文件原则：忽略操作系统自动生成的文件，比如缩略图等；<br>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；<br>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</p></blockquote></li><li>强制提交已忽略的的文件。<code>git add -f &lt;file&gt;</code></li><li><code>git check-ignore -v &lt;file&gt;</code>检查为什么Git会忽略该文件。</li><li><strong>给Git命令配别名</strong>,这个有点骚，就是你以后想输入<code>git rebase</code>时,你给它一个“外号”，就叫它<code>git nb</code>。以后你可以通过<code>git nb</code>来代替<code>git rebase</code>。具体怎么转换可以去<a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732837407424" target="_blank" rel="noopener">廖雪峰老师的网站</a>看。因为水平有限，我觉得先把正常的Git命令搞清楚来就很不错了。<h1 id="常用Git命令总结"><a href="#常用Git命令总结" class="headerlink" title="常用Git命令总结"></a>常用Git命令总结</h1></li><li><code>git config --global user.name &quot;你的名字&quot;</code> 让你全部的<code>Git</code>仓库绑定你的名字</li><li><code>git config --global user.email &quot;你的邮箱&quot;</code> 让你全部的<code>Git</code>仓库绑定你的邮箱</li><li><code>git init</code> 初始化你的仓库</li><li><code>git add .</code> 把工作区的文件全部提交到暂存区</li><li><code>git add ./&lt;file&gt;/</code> 把工作区的<code>&lt;file&gt;</code>文件提交到暂存区</li><li><code>git commit -m &quot;xxx&quot;</code> 把暂存区的所有文件提交到仓库区，<strong>暂存区空空荡荡</strong></li><li><code>git remote add origin https://github.com/name/name_cangku.git</code> 把本地仓库与远程仓库连接起来</li><li><code>git push -u origin master</code> 把仓库区的主分支<code>master</code>提交到远程仓库里</li><li><code>git push -u origin &lt;其他分支&gt;</code> 把其他分支提交到远程仓库</li><li><code>git status</code>查看当前仓库的状态</li><li><code>git diff</code> 查看文件修改的具体内容</li><li><code>git log</code> 显示从最近到最远的提交历史</li><li><code>git clone + 仓库地址</code>下载克隆文件</li><li><code>git reset --hard + 版本号</code> 回溯版本，版本号在<code>commit</code>的时候与<code>master</code>跟随在一起</li><li><code>git reflog</code> 显示命令历史</li><li><code>git checkout -- &lt;file&gt;</code> 撤销命令，用版本库里的文件替换掉工作区的文件。我觉得就像是<code>Git</code>世界的<code>ctrl + z</code></li><li><code>git rm</code> 删除版本库的文件</li><li><code>git branch</code> 查看当前所有分支</li><li><code>git branch &lt;分支名字&gt;</code> 创建分支</li><li><code>git checkout &lt;分支名字&gt;</code> 切换到分支</li><li><code>git merge &lt;分支名字&gt;</code> 合并分支</li><li><code>git branch -d &lt;分支名字&gt;</code> 删除分支,有可能会删除失败，因为<code>Git</code>会保护没有被合并的分支</li><li><code>git branch -D + &lt;分支名字&gt;</code> 强行删除，丢弃没被合并的分支</li><li><code>git log --graph</code> 查看分支合并图</li><li><code>git merge --no-ff &lt;分支名字&gt;</code> 合并分支的时候禁用<code>Fast forward</code>模式,因为这个模式会丢失分支历史信息</li><li><code>git stash</code> 当有其他任务插进来时，把当前工作现场“存储”起来,以后恢复后继续工作</li><li><code>git stash list</code> 查看你刚刚“存放”起来的工作去哪里了</li><li><code>git stash apply</code> 恢复却不删除<code>stash</code>内容</li><li><code>git stash drop</code> 删除<code>stash</code>内容</li><li><code>git stash pop</code> 恢复的同时把stash内容也删了</li><li><code>git remote</code> 查看远程库的信息，会显示<code>origin</code>，远程仓库默认名称为<code>origin</code></li><li><code>git remote -v</code> 显示更详细的信息</li><li><code>git pull</code> 把最新的提交从远程仓库中抓取下来，在本地合并,和<code>git push</code>相反</li><li><code>git rebase</code> 把分叉的提交历史“整理”成一条直线，看上去更直观</li><li><code>git tag</code> 查看所有标签，可以知道历史版本的tag</li><li><code>git tag &lt;name&gt;</code> 打标签，默认为<code>HEAD</code>。比如<code>git tag v1.0</code></li><li><code>git tag &lt;tagName&gt; &lt;版本号&gt;</code> 把版本号打上标签，版本号就是<code>commit</code>时，跟在旁边的一串字母数字</li><li><code>git show &lt;tagName&gt;</code> 查看标签信息</li><li><code>git tag -a &lt;tagName&gt; -m &quot;&lt;说明&gt;&quot;</code> 创建带说明的标签。 <code>-a</code>指定标签名，<code>-m</code>指定说明文字</li><li><code>git tag -d &lt;tagName&gt;</code> 删除标签</li><li><code>git push origin &lt;tagname&gt;</code> 推送某个标签到远程</li><li><code>git push origin --tags</code> 一次性推送全部尚未推送到远程的本地标签</li><li><code>git push origin :refs/tags/&lt;tagname&gt;</code> 删除远程标签<code>&lt;tagname&gt;</code></li><li><code>git config --global color.ui true</code> 让Git显示颜色，会让命令输出看起来更醒目</li><li><code>git add -f &lt;file&gt;</code> 强制提交已忽略的的文件</li><li><code>git check-ignore -v &lt;file&gt;</code> 检查为什么Git会忽略该文件<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1>廖雪峰老师讲Git讲的通俗易懂，对小白很友好。认认真真花上两天时间去整理，会有所收获的。<a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖老师的个人网站传送门</a></li></ul><p>欢迎访问我的<a href="https://zhongjunhaoz.github.io/">个人博客</a>，定时分享技术文章，一起前端学习！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>仿网易云音乐微信小程序</title>
      <link href="/2019/10/20/fang-wang-yi-yun-yin-le-wei-xin-xiao-cheng-xu/"/>
      <url>/2019/10/20/fang-wang-yi-yun-yin-le-wei-xin-xiao-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="项目部分截图-Gif"><a href="#项目部分截图-Gif" class="headerlink" title="项目部分截图(Gif)"></a>项目部分截图(Gif)</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/24/16b89bbee707dd70?w=405&h=692&f=gif&s=3289476" alt=""><br><img src="https://user-gold-cdn.xitu.io/2019/6/24/16b89f9bc0492380?w=405&h=692&f=gif&s=3465695" alt=""><br><img src="https://user-gold-cdn.xitu.io/2019/6/24/16b89c4f8e1eccb5?w=405&h=692&f=gif&s=4980551" alt=""></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一阵子学习了微信小程序，为了巩固所学的知识和提高实战经验，决定自己手撸一款小程序。因为听歌一直在用网易云音乐，所以突发奇想就做一款仿网易云音乐的小程序吧！开发中遇到了很多在学习中没有遇到过的坑，也很感谢在我改不出BUG时给予帮助的老师同学！本着学习和分享的目的，写下以下的文字,希望能给<strong>初学小程序的你</strong>带来一点帮助,大佬轻点喷。</p><hr><h1 id="开发前准备"><a href="#开发前准备" class="headerlink" title="开发前准备"></a>开发前准备</h1><ul><li>VScode代码编辑器。</li><li>微信开发者工具</li><li>ios网易云音乐(V5.9.1版本)</li><li>酷狗音乐小程序(提供了一些思路)</li><li><a href="[http://musicapi.leanapp.cn/">网易云音乐API</a></li><li>(<a href="https://www.iconfont.cn" target="_blank" rel="noopener">阿里巴巴矢量图标库</a>)提供一些图标icon</li></ul><hr><h1 id="tabBar部分"><a href="#tabBar部分" class="headerlink" title="tabBar部分"></a>tabBar部分</h1><h2 id="自定义tabBar"><a href="#自定义tabBar" class="headerlink" title="自定义tabBar"></a><strong>自定义tabBar</strong></h2><p>一般在开发中，微信小程序给我们的tabBar就能满足需求。但是，有些特别的需求必须使用自定义tabBar才能满足。<br>比如tabBar实现半透明。那么，如何才能自定义tabBar呢？<br>    1.首先,在 app.json里的”tabBar”里声明<br>    <code>&quot;tabBar&quot;: {    &quot;custom&quot;: true    }</code><br>    2.接着在项目的根目录下新建一个<code>custom-tab-bar</code>文件夹。里面包含<code>index.wxml index.js index.json index.wxss</code>四个文件。更多细节参考<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html" target="_blank" rel="noopener">微信小程序文档</a><br><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8a44df06fca6e?w=511&h=229&f=png&s=66834" alt=""></p><pre><code>&lt;!-- index.html --&gt;&lt;!-- 自定义tabbar页面 --&gt;&lt;cover-view class=&quot;tab-bar&quot;&gt;   &lt;cover-view class=&quot;tab-bar-border&quot;&gt;&lt;/cover-view&gt;&lt;!--tabBal边框样式  --&gt;&lt;!-- 乐库tabbar --&gt;  &lt;cover-view class=&#39;tab-bar-item&#39; &gt;    &lt;cover-image src=&#39;../images/music.png&#39; hidden=&#39;{{isShow_index}}&#39; bindtap=&#39;switchTab_index&#39;&gt;&lt;/cover-image&gt;    &lt;cover-image src=&#39;../images/selected-music.png&#39; hidden=&#39;{{!isShow_index}}&#39; bindtap=&#39;switchTab_index&#39;&gt;&lt;/cover-image&gt;    &lt;cover-view style=&quot;color:{{isShow_index ? selectedColor : color}}&quot;&gt;乐库&lt;/cover-view&gt;  &lt;/cover-view&gt;&lt;!-- 播放tabbar --&gt;    &lt;cover-view class=&#39;tab-bar-item&#39; bindtap=&#39;switchTab_playing&#39;&gt;    &lt;cover-image src=&#39;../images/selected-playing.png&#39; hidden=&#39;{{isShow_playing}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-image src=&#39;../images/playing.png&#39; hidden=&#39;{{!isShow_playing}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-view&gt;&lt;/cover-view&gt;  &lt;/cover-view&gt;&lt;!-- 我的tabbar --&gt;    &lt;cover-view class=&#39;tab-bar-item&#39; bindtap=&#39;switchTab_me&#39;&gt;    &lt;cover-image src=&#39;../images/me.png&#39; hidden=&#39;{{isShow_me}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-image src=&#39;../images/selected-me.png&#39; hidden=&#39;{{!isShow_me}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-view style=&quot;color:{{isShow_me ? selectedColor : color}}&quot;&gt;我的&lt;/cover-view&gt;  &lt;/cover-view&gt;&lt;/cover-view&gt;</code></pre><pre><code>// index.jsComponent({  data: {    isShow_index:true,    isShow_playing:false,    isShow_me:false,    selected: 0, //首页    color: &quot;#8D8D8D&quot;,    selectedColor: &quot;#C62F2F&quot;,    list: [{      pagePath: &quot;/pages/index/index&quot;,      iconPath: &quot;/images/music.png&quot;,      selectedIconPath: &quot;/images/selected-music.png&quot;,      text: &quot;乐库&quot;    }, {      pagePath: &quot;/pages/love/love&quot;,        iconPath: &quot;/images/selected-playing.png&quot;,      selectedIconPath: &quot;/images/playing.png&quot;,      text: &quot;&quot;    },      {        pagePath: &quot;/pages/me/me&quot;,        iconPath: &quot;/images/me.png&quot;,        selectedIconPath: &quot;/images/selected-me.png&quot;,        text: &quot;我的&quot;      }]  },  methods: {    switchTab_index:function(){      wx.switchTab({        url:&#39;/pages/index/index&#39;      })      this.setData({        isShow_index: true,        isShow_me: false,        isShow_playing: false      })    },    switchTab_playing: function () {      wx.switchTab({        url: &#39;/pages/love/love&#39;      })      this.setData({        isShow_playing: true,        isShow_index: false,        isShow_me: false      })    },    switchTab_me: function () {      wx.switchTab({        url: &#39;/pages/me/me&#39;      })      this.setData({        isShow_me:true,        isShow_playing: false,        isShow_index: false      })    }  }})</code></pre><h2 id="tabBar半透明"><a href="#tabBar半透明" class="headerlink" title="tabBar半透明"></a><strong>tabBar半透明</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8a6ee63e9f2da?w=405&h=94&f=gif&s=538191" alt=""></p><pre><code>/* custom-tab-bar/index.wxss */.tab-bar {  height:7%;  position: fixed;  bottom: 0;  left: 0;  right: 0;  height: 48px;  background:#FAFBFD;  opacity: 0.93;  display: flex;  padding-bottom: env(safe-area-inset-bottom);}</code></pre><h1 id="API封装"><a href="#API封装" class="headerlink" title="API封装"></a>API封装</h1><p>一般我们https请求都是通过<code>wx.request</code>来请求,但是这种方法只能请求一次数据,如果首页用<code>wx.request</code>来请求的话,代码看起来会很冗长和杂乱。不仅自己容易搞糊涂,其他人看代码时也会很累。因此为了代码的整洁干净,我在这里新建了一个文件专门存放API。一般在根目录下的<code>utils</code>文件夹下新建一个<code>api.js</code>,但我在根目录下新建了文件夹<code>API</code>,里面包含<code>api.js</code>。</p><pre><code>// api.jsconst API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const request = (url, data) =&gt; {   let _url = API_BASE_URL  + url;  return new Promise((resolve, reject) =&gt; {    wx.request({      url: _url,      method: &quot;get&quot;,      data: data,      header: {        &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;      },      success(request) {        resolve(request.data)      },      fail(error) {        reject(error)      }    })  });}module.exports ={  gethotsongs:(data) =&gt;{    return request(&#39;/search/hot&#39;,data)//热搜接口  },  searchSuggest:(data)=&gt;{    return request(&#39;/search/suggest&#39;,data)//搜索建议接口  },  searchResult:(data)=&gt;{    return request(&#39;/search&#39;,data)//搜索结果接口  },  getBanner:(data)=&gt;{    return request(&#39;/banner&#39;,data)//个性推荐轮播  },  getsongsheet:(data)=&gt;{    return request(&#39;/top/playlist&#39;,data)//热门歌单接口  },  getNewSong:(data)=&gt;{    return request(&#39;/personalized/newsong&#39;,data)//最新音乐接口  },  getDjRadios:(data)=&gt;{    return request(&#39;/dj/recommend&#39;,data)//电台推荐接口  },  getProgramRecommend:(data)=&gt;{    return request(&#39;/program/recommend&#39;,data)//推荐节目接口  },  getRecommendType:(data)=&gt;{    return request(&#39;/dj/recommend/type&#39;,data)//所有电台分类推荐  },  getRecommendMV:(data)=&gt;{    return request(&#39;/personalized/mv&#39;,data)//推荐MV  },  getNewMv:(data)=&gt;{    return request(&#39;/mv/first&#39;,data)//最新MV  },  getNewEst:(data)=&gt;{    return request(&#39;/album/newest&#39;,data)//最新专辑  },  getTopList:(data)=&gt;{    return request(&#39;/top/list&#39;,data)//排行榜  },  getDjList:(data)=&gt;{    return request(&#39;/dj/catelist&#39;,data) //电台分类  },  getPay:(data)=&gt;{    return request(&#39;/dj/paygift&#39;,data)//付费精品  },  getSonger:(data)=&gt;{    return request(&#39;/toplist/artist&#39;,data)//歌手排行  }}</code></pre><p><code>api.js</code>只能通过<code>module.exports</code>来暴露,那个页面要数据就从这拿。如果在哪个页面要用到它,还需要在头部引入一下:</p><p><code>const API = require(&#39;../../API/api&#39;)</code></p><p>以个性推荐轮播图为例，</p><pre><code>  getBanner: function() {    API.getBanner({      type: 2    }).then(res =&gt; {      if (res.code === 200) { //更加严谨        this.setData({          banner: res.banners        })      }    })  }</code></pre><p>  这样就把请求到的数据存储到<code>banner</code>中了。</p><hr><h1 id="搜索部分"><a href="#搜索部分" class="headerlink" title="搜索部分"></a>搜索部分</h1><h2 id="输入框样式"><a href="#输入框样式" class="headerlink" title="输入框样式"></a><strong>输入框样式</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8da289aa52854?w=436&h=97&f=png&s=7182" alt=""><br>我这里是引入了<code>WEUI</code>的样式，<br>1.下载<code>weui.wxss</code>,链接我找不到了，所以我放上了我的<a href="https://github.com/zhongjunhaoz/CloudMusic/blob/master/weui.wxss" target="_blank" rel="noopener">github</a>上的<code>weui.wxss</code>。<br>2.把下载好的<code>weui.wxss</code>放到根目录下。<br>3.在<code>app.wxss</code>中<code>@import &quot;weui.wxss&quot;;</code>引入一下就可以使用微信提供给我们的样式了。<br>4.<a href="https://weui.io/" target="_blank" rel="noopener"><code>WeUI</code>样式库</a></p><h2 id="热门搜索"><a href="#热门搜索" class="headerlink" title="热门搜索"></a><strong>热门搜索</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8daeda7452a8f?w=415&h=404&f=png&s=31051" alt=""><br>上面已经提到我从<code>api.js</code>中拿数据。</p><pre><code> // 从接口到获取到数据导入到hotsongs  gethotsongs() {    API.gethotsongs({ type: &#39;new&#39; }).then(res =&gt; {      wx.hideLoading()      if (res.code === 200) {  //严谨        this.setData({          hotsongs: res.result.hots        })      }    })  }</code></pre><h2 id="搜索历史"><a href="#搜索历史" class="headerlink" title="搜索历史"></a><strong>搜索历史</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dba723508edc?w=419&h=741&f=png&s=42298" alt=""><br>思路：当在输入框输入完成后–&gt;失去焦点–&gt; 利用<code>wx.setStorageSync</code>存进缓存中–&gt;<code>wx.getStorageSync</code>获取到并把它打印出来。</p><pre><code>  // input失去焦点函数  routeSearchResPage: function(e) {    console.log(e.detail.value)    let history = wx.getStorageSync(&quot;history&quot;) || [];    history.push(this.data.searchKey)    wx.setStorageSync(&quot;history&quot;, history);  },//每次显示变动就去获取缓存，给history，并for出来。  onShow: function () {    this.setData({      history: wx.getStorageSync(&quot;history&quot;) || []    })  },</code></pre><h2 id="清空搜索历史"><a href="#清空搜索历史" class="headerlink" title="清空搜索历史"></a><strong>清空搜索历史</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dbe42c2c2c33?w=405&h=487&f=gif&s=119001" alt=""><br>思路：×图标绑定事件-&gt;呼出对话框<code>wx.showModal</code>-&gt;确定则把<code>history</code>赋值为空</p><pre><code>    // 清空page对象data的history数组 重置缓存为[]  clearHistory: function() {    const that = this;    wx.showModal({      content: &#39;确认清空全部历史记录&#39;,      cancelColor:&#39;#DE655C&#39;,      confirmColor: &#39;#DE655C&#39;,      success(res) {        if (res.confirm) {          that.setData({            history: []          })          wx.setStorageSync(&quot;history&quot;, []) //把空数组给history,即清空历史记录        } else if (res.cancel) {        }      }    })  },</code></pre><h2 id="实时搜索建议"><a href="#实时搜索建议" class="headerlink" title="实时搜索建议"></a><strong>实时搜索建议</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dc5e9059003f?w=399&h=707&f=gif&s=62309" alt=""><br>思路：实时获取输入框的值-&gt;把值传给搜索建议API，发起网络请求-&gt;请求之后拿到搜索建议-&gt;打印结果并隐藏其他组件只保留搜索建议的组件(类似于Vue里的v-show)</p><pre><code> //获取input文本并且实时搜索,动态隐藏组件  getsearchKey:function(e){    console.log(e.detail.value) //打印出输入框的值    let that = this;    if(e.detail.cursor != that.data.cursor){ //实时获取输入框的值      that.setData({        searchKey: e.detail.value      })    }    if(e.value!=&quot;&quot;){ //组件的显示与隐藏      that.setData({        showView: false      })    } else{      that.setData({        showView: &quot;&quot;      })    }    if(e.detail.value!=&quot;&quot;){ //解决 如果输入框的值为空时，传值给搜索建议，会报错的bug      that.searchSuggest();    }    }</code></pre><pre><code>  // 搜索建议  searchSuggest(){    API.searchSuggest({ keywords: this.data.searchKey ,type:&#39;mobile&#39;}).then(res=&gt;{      if(res.code === 200){        this.setData({          searchsuggest:res.result.allMatch        })      }    })  }</code></pre><h2 id="点击热搜或历史，执行搜索"><a href="#点击热搜或历史，执行搜索" class="headerlink" title="点击热搜或历史，执行搜索"></a>点击热搜或历史，执行搜索</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8eefd6bdf126f?w=403&h=703&f=gif&s=257246" alt=""><br>思路：关键是<code>event</code>,点击通过<code>e.currentTarget.dataset.value</code>拿到所点击的值，再交给其他方法执行搜索行为。</p><pre><code>// 点击热门搜索值或搜索历史，填入搜索框  fill_value:function(e){    let that = this;    console.log(history)    // console.log(e.currentTarget.dataset.value)    that.setData({      searchKey: e.currentTarget.dataset.value,//点击吧=把值给searchKey,让他去搜索      inputValue: e.currentTarget.dataset.value,//在输入框显示内容      showView:false,//给false值，隐藏 热搜和历史 界面      showsongresult: false, //给false值，隐藏搜索建议页面    })    that.searchResult(); //执行搜索功能  }</code></pre><h2 id="搜索结果"><a href="#搜索结果" class="headerlink" title="搜索结果"></a><strong>搜索结果</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dd6660f63f9a?w=399&h=707&f=gif&s=63353" alt=""><br>思路：输入结束-&gt;确认键-&gt;调用<code>searchResult</code>请求到结果</p><pre><code>// 搜索完成点击确认  searchover:function(){    let that = this;    that.setData({      showsongresult: false    })    that.searchResult();  }</code></pre><pre><code>   // 搜索结果  searchResult(){    console.log(this.data.searchKey)    API.searchResult({ keywords: this.data.searchKey, type: 1, limit: 100, offset:2 }).then(res =&gt; {      if (res.code === 200) {        this.setData({          searchresult: res.result.songs        })      }    })  }</code></pre><hr><h1 id="乐库部分"><a href="#乐库部分" class="headerlink" title="乐库部分"></a>乐库部分</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8deb716cb19fc?w=1049&h=734&f=png&s=483647" alt=""><br>乐库部分其实没什么逻辑很难的部分，以结构和样式为主，在这里就不赘述了。可以到我的<a href="https://github.com/zhongjunhaoz/CloudMusic" target="_blank" rel="noopener">github</a>上查看。在这里分享一些小功能的实现和踩到的坑。</p><h2 id="个性推荐，主播电台切换"><a href="#个性推荐，主播电台切换" class="headerlink" title="个性推荐，主播电台切换"></a><strong>个性推荐，主播电台切换</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8e03ef5ad0dbc?w=403&h=669&f=gif&s=1612390" alt=""><br>1.个性推荐和主播电台是两个<code>swiper-item</code>所以他们才可以左右滑动，就像轮播图一样，不过轮播图放的是图片，而这里放的是整个页面。<br>2.我要实现的效果是左右滑动的同时，<code>个性推荐</code>和<code>主播电台</code>下面的白色方块也要跟着滑动。<br><strong>1. 第一种方法</strong><br>给包裹两个<code>swiper-item</code>的<code>swiper</code>添加一个<code>bindchange=&quot;changeline&quot;</code>事件，把事件对象<code>event</code>打印出来发现，<code>console.log(e.detail.current)</code>,当我们左右滑动的时候<code>cuurrent</code>的值会在<code>0</code>和<code>1</code>之间切换。所以我给白色方块添加</p><pre><code>class=&quot;{{changeline?'swiper_header_line_before':'swiper_header_line_after'}}&quot;</code></pre><pre><code>    if(e.detail.current === 0){    this.setData({       changeline:true      })    }else{    this.setData({       changeline:false      })    }</code></pre><p>当<code>current</code>为0，即页面在个性推荐时，让<code>changeline</code>为<code>true</code>;当<code>current</code>为1，即页面在主播电台时，让<code>changeline</code>为<code>false</code>;为<code>true</code>时，给白色方块加持<code>swiper_header_line_before</code>的样式，为<code>false</code>时，加持<code>swiper_header_line_after</code>的样式。这样就可以跟随<code>swiper-item</code>的滑动而切换了。<strong>但是，这种切换方式太僵硬了</strong>，没有那种流畅的切换效果，而且不适合多<code>swiper-item</code>页面。<br><strong>2. 第二种方法</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8e8d9a71ab12a?w=436&h=295&f=png&s=23978" alt=""><br>让一半宽度，四分之一宽度设置为变量是为了兼容不同的手机型号。因为写死数据肯定会有BUG，所以才要计算宽度。</p><pre><code>&lt;view class=&quot;weui-navbar-slider&quot; style=&quot;transform:translateX({{slideOffset}}px);&quot;&gt;&lt;/view&gt;</code></pre><pre><code>.weui-navbar-slider{  width:28px;  height: 5px;  background: #ffffff;  border-radius:10rpx;  transition: transform .6s; }</code></pre><p><code>slideOffset</code>为变量，动态接受从<code>data</code>传来的数据。</p><pre><code>onLoad:function(){    wx.getSystemInfo({      success: function (res) {        // console.log(res.windowWidth)        // console.log(res.windowWidth / 2 / 2)        half = res.windowWidth / 2 ;        quarter = res.windowWidth / 2 / 2;        that.setData({          slideOffset: quarter - 14 //onLoad的时候让 quarter - 14 给slideOffset，即一开始就让他在个性推荐的下面，否则onLoad的时候一开始在0的位置        })      }    })}  changeline:function(e){    // console.log(e)    // console.log(e.detail.current)    let current = e.detail.current; //获取swiper的current值    if(e.detail.current === 0){      this.setData({        slideOffset: quarter - 14      })    }    if(e.detail.current === 1){      this.setData({        slideOffset: (quarter - 14) + half      })    }    if(e.detail.current === null){      this.setData({        slideOffset: quarter - 14      })    }  }</code></pre><h2 id="MV播放"><a href="#MV播放" class="headerlink" title="MV播放"></a>MV播放</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8ea3d1f4e6c01?w=403&h=669&f=gif&s=2204017" alt=""><br>主要是结构和样式，我直接上代码了。</p><pre><code>&lt;!-- play_mv.wxml --&gt;&lt;view class=&quot;mv_box&quot;&gt;    &lt;video src=&quot;{{mv.brs['480']}}&quot; class=&quot;mv&quot; autoplay=&quot;{{autoplay}}&quot; loop=&quot;{{loop}}&quot; direction=&quot;{{0}}&quot; show-fullscreen-btn=&quot;{{showfullscreenbtn}}&quot;    show-center-play-btn=&quot;{{showcenterplaybtn}}&quot; enable-progress-gesture=&quot;{{enableprogressgesture}}&quot; show-mute-btn=&quot;{{showmutebtn}}&quot; title=&quot;{{mv.name}}&quot;    play-btn-position=&quot;{{center}}&quot; object-fit=&quot;{{objectfit}}&quot;&gt;&lt;/video&gt;&lt;/view&gt;&lt;view class=&quot;mv_name&quot;&gt;{{mv.name}}&lt;/view&gt;&lt;view class=&quot;mv_time&quot;&gt; 发行:  {{mv.publishTime}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_times&quot;&gt;播放次数:  {{mv.playCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc&quot;&gt;{{mv.desc}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;点赞: {{mv.likeCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;收藏: {{mv.subCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;评论: {{mv.commentCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;分享: {{mv.shareCount}}&lt;/view&gt;</code></pre><pre><code>/* play/play_mv.wxss */.mv_box{    width: 100%;    height: 480rpx;    margin-top:-2rpx;}.mv{    width: 100%;    height: 100%;    border-radius:15rpx;}.mv_name{    margin-top:20rpx;    margin-left:20rpx;}.mv_time{    font-size: 12px;    margin-left:20rpx;    color:#979798;    display:initial;}.mv_times{    margin-left: 100rpx;}.mv_desc{    display: block;    color:#6A6B6C;}.mv_other{    display: block;}</code></pre><pre><code>// play_mv.jsconst API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const app = getApp();Page({  data: {    mv: [],    autoplay: true,    loop: true,    showfullscreenbtn: true,    showcenterplaybtn: true,    enableprogressgesture: true,    showmutebtn: true,    objectfit: &#39;contain&#39;,  },  onLoad: function (options) {    // console.log(mv_url);    const mvid = options.id; // onLoad()后获取到歌曲视频之类的id    // 请求MV的地址，失败则播放出错，成功则传值给createBgAudio(后台播放管理器，让其后台播放)    wx.request({      url: API_BASE_URL + &#39;/mv/detail&#39;,      data: {        mvid: mvid          },      success: res =&gt; {        console.log(res.data.data.brs[&#39;480&#39;])        console.log(&#39;歌曲音频url:&#39;, res)        if (res.data.data.brs === null) {  //如果是MV 电台 广告 之类的就提示播放出错，并返回首页          console.log(&#39;播放出错&#39;)          wx.showModal({            content: &#39;服务器开了点小差~~&#39;,            cancelColor: &#39;#DE655C&#39;,            confirmColor: &#39;#DE655C&#39;,            showCancel: false,            confirmText: &#39;返回&#39;,            complete() {              wx.switchTab({                url: &#39;/pages/index/index&#39;              })            }          })        } else {          this.setData({            mv: res.data.data          })        }      }    })  },})</code></pre><h2 id="歌手榜"><a href="#歌手榜" class="headerlink" title="歌手榜"></a>歌手榜</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8eaed5f5e5b3b?w=795&h=695&f=png&s=242469" alt=""></p><pre><code>// 歌手榜的jsconst API = require(&#39;../../API/api&#39;);const app = getApp();Page({  data: {    songers: [], //歌手榜  },  onLoad: function (options) {    wx.showLoading({      title: &#39;加载中&#39;,    });    this.getSonger();  },  getSonger: function () {    API.getSonger({}).then(res =&gt; {      wx.hideLoading()      this.setData({        songers: res.list.artists.slice(0, 100)      })    })  },  handleSheet: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性    const sheetId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面      url: `./moremore_songer?id=${sheetId}`    })  },})</code></pre><pre><code>&lt;!-- 歌手榜结构 --&gt;&lt;view wx:for=&quot;{{songers}}&quot; wx:key=&quot;&quot; class=&#39;songer_box&#39; data-id=&quot;{{item.id}}&quot; bindtap=&#39;handleSheet&#39;&gt;  &lt;view class=&#39;songer_index_box&#39;&gt;    &lt;text class=&#39;songer_index&#39;&gt;{{index + 1}}&lt;/text&gt;  &lt;/view&gt;  &lt;view class=&#39;songer_img_box&#39;&gt;  &lt;image src=&quot;{{item.picUrl}}&quot; class=&#39;songer_img&#39;&gt;&lt;/image&gt;  &lt;/view&gt;  &lt;view class=&#39;songer_name_box&#39;&gt;  &lt;text class=&#39;songer_name&#39;&gt;{{item.name}}&lt;/text&gt;  &lt;text class=&#39;songer_score&#39;&gt;{{item.score}}热度&lt;/text&gt;  &lt;/view&gt;&lt;/view&gt;</code></pre><pre><code>// 歌手下级路由歌曲列表const API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const app = getApp();Page({  data: {    songList: []  },  onLoad: function (options) {    wx.showLoading({      title: &#39;加载中&#39;,    });    const sheetId = options.id;    wx.request({      url: API_BASE_URL + &#39;/artists&#39;,      data: {        id: sheetId          },      success: res =&gt; {        const waitForPlay = new Array;        for (let i = 0; i &lt;= res.data.hotSongs.length - 1; i++) { //循环打印出其id          waitForPlay.push(res.data.hotSongs[i].id) //循环push ID 到waitForPlay数组          app.globalData.waitForPlaying = waitForPlay  //让waitForPlay数组给全局数组          // console.log(app.globalData.waitForPlaying)        }        wx.hideLoading()        console.log(res.data.hotSongs)        this.setData({          songList: res.data.hotSongs        })      }    })  },  handlePlayAudio: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性    const audioId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面      url: `../../play/play?id=${audioId}`    })  }})</code></pre><pre><code>&lt;!-- more/more_songer/moremore_songer.wxml歌手下面的歌曲 --&gt;&lt;view class=&#39;search_result_songs&#39;&gt;  &lt;view wx:for=&quot;{{songList}}&quot; wx:key=&quot;&quot; class=&#39;search_result_song_item songer_box&#39; data-id=&quot;{{item.id}}&quot; bindtap=&#39;handlePlayAudio&#39;&gt;    &lt;view class=&#39;songer_index_box&#39;&gt;      &lt;text class=&#39;songer_index&#39;&gt;{{index + 1}}&lt;/text&gt;    &lt;/view&gt;    &lt;view class=&#39;songer_img_box&#39;&gt;      &lt;view class=&#39;search_result_song_song_name&#39;&gt;{{item.name}}&lt;/view&gt;      &lt;view class=&#39;search_result_song_song_art-album&#39;&gt;{{item.ar[0].name}} - {{item.al.name}}&lt;/view&gt;    &lt;/view&gt;  &lt;/view&gt;&lt;/view&gt;</code></pre><h2 id="推荐歌单"><a href="#推荐歌单" class="headerlink" title="推荐歌单"></a>推荐歌单</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8eb96b06ef0b4?w=800&h=642&f=png&s=373779" alt=""><br>因为样式与排行榜类似，所以只放出图片，源码可以到我的<a href="https://github.com/zhongjunhaoz/CloudMusic/tree/master/more/more_sheet" target="_blank" rel="noopener">github</a>上查看。</p><h2 id="榜单排行"><a href="#榜单排行" class="headerlink" title="榜单排行"></a>榜单排行</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8ebf82357b4e6?w=735&h=623&f=png&s=222179" alt=""><br><a href="https://github.com/zhongjunhaoz/CloudMusic/tree/master/more" target="_blank" rel="noopener">请查看源码</a></p><h2 id="换一换功能"><a href="#换一换功能" class="headerlink" title="换一换功能"></a>换一换功能</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8ec5afa3172e5?w=403&h=386&f=gif&s=301154" alt=""><br>思路：绑定点击事件-&gt;选取随机的三个数-&gt;给空值-&gt;push三个随机数进数组中-&gt;重新赋值。</p><pre><code>  // 换一换  change_1:function(){    let maxNum = this.data.more_recommend_create.length  //计算数据长度    let r1 = parseInt(Math.random() * (maxNum - 0) + 0); //取【0-数据长度】内的整数随机数    let r2 = parseInt(Math.random() * (maxNum - 0) + 0);    let r3 = parseInt(Math.random() * (maxNum - 0) + 0);    this.setData({      recommend_create: []    })    //重新取3组数据    this.data.recommend_create.push(this.data.more_recommend_create[r1])    this.data.recommend_create.push(this.data.more_recommend_create[r2])    this.data.recommend_create.push(this.data.more_recommend_create[r3])    //重新赋值    this.setData({      recommend_create: this.data.recommend_create    })  }</code></pre><h1 id="播放界面"><a href="#播放界面" class="headerlink" title="播放界面"></a>播放界面</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8f088b494cb9c?w=403&h=703&f=gif&s=3753267" alt=""><br>图片太大，因此加快了播放。</p><h2 id="播放功能"><a href="#播放功能" class="headerlink" title="播放功能"></a>播放功能</h2><p><strong>思路：利用<code>data-id=&quot;&quot;</code>获取到歌曲ID放在<code>event</code>中-&gt; 通过<code>event</code>对象事件获取ID并跳转到播放页面 -&gt;<code>wx.request</code>获取到歌曲的音频地址及detail-&gt;背景音频管理器 <code>wx.getBackgroundAudioManager()</code>-&gt;播放</strong><br>以歌手榜下级路由歌曲列表为例，  </p><pre><code>&lt;view wx:for=&quot;{{songList}}&quot; wx:key=&quot;&quot; class=&#39;search_result_song_item songer_box&#39; data-id=&quot;{{item.id}}&quot; bindtap=&#39;handlePlayAudio&#39;&gt;</code></pre><pre><code>  handlePlayAudio: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性    const audioId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面      url: `../../play/play?id=${audioId}`    })  }</code></pre><pre><code>  // play.jsconst API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const app = getApp();Page({  data: {    isPlay: &#39;&#39;,    song:[],    innerAudioContext: {},    show:true,    showLyric:true,    songid:[],    history_songId:[]  },  onLoad: function (options) {    const audioid = options.id; // onLoad()后获取到歌曲视频之类的id    this.play(audioid); //把从wxml获取到的值传给play()  },  play: function (audioid){    const audioId = audioid;    app.globalData.songId = audioId;  //让每一个要播放的歌曲ID给全局变量的songId    const innerAudioContext = wx.createInnerAudioContext();    this.setData({      innerAudioContext,      isPlay: true    })    // 请求歌曲音频的地址，失败则播放出错，成功则传值给createBgAudio(后台播放管理器，让其后台播放)    wx.request({      url: API_BASE_URL + &#39;/song/url&#39;,      data: {        id: audioId      },      success: res =&gt; {        if (res.data.data[0].url === null) {  //如果是MV 电台 广告 之类的就提示播放出错，并返回首页          wx.showModal({            content: &#39;服务器开了点小差~~&#39;,            cancelColor: &#39;#DE655C&#39;,            confirmColor: &#39;#DE655C&#39;,            showCancel: false,            confirmText: &#39;返回&#39;,            complete() {              wx.switchTab({                url: &#39;/pages/index/index&#39;              })            }          })        } else {          this.createBgAudio(res.data.data[0]);        }      }    })    //获取到歌曲音频，则显示出歌曲的名字，歌手的信息，即获取歌曲详情；如果失败，则播放出错。    wx.request({      url: API_BASE_URL + &#39;/song/detail&#39;,      data: {        ids: audioId    //必选参数ids      },      success: res =&gt; {        if (res.data.songs.length === 0) {          wx.showModal({            content: &#39;服务器开了点小差~~&#39;,            cancelColor: &#39;#DE655C&#39;,            confirmColor: &#39;#DE655C&#39;,            showCancel: false,            confirmText: &#39;返回&#39;,            complete() {              wx.switchTab({                url: &#39;/pages/index/index&#39;              })            }          })        } else {          this.setData({            song: res.data.songs[0],  //获取到歌曲的详细内容，传给song          })          app.globalData.songName = res.data.songs[0].name;        }      },    })  },  createBgAudio(res) {    const bgAudioManage = wx.getBackgroundAudioManager(); //获取全局唯一的背景音频管理器。并把它给实例bgAudioManage    app.globalData.bgAudioManage = bgAudioManage;         //把实例bgAudioManage(背景音频管理器) 给 全局    bgAudioManage.title = &#39;title&#39;;                        //把title 音频标题 给实例    bgAudioManage.src = res.url;                          // res.url 在createBgAudio 为 mp3音频  url为空，播放出错    const history_songId = this.data.history_songId    const historySong = {      id: app.globalData.songId,      songName:app.globalData.songName    }    history_songId.push(historySong)    bgAudioManage.onPlay(res =&gt; {                         // 监听背景音频播放事件      this.setData({        isPlay: true,        history_songId      })    });    bgAudioManage.onEnded(() =&gt; {                  //监听背景音乐自然结束事件，结束后自动播放下一首。自然结束，调用go_lastSong()函数，即歌曲结束自动播放下一首歌      this.go_lastSong();    })    wx.setStorageSync(&#39;historyId&#39;, history_songId); //把historyId存入缓存  },})</code></pre><h2 id="暂停-播放"><a href="#暂停-播放" class="headerlink" title="暂停/播放"></a>暂停/播放</h2><pre><code>    &lt;!-- 暂停播放图标 --&gt;  &lt;view class=&quot;play_suspend&quot;&gt;    &lt;view class=&quot;icon_playing&quot;&gt;&lt;image bindtap=&quot;handleToggleBGAudio&quot; src=&quot;../images/suspend.png&quot; hidden=&quot;{{!isPlay}}&quot; class=&quot;{{'img_play_suspend'}}&quot; /&gt;  &lt;!-- 暂停图标--&gt;    &lt;image bindtap=&quot;handleToggleBGAudio&quot; src=&quot;../images/play.png&quot; hidden=&quot;{{isPlay}}&quot; class=&quot;{{'img_play_suspend'}}&quot; /&gt;&lt;/view&gt; &lt;!--播放图标--&gt;  &lt;/view&gt;</code></pre><pre><code>  // 播放和暂停  handleToggleBGAudio() {    // const innerAudioContext = app.globalData.innerAudioContext;    const bgAudioManage = app.globalData.bgAudioManage;    const {isPlay} = this.data;    if (isPlay) {      bgAudioManage.pause();      // innerAudioContext.pause();handleToggleBGAudio    } else {      bgAudioManage.play();      // innerAudioContext.play();    }    this.setData({      isPlay: !isPlay    })    console.log(this.data.isPlay)  }</code></pre><h2 id="上一首-下一首-随机播放"><a href="#上一首-下一首-随机播放" class="headerlink" title="上一首/下一首(随机播放)"></a>上一首/下一首(随机播放)</h2><p>  <strong>思路：点击歌单或歌手页，获取到对应的歌单/歌手id-&gt;<code>wx.request</code>请求数据获取到所有的歌单内/歌手热门歌曲音频地址-&gt;给全局变量globalData-&gt;点击上一首/下一首随机获取到全局变量的一则数据-&gt;给play()方法-&gt;播放</strong></p><pre><code>  &lt;!--歌单--&gt;    onLoad: function (options) {    wx.showLoading({      title: &#39;加载中&#39;,    });    const sheetId = options.id;    wx.request({      url: API_BASE_URL + &#39;/playlist/detail&#39;,      data: {        id: sheetId          },      success: res =&gt; {        const waitForPlay = new Array;        for (let i = 0; i &lt;= res.data.playlist.trackIds.length - 1;i++){ //循环打印出其id          waitForPlay.push(res.data.playlist.trackIds[i].id) //循环push ID 到waitForPlay数组          app.globalData.waitForPlaying = waitForPlay  //让waitForPlay数组给全局数组        }        wx.hideLoading()        this.setData({          songList: res.data.playlist.tracks        })        }    })  }</code></pre><pre><code>  &lt;view class=&quot;icon_playing &quot;&gt;&lt;image src=&quot;../images/lastSong.png&quot; class=&quot; icon_play&quot; bindtap=&quot;go_lastSong&quot; /&gt;&lt;/view&gt;  &lt;view class=&quot;icon_playing &quot;&gt;&lt;image src=&quot;../images/nextSong.png&quot; class=&quot; icon_play&quot; bindtap=&quot;go_lastSong&quot; /&gt;&lt;/view&gt;</code></pre><pre><code>    go_lastSong:function(){     let that = this;    const lastSongId = app.globalData.waitForPlaying;    const songId = lastSongId[Math.floor(Math.random() * lastSongId.length)]; //随机选取lastSongId数组的一个元素    that.data.songid = songId;    this.play(songId)//传进play()方法中    app.globalData.songId=songId;  }</code></pre><h2 id="歌词-封面切换"><a href="#歌词-封面切换" class="headerlink" title="歌词/封面切换"></a>歌词/封面切换</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b8f5e9d2a1e22b?w=403&h=703&f=gif&s=1127200" alt=""><br>  因为网易云API的歌词接口崩溃，请求不到歌词，所以我只能把歌词写死为<code>纯音乐，请欣赏</code>。类似于<code>v-show</code>。</p><pre><code>   &lt;!-- 封面 --&gt;  &lt;!-- 一开始onload时,showLyric=true, 显示为转动的图标，点击图标，切换为歌词--&gt;  &lt;view class=&quot;sing-show&quot; bindtap=&quot;showLyric&quot; &gt;    &lt;view class=&quot;moveCircle {{isPlay ? 'play' : ''}}&quot; hidden=&quot;{{!showLyric}}&quot;&gt;      &lt;image src=&quot;{{song.al.picUrl}}&quot; class=&quot;coverImg {{isPlay ? 'play' : ''}}&quot; hidden=&quot;{{!showLyric}}&quot;/&gt;    &lt;/view&gt;    &lt;text  hidden=&quot;{{showLyric}}&quot; class=&quot;songLyric&quot;&gt;纯音乐，请欣赏&lt;/text&gt;  &lt;/view&gt;</code></pre><pre><code>    // 点击切换歌词和封面  showLyric(){    const {showLyric} = this.data;    this.setData({      showLyric: !showLyric    })  }</code></pre><h2 id="破产版的孤独星球动效"><a href="#破产版的孤独星球动效" class="headerlink" title="破产版的孤独星球动效"></a>破产版的孤独星球动效</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8f4e771e9a04d?w=403&h=703&f=gif&s=1629412" alt=""><br>封面旋转：</p><pre><code>@keyframes rotate {  0%{    transform: rotate(0);  }  100%{    transform: rotate(360deg);  }}</code></pre><p>扩散的圆形线条：<br>其实就是外面套一个盒子，盒子宽高变大以及透明度逐渐变低。</p><pre><code>@keyframes moveCircle {  0%{    width: 400rpx;    height: 400rpx;    border: 1px solid rgba(255, 255, 255, 1)  }  30%{    width: 510rpx;    height: 510rpx;    border: 1px solid rgba(255, 255, 255, 0.8)  }  50%{    width: 610rpx;    height: 610rpx;    border: 1px solid rgba(255, 255, 255, 0.6)  }  80%{    width: 700rpx;    height: 700rpx;    border: 1px solid rgba(255, 255, 255, 0.4)  }  99%{    width: 375px;    height: 375px;    border: 1px solid rgba(255, 255, 255, 0.1)  }  100%{    width: 0px;    height: 0px;    border: 1px solid rgba(255, 255, 255, 0)  }}</code></pre><h2 id="背景毛玻璃"><a href="#背景毛玻璃" class="headerlink" title="背景毛玻璃"></a>背景毛玻璃</h2><pre><code>&lt;!-- play.wxml --&gt;&lt;image src=&quot;{{song.al.picUrl}}&quot; class=&quot;background_img&quot; &gt;&lt;/image&gt;</code></pre><pre><code>/* 播放界面毛玻璃效果 */.background_img{   position: fixed;  top: 0;  left: 0;  bottom: 0;  width: 100%;  height: 100%;  filter: blur(20px);  z-index: -1;  transform: scale(1.5); /*和网易云音乐对比了一下，发现也是放大1.5倍*/}</code></pre><hr><h1 id="播放tabBar"><a href="#播放tabBar" class="headerlink" title="播放tabBar"></a>播放tabBar</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b8f674f2bdc7a5?w=403&h=731&f=gif&s=1441605" alt=""><br>思路是参考酷狗音乐小程序。这个tabBar的js，wxml与播放功能界面的js，wxml相同。因为音乐播放是用<code>wx.getBackgroundAudioManager()</code>背景音频播放器管理的，所以才能同步。</p><hr><h1 id="我的tabBar"><a href="#我的tabBar" class="headerlink" title="我的tabBar"></a>我的tabBar</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b8f828b086f094?w=418&h=735&f=png&s=154747" alt=""></p><h2 id="播放历史"><a href="#播放历史" class="headerlink" title="播放历史"></a>播放历史</h2><p>思路：play.js中一旦播放成功就把歌名及歌曲ID传入全局变量-&gt;push到play.js里的数组中-&gt;<code>wx.setStorageSync</code>把数据存入缓存-&gt;在需要的页面<code>wx.getStorageSync</code>获取到缓存。</p><pre><code>&lt;!--play.js--&gt;const history_songId = this.data.history_songIdconst historySong = {      // id: res.id      id: app.globalData.songId,      songName:app.globalData.songName    }    history_songId.push(historySong)    wx.setStorageSync(&#39;historyId&#39;, history_songId); //把historyId存入缓存</code></pre><pre><code>&lt;!--me.js--&gt; onShow:function(){    var history = wx.getStorageSync(&#39;historyId&#39;);    // console.log(history)     this.setData({      hidden:true,      //  historyId: app.globalData.songName       historyId: history    })    console.log(this.data.historyId)  }</code></pre><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  做项目的过程总的来说痛并快乐，因为改不出BUG的样子真的很狼狈，但实现了某一个功能的那一刻真的很欣慰。再次感谢给予帮助的老师同学。如果你喜欢这篇文章或者可以帮到你，不妨点个赞吧！同时也非常希望看到这篇文章的你在下方给出建议！最后奉上<a href="https://github.com/zhongjunhaoz/CloudMusic" target="_blank" rel="noopener"><strong>源码</strong></a>，有需要的可以自取。最后，说点题外话，因为我是2020届毕业生，现在面临实习压力，有没有大佬捞一下。</p><p>  欢迎访问我的<a href="https://zhongjunhaoz.github.io/">个人博客</a>，定时分享技术文章，一起前端学习！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
