<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从源头上解决HTTP面试问题 - 重学计算机网络系列(1)</title>
      <link href="/2020/01/08/cong-yuan-tou-shang-jie-jue-http-mian-shi-wen-ti-chong-xue-ji-suan-ji-wang-luo-xi-lie-1/"/>
      <url>/2020/01/08/cong-yuan-tou-shang-jie-jue-http-mian-shi-wen-ti-chong-xue-ji-suan-ji-wang-luo-xi-lie-1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2019/12/27/16f4685e332d4a4b?w=1144&h=439&f=png&s=45298" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>这是关于计算机网络的<strong>一系列专题，后续会不断更新</strong>。</li><li>因为是前端开发，所以我的重心是放在<strong>应用层</strong>，重中之重是应用层下面的<strong>HTTP协议</strong>。</li><li>学习资料来源于 <strong>《计算机网络》(第七版) 和《图解HTTP》。</strong></li><li>本篇主要分享<strong>互联网概述，计算机网络体系结构等</strong>知识。</li></ul><h1 id="互连网与互联网的区别"><a href="#互连网与互联网的区别" class="headerlink" title="互连网与互联网的区别"></a>互连网与互联网的区别</h1><h2 id="互连网"><a href="#互连网" class="headerlink" title="互连网"></a>互连网</h2><ul><li>与网络相连的计算机称为主机。智能手机也可以称为主机。</li><li>结点可以是<strong>计算机，集成器，交换机，路由器等</strong>。</li><li>计算机网络（简称网络）由<strong>若干结点</strong>和连接这些结点的<strong>链路</strong>组成。</li><li><strong>互连网</strong>：网络之间可以通过路由器互连起来，这就构成一个覆盖范围更大的计算机网络。</li><li><strong>互连网是“网络的网络”</strong>，泛指由多个计算机网络互连而成的计算机网络。网络把许多计算机连接在一起。而<strong>互连网</strong>把许多网络通过路由器连接在一起。</li></ul><h2 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h2><ul><li>也叫做因特网，不过现在不用了。</li><li>互联网(专有名词)：指当前<strong>全球最大的</strong>，开放的，由众多网络相互连接而成的特定<strong>互连网</strong>。</li><li>这也是为什么1994年中国接入互联网叫做<strong>接入</strong>，而不是其他动词。</li><li>采用<strong>TCP/IP</strong>协议族作为通信的规则，前身是<code>ARPANET</code>。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>计算机，交换机，路由器等 = 结点</li><li>结点 + 链路 = 网络</li><li>网络 + 网络 = 互连网</li><li>互联网 = 全球最大的互连网</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/11/10/16e53aaeea02db07?w=3703&h=1253&f=jpeg&s=909601" alt=""></p><h1 id="互联网发展的几个阶段"><a href="#互联网发展的几个阶段" class="headerlink" title="互联网发展的几个阶段"></a>互联网发展的几个阶段</h1><ul><li>第一阶段：1969美国国防部创建的第一个分组交换网<code>ARPANET</code>。（并不是一个互连的网络）所有要连接在<code>ARPANET</code>上的主机都直接与最近的结点交换机相连。<ul><li>第二阶段：20世纪70年代中期，开始研究<strong>多种网络互连的技术</strong>，导致互连网络的出现。互联网的雏形。</li></ul></li><li>第三阶段：1983年，<code>TCP/IP</code>协议成为<code>ARPANET</code>上的标准协议，使所有使用<code>TCP/IP</code>协议的计算机都能利用互联网相互通信。互联网诞生。</li><li>第四阶段：1985年。建成了三级结构的互联网<code>NSFNET</code>。分为主干网，地区网，校园网。基本覆盖了全美国主要的大学和研究所。</li><li>第五阶段：世界上许多公司纷纷接入到互联网，网络通信急剧增大，满足不了需求。美国政府决定交给私人公司来经营，开始收费。于是，逐渐形成<strong>多层次ISP结构</strong>的互联网。1993年开始，三级结构的互联网<code>NSFNET</code>逐渐被若干个商用的互联网主干网替代。</li></ul><h1 id="ISP（互联网服务提供商）"><a href="#ISP（互联网服务提供商）" class="headerlink" title="ISP（互联网服务提供商）"></a>ISP（互联网服务提供商）</h1><ul><li>中国电信，中国联通，中国移动等公司是中国最有名的ISP。</li><li>ISP可以从互联网管理机构申请到很多IP地址。<strong>主机必须有IP地址才能上网</strong>，同时还有通信线路，路由器等联网设备。缴纳费用就能能获取所需IP地址的使用权。</li><li>所谓上网就是通过ISP获得的IP地址接入互联网。</li><li>ISP分为主干ISP，地区ISP，本地ISP。<ul><li>主干ISP由专门的公司创建和维持，服务面积最大（一般能覆盖国家范围）</li><li>地区ISP是一些较小的ISP。</li><li>本地ISP给用户提供直接的服务。本地ISP可以是一个仅仅提供互联网服务的公司，也可以是一个拥有网络并向自己雇员提供服务的企业，或者是大学。</li></ul></li><li>主机A和主机B通信的过程。主机A –&gt; 本地ISP –&gt; 地区ISP –&gt; 主干ISP –&gt; 地区ISP –&gt; 本地ISP –&gt; 主机B</li><li>上面这种通信要经过层层阻拦，是否能绕过主干ISP，地区ISP直接和地区ISP直接通信呢？可以的。<strong>互联网交换点IXP</strong>的主要作用是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。 主机A –&gt; 本地ISP –&gt; 地区ISP –&gt; 地区ISP –&gt; 本地ISP –&gt; 主机B<br><img src="https://user-gold-cdn.xitu.io/2019/11/10/16e53ae0d72b8ae1?w=678&h=335&f=png&s=79228" alt=""></li></ul><h1 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h1><ul><li>从工作方式可以分为两大块：边缘部分 + 核心部分。<ul><li>边缘部分：由所有连接在互联网上的主机组成，用户直接使用。</li><li>核心部分：由大量网络和连接这些网络的路由器组成。</li></ul></li><li>边缘部分的通信方式<ul><li>客户-服务器方式（C/S）。客户是服务请求方，服务器是服务提供方。</li><li>对等连接方式（P2P）。两台主机通信并不区分哪一个是服务请求方哪一个是提供方。只要两台主机都运行了对等连接软件就可以通信，相互下载对方硬盘里面的文档。</li></ul></li><li>核心部分<ul><li>路由器。它是一种专用计算机。路由器是实现<strong>分组交换</strong>的关键构件，其任务是转发收到的分组。<h2 id="何为分组交换"><a href="#何为分组交换" class="headerlink" title="何为分组交换"></a>何为分组交换</h2></li></ul></li><li>电路交换： 建立连接（占用通信资源） -&gt; 通话（一直占用通信资源） -&gt; 释放连接（归还通信资源）。在通话的全部时间里，通话的两个用户始终占用端到端的通信资源。</li><li>分组交换：采用<strong>存储转发</strong>技术。要发送整块数据，这块数据被称为一个<strong>报文</strong>。在发送之前，把报文分成一个个更小的等长数据段，并在头部加上包头。</li><li><strong>（首部 + 数据 = 分组）X （很多个） = 报文</strong></li><li>路由器的作用就是<strong>用来转发这些分组</strong>的。路由器收到一个分组，先暂存一下，检查头部，查找转发表，交给下一个路由器，一步一步以存储转发的方式给目的主机。分组交换在传输数据之前不必占用一条端到端的通信资源，并且省去了建立连接和释放连接的开销，<strong>传输数据效率更高</strong>。</li></ul><blockquote><p>为了理解<strong>分组</strong>，我还是更愿意称之为<strong>小报文</strong>，更方便记忆。因为称之为分组我感觉太拗口了。</p></blockquote><ul><li>总结  <ul><li>电路交换。整个报文连续从源点到终点，好像在一个管道中传送。适合大量数据传输。</li><li>报文交换。整个报文先到达相邻结点，全部储存下来查找转发表，转发到下一个结点。</li><li>分组交换。单个分组（整个报文的一小部分）传送给相邻结点，存储下来后查找转发表，转发到下一个结点。（原理采用报文交换）灵活。</li></ul></li></ul><h1 id="七层协议和四层协议的由来"><a href="#七层协议和四层协议的由来" class="headerlink" title="七层协议和四层协议的由来"></a>七层协议和四层协议的由来</h1><p><img src="https://user-gold-cdn.xitu.io/2019/11/10/16e53ec3b6abd5b4?w=686&h=409&f=png&s=168302" alt=""><br>先看一个很简单的例子：连接在网络上的两台计算机要互相传送文件。<br>  要实现这种功能需要做什么呢？</p><ul><li>两者之间要有传输数据的通路。</li><li>要保证通道的正确发送和接收。</li><li>要告诉网络如何识别接收数据的计算机。</li><li>必须检查对方是否开机，并且联网了。</li><li>发起通信的计算机的软件必须搞清楚在对方的软件是否做好接收文件和存储文件的准备。</li><li>若计算机文件格式不兼容，则至少其中一台计算机应完成格式转换功能。</li><li>对于出现的各种差错意外，如数据传输错误，重复，丢失，是否有可靠的措施保障对方能接受到正确的文件。</li></ul><p>以上在种种，表明相互通信的两个计算机系统必须高度协调工作才行，为了协调，提出了<strong>分层</strong>的方法。用<strong>分层</strong>把问题分而治之。</p><h2 id="协议与划分层次"><a href="#协议与划分层次" class="headerlink" title="协议与划分层次"></a>协议与划分层次</h2><p>  在计算机网络要做到有条不紊的交换数据，就必须遵守实现约好的规则。这些为进行网络中的数据交换而建立的规则，标准，约定称之为<strong>网络协议</strong>，也可简称为<strong>协议</strong>。协议有三要素。</p><ul><li>语法。数据与控制信息的结构或格式。</li><li>语义。即需要发出何种控制信息，完成何种动作以及做出何种响应。</li><li>同步。事件实现顺序的详细说明。 </li></ul><p>  <strong>我们想连接在网络上的另外一台计算机做点什么事，都需要有协议。</strong></p><h2 id="立贤不立长"><a href="#立贤不立长" class="headerlink" title="立贤不立长"></a>立贤不立长</h2><ul><li>1974年，美国IBM公司宣布了<code>系统网络体系结构SNA</code>。这个网络标准是按照分层的方法制定的。不久其他一些公司也相继推出自己公司的体系结构。</li><li>不同的网络体系结构出现后，使得同一个公司生产的各种设备都能很容易地互连成网。但由于<strong>网络体系结构的不同，不同公司的设备很难互相连通</strong>。</li><li>为了使得不同网络体系结构的用户迫切要求能够互相交换信息，国际化标准组织ISO在1977成立专门机构研究该问题。他们提出一个试图使各种计算机在世界范围内互连成网的标准框架，即OSI/RM,<strong>简称OSI</strong>。只要遵循OSI标准，一个系统就可以和世界上任何地方的，也遵守这一标准的其他任何系统进行通信。</li><li>1983年，OSI提出了<strong>七层协议。</strong></li><li>但是，到了90年代初期，尽管整套的OSI国际标准已经制定出来，但基于<strong>TCP/IP的四层协议</strong>的互联网已抢先在全球相当大的范围成功运行。OSI失败了。</li><li>得到最广泛应用的不是法律上的标准OSI，而是非国际标准TCP/IP。<strong>TCP/IP被当做事实的国际标准</strong>。<blockquote><ul><li>现在人们提到的TCP/IP并不一定单指TCP和IP两个具体的协议，而是往往表示互联网所使用的<strong>整个TCP/IP协议族</strong>。</li><li>网络协议的一个重要的特定是必须把所有不利的条件事先估计到，不能假设一切都是正常的和非常理想的。</li></ul></blockquote></li></ul><h2 id="四层协议"><a href="#四层协议" class="headerlink" title="四层协议"></a>四层协议</h2><ul><li>应用层。<br>  是体系结构的最高层。任务是通过应用进程间的交互来完成特定网络应用。应用层定义的是应用进程间通信和交互的规则。在互联网的应用层协议很多，如<br>  <code>域名系统NDS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议。</code>我们把应用层交互的数据单元称为报文。<ul><li>运输层。<br>负责两台主机中进程之间的通信提供通用的数据传输服务。主要使用两种协议。<ul><li><code>传输控制协议TCP</code>。数据传输的单位是报文段。</li><li><code>用户数据报协议UDP</code>。提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性），数据传输的单位是用户数据报。</li></ul></li><li>网络层。<br>负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组（小报文）或包进行传送。<br>网络层的另外一个任务就是要选择合适的路由，使源主机运输层所传下来的分组（小报文）能够通过路由器找到目的的主机。<code>IP协议</code>。</li><li>数据链路层（链路层）。<br>两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要专门的链路层协议。<br><code>在两个相邻结点之间传送数据时，数据链路层把网络层交下来的IP数据报组装成帧，在两个相邻结点的链路上传送帧，每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制）</code><br>在接收数据时，接收到一个帧，抽出数据部分，提交给网络层。</li></ul></li></ul><h1 id="捋一捋两个主机之间通信的全过程"><a href="#捋一捋两个主机之间通信的全过程" class="headerlink" title="捋一捋两个主机之间通信的全过程"></a>捋一捋两个主机之间通信的全过程</h1><p>主机A向主机B传输数据。</p><ol><li>主机A把数据给应用层，应用层加上必要的控制信息。</li><li>应用层的数据再给运输层，运输层再加上控制信息。</li><li>运输层的数据给网络层，网络层再加上控制信息。</li><li>网络层的数据给链路层，链路层给数据加上首部和尾部。</li><li>链路层再把数据给物理层，物理层传输单位是比特，不加控制信息。</li><li>接着数据到达路由器，路由器分析控制信息。</li><li>路由器的分组（小报文）传给物理层。</li><li>物理层再传给链路层，链路层分析控制信息并剥去，找到上层的网络层。</li><li>网络层接收到数据，分析控制信息并剥去，找到上层的运输层。</li><li>运输层接收到信息，分析并剥去控制信息，找到应用层。</li><li>应用层剥去控制信息，把数据给主机B。</li></ol><p><strong>用一个简单的例子描述：</strong><br>  一封信从最高层向下传，每经过一层就包上一个新的信封，写上必要的地址信息。到达最底层时，向上传，每经过一层就剥去一层信封，到达最高层的时候，去取出发信人的信交给收信人就可以了。</p><h3 id="下一篇文章讲应用层的各种协议，HTTP除外，HTTP是重点应该单拎起来讲。-如果对你有帮助，麻烦点赞加关注哦！"><a href="#下一篇文章讲应用层的各种协议，HTTP除外，HTTP是重点应该单拎起来讲。-如果对你有帮助，麻烦点赞加关注哦！" class="headerlink" title="下一篇文章讲应用层的各种协议，HTTP除外，HTTP是重点应该单拎起来讲。      如果对你有帮助，麻烦点赞加关注哦！"></a>下一篇文章讲应用层的各种协议，HTTP除外，HTTP是重点应该单拎起来讲。      如果对你有帮助，麻烦点赞加关注哦！</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式布局方法总结</title>
      <link href="/2019/11/10/xiang-ying-shi-bu-ju-fang-fa-zong-jie/"/>
      <url>/2019/11/10/xiang-ying-shi-bu-ju-fang-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局。传统的开发方式是PC端开发一套，手机端再开发一套，而使用响应式布局只要开发一套就够。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>面对不同分辨率设备灵活性强</li><li>能够快捷解决多设备显示适应问题<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2></li><li>仅适用布局、信息、框架并不复杂的部门类型网站</li><li>兼容各种设备工作量大，效率低下</li><li>代码累赘，会出现隐藏无用的元素，加载时间加长</li><li>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</li><li>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况<h1 id="响应式与自适应区别"><a href="#响应式与自适应区别" class="headerlink" title="响应式与自适应区别"></a>响应式与自适应区别</h1></li><li>响应式：只需要开发一套代码。<br>  响应式设计通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。</li><li>自适应：需要开发多套界面。<br>  通过检测视口分辨率，来判断当前访问的设备是：pc端、平板、手机，<strong>从而请求服务层，返回不同的页面。</strong></li></ul><h1 id="响应式布局方法一：媒体查询"><a href="#响应式布局方法一：媒体查询" class="headerlink" title="响应式布局方法一：媒体查询"></a>响应式布局方法一：媒体查询</h1><p>使用<code>@media</code>媒体查询可以针对不同的媒体类型定义不同的样式，特别是响应式页面，可以针对不同屏幕的大小，编写多套样式，从而达到自适应的效果。举例来说：</p><pre><code>@media screen and (max-width: 960px){    body{      background-color:#FF6699    }}@media screen and (max-width: 768px){    body{      background-color:#00FF66;    }}@media screen and (max-width: 550px){    body{      background-color:#6633FF;    }}@media screen and (max-width: 320px){    body{      background-color:#FFFF00;    }}</code></pre><p>上述的代码通过媒体查询定义了几套样式，通过max-width设置样式生效时的最大分辨率，上述的代码分别对分辨率在0～320px，320px～550px，550px～768px以及768px～960px的屏幕设置了不同的背景颜色。</p><p>通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局，<strong>比如我们为不同分辨率的屏幕，设置不同的背景图片。比如给小屏幕手机设置@2x图，为大屏幕手机设置@3x图，通过媒体查询就能很方便的实现。</strong></p><p>但是媒体查询的缺点也很明显，如果在<strong>浏览器大小改变时，需要改变的样式太多</strong>，那么多套样式代码会很繁琐。</p><h1 id="响应式布局方法二：百分比"><a href="#响应式布局方法二：百分比" class="headerlink" title="响应式布局方法二：百分比%"></a>响应式布局方法二：百分比%</h1><p>比如当浏览器的宽度或者高度发生变化时，通过百分比单位，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。</p><p>height,width属性的百分比依托于父标签的宽高。但是，<strong>padding、border、margin等属性的情况又不一样？</strong></p><ul><li>子元素的top和bottom如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度，同样，子元素的left和right如果设置百分比，则相对于直接非static定位(默认定位的)父元素的宽度。</li><li>子元素的padding如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width，而与父元素的height无关。</li><li>子元素的margin如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的width</li><li>border-radius不一样，如果设置border-radius为百分比，则是相对于自身的宽度</li></ul><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul><li>计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。 </li><li>各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，而margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。</li><li>所以，<strong>不建议用%来做响应式布局。</strong><h1 id="响应式布局方法三：vw-vh"><a href="#响应式布局方法三：vw-vh" class="headerlink" title="响应式布局方法三：vw/vh"></a>响应式布局方法三：vw/vh</h1>css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度。<br>任意层级元素，在使用vw单位的情况下，1vw都等于视图宽度的百分之一。</li></ul><p>与百分比布局很相似，但更好用。</p><h1 id="响应式布局方法四：rem"><a href="#响应式布局方法四：rem" class="headerlink" title="响应式布局方法四：rem"></a>响应式布局方法四：rem</h1><p>rem单位是相对于字体大小的html元素，也称为根元素。<br>默认情况下，html元素的font-size为16px。所以此时1rem = 16px。</p><h2 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h2><pre><code>@media screen and (max-width: 414px) {  html {    font-size: 18px  }}@media screen and (max-width: 375px) {  html {    font-size: 16px  }}@media screen and (max-width: 320px) {  html {    font-size: 12px  }}</code></pre><p>利用rem和媒体查询，在分辨率发生变换时，给它不同的font-size。</p><h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><pre><code>//动态为根元素设置字体大小function init () {    // 获取屏幕宽度    var width = document.documentElement.clientWidth    // 设置根元素字体大小。此时为宽的10等分    document.documentElement.style.fontSize = width / 10 + &#39;px&#39;}//首次加载应用，设置一次init()// 监听手机旋转的事件的时机，重新设置window.addEventListener(&#39;orientationchange&#39;, init)// 监听手机窗口变化，重新设置window.addEventListener(&#39;resize&#39;, init)</code></pre><p>理解：上面代码实现了，无论设备可视窗口如何变化，始终设置rem为width的1/10.即实现了百分比布局。就没有第一版的媒体查询那样僵硬。</p><blockquote><p>以上代码需在dom之前写入（可放在head里面第一个script标签）</p></blockquote><h1 id="利用UI框架实现响应式布局"><a href="#利用UI框架实现响应式布局" class="headerlink" title="利用UI框架实现响应式布局"></a>利用UI框架实现响应式布局</h1><p>其实，现在的主流UI框架都会考虑到响应式布局这个问题，比如elementUI，iview等框架提供了<strong>栅格</strong>系统，<code>&lt;row&gt;</code>搭配<code>&lt;col&gt;</code>来实现响应式布局。<br>所以在工作中直接拿来使用就完事了。</p><h1 id="移动端响应式布局-viewport"><a href="#移动端响应式布局-viewport" class="headerlink" title="移动端响应式布局 viewport"></a>移动端响应式布局 viewport</h1><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;</code></pre><ul><li>width=device-width: 是自适应手机屏幕的尺寸宽度。</li><li>maximum-scale:是缩放比例的最大值。</li><li>minimum-scale:是缩放比例的最小值。</li><li>inital-scale:是缩放的初始化。</li><li>user-scalable:是用户的可以缩放的操作。</li></ul><blockquote><p>这个写法是用户不能缩放的页面设计。因为，如果页面能缩放的话，就会影响用户的体验，在手机端，我们都可以找到点击的按钮或者自己感兴趣的菜单进行操作。其二：就是我们如果让页面缩放的话，就完全暴露了我们手机app的程序是html的架构了。所以，我们专为移动端的设计页面的时候，就不需要用户进行缩放了。</p></blockquote><h1 id="flexible-js"><a href="#flexible-js" class="headerlink" title="flexible.js"></a>flexible.js</h1><p><code>flexible.js</code>是阿里手淘团队开发的。用来解决移动端的适配问题。    </p><ul><li>假设现在要适配一个iphone6的设备。<ul><li>设计师给了一个750px宽度的设计稿（注意这里是750px而不是375px）</li><li>前端工程师用750px的这个比例开始还原</li><li>把宽高是px的转换成rem</li><li>字体使用px而不使用rem</li><li><code>flexible.js</code>会自动判断dpr进行整个布局视口的放缩  </li></ul></li></ul><pre><code>至于`flexible.js`怎么使用的可以自行搜索，因为本人移动端做得少，就不再多说了。</code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.im/entry/59e70320f265da431c6f6514" target="_blank" rel="noopener">前端移动端适配总结</a> </p><p><a href="https://juejin.im/post/5caaa230e51d452b672f9703" target="_blank" rel="noopener">前端响应式布局原理与方案（详细版</a>   </p><p><a href="https://juejin.im/post/5b39905351882574c72f2808" target="_blank" rel="noopener">响应式布局的常用解决方案对比(媒体查询、百分比、rem和vw/vh）</a></p><p><a href="https://zhongjunhaoz.github.io/">欢迎访问我的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + GitHub 生成个人博客</title>
      <link href="/2019/10/20/hexo-github-sheng-cheng-ge-ren-bo-ke/"/>
      <url>/2019/10/20/hexo-github-sheng-cheng-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章记录一下我生成个人博客的过程。顺便分享给有需要的人。</p><p>如果您需要开发个人博客，需要：</p><ul><li>最基础的前端知识就行。</li><li>用<code>markdown</code>的语法来写文章。</li><li>有<code>GitHub</code>账号。</li><li>安装好了<code>Git</code>和<code>node</code></li><li>知道<code>npm</code>操作。</li></ul><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><p><code>Hexo</code> 是一个快速、简洁且高效的博客框架。<code>Hexo</code>使用 <code>Markdown</code>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p><code>hexo</code> 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在<code>hexo</code>通过<code>markdown</code>编写的文章，然后<code>hexo</code>帮我们生成静态的<code>html</code>页面，然后，将生成的html上传到我们的服务器（或者是GitHub上）。<strong>简而言之：hexo是个静态页面生成、上传的工具</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/16/16dd438b19052027?w=944&h=170&f=png&s=21313" alt=""></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><pre><code>$ npm install hexo-cli -g //全局安装hexo$ hexo init blog //对blog文件夹初始化(这一步会很慢)$ npm install //安装所需要的组件$ hexo g //编译生成静态页面$ hexo s //启动本地服务</code></pre><p>启动本地服务之后，根据终端的提示打开<code>http://localhost:4000/</code>可以在本地查看到博客。如下图所示。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/19/16de1f68dde51b93?w=1887&h=899&f=png&s=1209434" alt=""></p><h2 id="绑定GitHub"><a href="#绑定GitHub" class="headerlink" title="绑定GitHub"></a>绑定GitHub</h2><p>上一步在本地查看到了博客，如果别人想通过在浏览器输入地址来访问你的博客怎么办？</p><p>让你的<code>Hexo</code>与<code>GitHub</code>仓库绑定。这样别人就可以访问了。</p><h3 id="获取本机SSH口令"><a href="#获取本机SSH口令" class="headerlink" title="获取本机SSH口令"></a>获取本机SSH口令</h3><p><code>ssh keys</code>就是用来使本地<code>git</code> 项目与github联系。</p><ul><li><p>提交过代码到<code>GitHub</code>上的同学代表着已经让<code>git</code>仓库绑定到了<code>GitHub</code>上了。就不必再配置<code>SSH 口令了</code>。</p></li><li><p>如果没有绑定的话。</p><ul><li><code>$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; //ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot;</code></li><li>提示<code>Enter passphrase (empty for no passphrase):</code>设置密码</li><li><code>Enter same passphrase again</code> 再次输入</li><li><code>Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub.</code>代表设置成功。</li><li>找到<code>id_rsa.pub</code>文件，复制里面所有内容。</li><li>来到<code>GitHub</code>主页面，路径为<code>Settings/SSH and GPG keys/New SSH key</code>。</li><li><code>Title: blog //不一定非要是blog</code> </li><li><code>key: 复制的内容</code></li><li><code>Add SSH key</code> 完成SSH key 的绑定。</li></ul></li><li><p>最后还要这一步。</p><pre><code>$git config --global user.name &quot;你的名字&quot;$git config --global user.email &quot;你的邮箱&quot;</code></pre></li></ul><blockquote><p>Git还不清楚的同学可以戳<a href="https://juejin.im/post/5d157bf3f265da1bcc1954e6" target="_blank" rel="noopener">Git笔记</a></p></blockquote><h3 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h3><ul><li>平时我们创建仓库会直接写你要创建的仓库名就OK。比如建一个<code>Node</code>的仓库直接填<code>Node</code>就行了。</li></ul><p><strong>但是，博客的仓库地址不一样，必须为<code>你的GitHub名+ github.io</code> 。比如我的博客仓库名就叫做<code>zhongjunhaoz.github.io</code>。必须按照此种格式去填写。</strong></p><h2 id="blog文件的基本配置"><a href="#blog文件的基本配置" class="headerlink" title="blog文件的基本配置"></a>blog文件的基本配置</h2><ul><li>配置<code>_config.yml</code>文件。<pre><code>title: **My Blog** #博客名subtitle: to be continued... #副标题description: My blog #给搜索引擎看的，对网站的描述，可以自定义author: **Yourname** #作者，在博客底部可以看到email: yourname@yourmail.com #你的联系邮箱language: **zh-CN** #中文。如果不填则默认英文timezone: Asia/Shanghai# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: http://yoursite.com# Writing 文章布局、写作格式的定义，不修改# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文# Server 不修改# Date / Time format 日期格式，可以修改成自己喜欢的格式# Pagination 每页显示文章数，可以自定义，贴主设置的是10</code></pre></li></ul><pre><code>- 配置`_config.yml`文件下的`Deploy`</code></pre><p>deploy:<br>  type: git<br>  repository: 你的仓库地址<br>  name: GitHub名<br>  email: 邮箱<br>  branch: master</p><pre><code>- 安装插件`npm install hexo-deployer-git --save`- 准备上传到github仓库。</code></pre><ul><li>hexo clean //清除之前的缓存</li><li>hexo g  // 生成静态文件</li><li>hexo d  //上传至仓库<br>```</li><li>接着在浏览器输入<code>你的GitHub名+ github.io</code>就可以访问你的个人博客了。</li><li><a href="https://zhongjunhaoz.github.io/">https://zhongjunhaoz.github.io/</a>  这是我的个人博客。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/10/19/16de28c0c64ce460?w=1897&h=1005&f=png&s=554623" alt=""></p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>原生的博客主题有点丑，我们可以选择自己喜欢的主题添加到自己的博客中。</p><ul><li>官方主题库：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a></li><li>在这里我选择的是：<a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">闪烁之狐</a>。<strong>里面有对更改主题配置的文档。</strong></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="首次安装可能需要"><a href="#首次安装可能需要" class="headerlink" title="首次安装可能需要"></a>首次安装可能需要</h3><pre><code>npm install hexo -g #全局安装 npm update hexo -g #升级 hexo init #初始化</code></pre><h3 id="写博客最常用"><a href="#写博客最常用" class="headerlink" title="写博客最常用"></a>写博客最常用</h3><pre><code>hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成静态Htmlhexo s == hexo server #会监视文件变动并自动更新，您无须重启服务器hexo d == hexo deploy #部署</code></pre><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><pre><code>hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo server -s #静态模式hexo clean #清除缓存 网页正常情况下可以忽略此条命令</code></pre><h3 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h3><pre><code>hexo generate --watch  #监视文件变动</code></pre><h2 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h2><pre><code>hexo publish [layout] &lt;title&gt;</code></pre><h2 id="网站效果"><a href="#网站效果" class="headerlink" title="网站效果"></a>网站效果</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/20/16de7143fc28e327?w=1898&h=964&f=png&s=1542846" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2019/10/20/16de714eac983fbf?w=1899&h=962&f=png&s=1338643" alt=""></p><p><img src="https://user-gold-cdn.xitu.io/2019/10/20/16de715fadb4cf90?w=1899&h=957&f=png&s=570306" alt=""></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">hexo常用命令笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂CSS中的字体单位大小</title>
      <link href="/2019/10/20/yi-wen-gao-dong-css-zhong-de-zi-ti-dan-wei-da-xiao/"/>
      <url>/2019/10/20/yi-wen-gao-dong-css-zhong-de-zi-ti-dan-wei-da-xiao/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习的过程中,发现CSS有很多可以描述单位的尺寸。比如<code>px</code>,<code>em</code>,<code>rem</code>,<code>vw</code>等等。平时也没有深究，一来是没时间，二来是在我学习清单中优先级过低。一直想彻底弄明白，一直耽搁到现在。现在花上一点时间来整理一下，彻底弄懂它。</p><h1 id="CSS长度单位"><a href="#CSS长度单位" class="headerlink" title="CSS长度单位"></a>CSS长度单位</h1><ul><li>绝对长度单位。<br>绝对长度单位表示为一个固定的值，不会改变。<strong>不利于页面渲染。</strong><ul><li>in,英寸</li><li>cm, 里面</li><li>mm, 毫米</li><li>pt</li><li>pc</li></ul></li><li>相对长度单位。<br>其长度单位会随着它的参考值的变化而变化。<ul><li>px,像素</li><li>em,元素的字体高度</li><li>%,百分比</li><li>rem,根元素的font-size</li><li>vm,视窗宽度，1vw=视窗宽度的1%</li><li>vh,视窗高度，1vh=视窗高度的1%</li></ul></li></ul><h1 id="物理像素-设备像素"><a href="#物理像素-设备像素" class="headerlink" title="物理像素(设备像素)"></a>物理像素(设备像素)</h1><p>比如有一个图片，细分，最小单位就是像素。也就是说，图片由许多的像素构成。像素是小方块，这些小方块都有一个明确的位置和被分配的色彩数值，小方格颜色和位置就决定该图像所呈现出来的样子。</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/25/16c27296fdd981a5?w=261&h=193&f=png&s=102964" alt=""><br><strong>一个设备生产出来，它们的像素就已经确定了。iPhone5的分辨率是<code>640x1136px</code>,代表屏幕由640行，1136列像素小方块组成。</strong></p><pre><code>为了理解像素和避免与CSS像素混淆，可以将物理像素当做物理小方块。比如iPhone5的像素是640X1136px,可以当做640*1136个小方块。</code></pre><h1 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h1><p>也叫做解析度，解像度。可以从显示分辨率与图像分辨率两个方向来分类。</p><ul><li>屏幕分辨率。是屏幕图像的精密度，是指显示器所能显示的像素有多少，即显示器可以可以显示的小方块有多少个。<ul><li><strong>显示器的可显示的小方块越多，画面就越精细，同样的屏幕区域内能显示的信息也越多</strong></li><li>可以把整个图像想象成是一个大型的棋盘，而分辨率的表示方式就是所有经线和纬线交叉点的数目。棋盘的小方块越多，可以放的棋子就越多。</li><li>显示分辨率一定的情况下，显示屏越小图像越清晰，反之，显示屏大小固定时，显示分辨率越高图像越清晰。(<strong>小方块一样多的情况下，显示屏越小越清晰；屏幕大小一样大的时候，小方块越多图形越清晰</strong>)<h1 id="CSS像素px"><a href="#CSS像素px" class="headerlink" title="CSS像素px"></a>CSS像素px</h1>CSS像素的单位也叫做<strong>px</strong>。它是图像显示的基本单元，既不是一个确定的物理量，也不是一个点或者小方块，而是一个抽象概念。所以在谈论像素时一定要清楚<strong>它的上下文！</strong></li></ul></li><li>为了保证阅读体验一致，CSS可以自动在不同设备之间可以调节。即一份代码可以在不同的大小的设备之间显示，并且可以保证阅读体验一致。</li><li>默认情况下一个CSS像素应该是等于一个物理像素的宽度。</li><li>但是在高PPI的设备上，CSS像素甚至在默认状态下就相当于多个物理像素的尺寸。比如iPhone的屏幕对比一般的手机屏幕会看起来更精细清晰一些。</li><li>在浏览器上通过<code>ctrl +/-</code>可以扩大缩小屏幕，其实就是屏幕分辩率的调低/调高。<code>ctrl +</code>屏幕放大，分辨率降低。</li><li>iPhone6,7,8都是两倍屏手机，即一个CSS像素等于2物理像素。iPhone6Plus等是三倍屏手机，一个CSS像素等于3物理像素。</li><li>以iPhone6为例，设计稿给出一个图片宽高为40*40。在实际开发中要除以2，宽高要写成20x20。因为iPhone6是两倍屏手机。</li></ul><h1 id="em"><a href="#em" class="headerlink" title="em"></a>em</h1><p>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，<strong>则相对于浏览器的默认字体尺寸,浏览器字体默认为16px</strong>。</p><ul><li>所以，1em = 16px。默认情况下。<h2 id="如何高效使用em呢"><a href="#如何高效使用em呢" class="headerlink" title="如何高效使用em呢"></a>如何高效使用em呢</h2></li><li>body里声明font-size:62.5%。即全局声明<code>1em = 16px * 62.5% = 10px</code></li><li>之后可以把<code>em</code>当做<code>px</code>使用。当然此时，<code>1em = 10px</code></li><li>如果在父容器里说明了<code>font-size:20px</code>,那么在子容器里的<code>1em</code>就等于<code>20px</code>。</li></ul><h1 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h1><p>rem单位是相对于字体大小的<strong>html元素</strong>，也称为根元素。</p><pre><code>html {  font-size: 10px; /* 不建议设置 font-size: 62.5%; 在 IE 9-11 上有偏差，具体表现为 1rem = 9.93px。 */}.sqaure {  width: 5rem;  /* 50px */  height: 5rem; /* 50px */}</code></pre><h1 id="em与rem"><a href="#em与rem" class="headerlink" title="em与rem"></a>em与rem</h1><ul><li>rem是相对于根元素（html）的字体大小，而em是相对于其父元素的字体大小。</li><li>em最多取到小数点的后三位<pre><code>&lt;style&gt;html{ font-size: 20px; }body{   font-size: 1.4rem;  /* 1rem = 28px */  padding: 0.7rem;  /* 0.7rem = 14px */} div{  padding: 1em;  /* 1em = 28px */}span{  font-size:1rem;  /* 1rem = 20px */  padding: 0.9em;  /* 1em = 18px */}&lt;/style&gt;</code></pre></li></ul><html>  <body>    <div>         <span></span>      </div>  </body></html>```上面的例子中，发现了一个有意思的情况。`em 会层层继承父元素的字体大小`，很容易造成字体大小的混乱。所以以后用`rem`会更好。<h1 id="rpx"><a href="#rpx" class="headerlink" title="rpx"></a>rpx</h1><p><strong>rpx 是微信小程序解决自适应屏幕尺寸的尺寸单位。微信小程序规定屏幕的宽度为750rpx。</strong></p><p>无论是在iPhone6上面还是其他机型上面都是750rpx的屏幕宽度，拿iPhone6来讲，屏幕宽度为375px，把它分为750rpx后， 1rpx = 0.5px = 1物理像素。</p><p><img src="https://user-gold-cdn.xitu.io/2019/7/25/16c29bee71b0c4c4" alt=""></p><h1 id="vw-和-vh"><a href="#vw-和-vh" class="headerlink" title="vw 和 vh"></a>vw 和 vh</h1><ul><li><code>vw</code>,视窗宽度，1vw=视窗宽度的1%</li><li><code>vh</code>,视窗高度，1vh=视窗高度的1%</li><li>如果浏览器的高是900px,1vh求得的值为9px。同理，如果显示窗口宽度为750px,1vw求得的值为7.5px。</li></ul><h1 id="vmin-和-vmax"><a href="#vmin-和-vmax" class="headerlink" title="vmin 和 vmax"></a>vmin 和 vmax</h1><ul><li>vmin和vmax是相对于视口的高度和宽度两者之间的最小值或最大值。</li><li>浏览器的高为1100px、宽为700px，那么1vmin就是7px，1vmax就是11px</li><li>浏览器的高为800px，宽为1080px，那么1vmin也是8px，1vmax也是10.8px</li><li>vmin取宽度高度两者更小者/100</li><li>vmax取宽度高度两者更大者/100<h2 id="哪些地方可以用到"><a href="#哪些地方可以用到" class="headerlink" title="哪些地方可以用到"></a>哪些地方可以用到</h2></li><li>一个总是在屏幕上可见的元素。使用高度和宽度设置为低于100的vmin值将可以实现这个效果。</li><li>一个总是覆盖可视窗口的正方形(一直接触屏幕的四条边)<pre><code>.box {  height: 100vmax;  width: 100vmax;}</code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><a href="https://github.com/wujunchuan/wujunchuan.github.io/issues/15" target="_blank" rel="noopener">前端开发中像素的概念</a></li></ul><p><a href="http://www.360doc.com/content/19/0327/15/63018409_824523443.shtml" target="_blank" rel="noopener">最全的CSS尺寸单位介绍</a></p><p><a href="http://www.divcss5.com/css3-style/c33196.shtml" target="_blank" rel="noopener">CSS3中常见的单位</a><br><a href="http://www.mamicode.com/info-detail-2439333.html" target="_blank" rel="noopener">移动设备分辨率（终于弄懂了为什么移动端设计稿总是640px和750px）</a></p><p><a href="https://www.jianshu.com/p/e377208aaadd" target="_blank" rel="noopener">几个CSS的单位你需要了解一下</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack入门(3) - 核心内容</title>
      <link href="/2019/10/20/webpack-ru-men-3-he-xin-nei-rong/"/>
      <url>/2019/10/20/webpack-ru-men-3-he-xin-nei-rong/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5d19a847518825793f6fcd9f" target="_blank" rel="noopener">webpack入门(2)-安装，配置，环境</a>，上节传送门。</p><h1 id="Entry-入口"><a href="#Entry-入口" class="headerlink" title="Entry(入口)"></a>Entry(入口)</h1><p>简单提一下，Entry是webpack的入口文件，一开始运行webpack它会找到<code>webpack.config.js</code>里的<code>Entry</code>。它会从这开始着手，构建内部依赖图。入口点可以有一个或多个。</p><h2 id="entry的类型"><a href="#entry的类型" class="headerlink" title="entry的类型"></a>entry的类型</h2><ul><li>string类型<pre><code>一个入口entry:&#39;./src/main.js&#39;</code></pre></li><li>array类型<pre><code>配置了多个入口entry: [&#39;./src/main1.js&#39;, &#39;./src/main2.js&#39;]</code></pre></li><li>object类型<pre><code>对象类型entry: {  a: &#39;./src/main.js&#39;,  b: [&#39;./src/main1.js&#39;, &#39;./src/main2.js&#39;]}</code></pre></li><li>多个入口时，每个入口生成都会生成Chuck。</li><li>如果是array类型，则搭配output.library配置项使用时，只有数组里的最后一个入口文件会被导出。</li></ul><h2 id="配置动态Entry"><a href="#配置动态Entry" class="headerlink" title="配置动态Entry"></a>配置动态Entry</h2><p>假如项目里有多个页面需要为每个页面的入口配置一个entry，但这些页面数量可能会不断增长，这时entry的配置会受到其他因素的影响导致不能写成静态的值。解决办法就是把entry设置成一个函数去动态返回上面所说的配置：</p><pre><code>//同步函数entry: () =&gt; {    return {        a: &#39;./pages/a&#39;,        b: &#39;./pages/b&#39;    }}//异步函数entry: () =&gt; {    return new Promise((resolve) =&gt; {        resolve({            a: &#39;./pages/a&#39;,            b: &#39;./pages/b&#39;        })    })}</code></pre><h1 id="output"><a href="#output" class="headerlink" title="output"></a>output</h1><p>Output属性告诉webpack在哪里输出它所创建的bundles，也可指定bundles的名称，默认位置为./dist。整个应用结构都会被编译到指定的输出文件夹中去，你可以通过在配置中指定一个 output 字段，来配置这些处理过程。最基本的属性包括filename（文件名）和path（输出路径）。</p><h2 id="Chuck的名称"><a href="#Chuck的名称" class="headerlink" title="Chuck的名称"></a>Chuck的名称</h2><p>向上面的<code>main.js</code>中，<code>main</code>就是Chuck名称。<strong>Chunk的名称和Entry的配置有关。</strong></p><ul><li>如果entry是<code>string</code>类型或者是<code>array</code>类型，只会生成一个Chuck。</li><li>如果entry是一个<code>object</code>,就可能出现多个<code>chunk</code>,这时候的<code>chunk</code>值是<code>object</code>名称。比如上面的<code>a.js</code>,<code>b.js</code>。Chuck名称在<code>output</code>可以配置。<h2 id="多个入口时怎么配置filename"><a href="#多个入口时怎么配置filename" class="headerlink" title="多个入口时怎么配置filename"></a>多个入口时怎么配置filename</h2>当通过多个入口起点(entry point)、代码拆分(code splitting)或各种插件(plugin)创建多个 bundle的时候，可以有以下几种赋bundle名称的方式。</li><li>使用入口名称赋值,[name]为entry的key值,比如<code>a.bundle.js</code>,<code>b.bundle.js</code><pre><code>filename: &quot;[name].bundle.js&quot;</code></pre></li><li>使用内部 chunk id,从0开始<pre><code>filename: &quot;[id].bundle.js&quot;</code></pre></li><li>使用每次构建过程中，都会生成一段Hash值<pre><code>filename: &quot;[name].[hash].bundle.js&quot;</code></pre></li><li>使用基于每个 chunk 内容的 hash值，可以理解为版本号(Git里面的)或者md5值。<strong>文件内容发生改变，chunkhash就会改变。在这里可以用到：项目上线，只上线那些被改过的文件</strong><pre><code>filename: &quot;[chunkhash].bundle.js&quot;</code></pre><pre><code>取5位Hash值，默认为20位。filename: &quot;[chunkhash:5].bundle.js&quot;</code></pre><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2>output.path 配置输出文件存放在本地的目录，必须是 <code>string</code> 类型的<strong>绝对路径</strong>。通常通过 Node.js 的 path 模块去获取绝对路径：<pre><code>path: path.resolve(__dirname, &#39;dist_[hash]&#39;)</code></pre><code>__dirname</code>就是当前文件所在的文件夹的名字。<h2 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h2>对构建出的资源进行异步加载（图片，文件）。加载这些异步资源需要对应的 URL 地址。默认值是空字符串“ ”。<strong>简单说，就是静态文件托管在cdn上。</strong><br>如果你这么配置：<pre><code>output:{  filename:&#39;[name]_[chunkhash:8].js&#39;,  publicPath:&#39;https://www.qdtalk.com/assets/&#39;}</code></pre>打包编译之后，HTML页面就变成了这个：<pre><code>&lt;script src=&quot;https://www.qdtalk.com/assets/a_12345678.js&quot;&gt;&lt;/script&gt;</code></pre>上面只是举了output的几个常用参数。</li></ul><h1 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h1><p><code>Loader</code>在webpack中承担<strong>翻译</strong>的工作。<br>因为<code>webpack</code>自身只支持加载<code>js</code>和<code>json</code>文件，把源文件转化翻译后输出新结果，且一个文件还可以链式的经过<strong>多个翻译员翻译</strong>。</p><p>以处理SCSS文件为例：</p><ul><li><code>SCSS</code> 源代码会先交给 <code>sass-loader</code> 把 <code>SCSS</code> 转换成 <code>CSS</code>；</li><li>把 <code>sass-loader</code> 输出的 <code>CSS</code> 交给 <code>css-loader</code> 处理，找出 <code>CSS</code> 中依赖的资源、压缩 <code>CSS</code> 等；</li><li>把 <code>css-loader</code> 输出的 <code>CSS</code> 交给 <code>style-loader</code> 处理，转换成通过脚本加载的 JavaScript 代码。<h2 id="常用的Loader"><a href="#常用的Loader" class="headerlink" title="常用的Loader"></a>常用的Loader</h2></li><li>样式：<code>style-loader、css-loader、less-loader、sass-loader</code>等。</li><li>文件：<code>raw-loader、file-loader 、url-loader</code>等</li><li>编译：<code>babel-loader、coffee-loader 、ts-loader</code>等</li><li>校验测试：<code>mocha-loader、jshint-loader 、eslint-loader</code>等</li><li><code>vue-loader、coffee-loader、babel-loader</code>等可以将特定文件格式转成js模块、将其他语言转化为js语言和编译下一代js语言</li><li><code>file-loader、url-loader</code>等可以处理资源，<code>file-loader</code>可以复制和放置资源位置，并可以指定文件名模板，用hash命名更好利用缓存。</li><li><code>url-loader</code>可以将小于配置limit大小的文件转换成内敛Data Url的方式，减少请求。</li><li><code>raw-loader</code>可以将文件已字符串的形式返回</li><li><code>imports-loader、exports-loader</code>等可以向模块注入变量或者提供导出模块功能</li><li><code>expose-loader</code>:暴露对象为全局变量<h2 id="安装Loader"><a href="#安装Loader" class="headerlink" title="安装Loader"></a>安装Loader</h2>以安装css-loader和style.loader为例，直接在终端：<pre><code>npm install css-loader style-loader --save-dev</code></pre><h2 id="配置单个Loader"><a href="#配置单个Loader" class="headerlink" title="配置单个Loader"></a>配置单个Loader</h2><code>webpack.config.js</code>中<pre><code>module.exports = {  module: {      rules: [          {              test: /\.css$/,              use: &#39;css-loader&#39;          }      ]  }}</code></pre></li><li>test:后面接一个正则表达式，表示有那些后缀文件被处理。</li><li>use：表示应该用什么loader。</li></ul><h2 id="配置多个loader"><a href="#配置多个loader" class="headerlink" title="配置多个loader"></a>配置多个loader</h2><pre><code>module.exports = {    module: {        rules: [            {                test: /\.css$/,                use: [                    {                        loader: &#39;style-loader&#39;                    },                    {                        loader: &#39;css-loader&#39;                    }                ]            }        ]    }}</code></pre><h2 id="其他配置方法"><a href="#其他配置方法" class="headerlink" title="其他配置方法"></a>其他配置方法</h2><ul><li>直接在命令行<pre><code>webpack --module-bind &#39;txt=raw-loader&#39;</code></pre></li><li>内联<pre><code>import txt from &#39;raw-loader!./file.txt&#39;</code></pre>但这两种方法都不推荐。还是在<code>webpack.config.js</code>配参数更好。</li></ul><h2 id="几个重要的loader"><a href="#几个重要的loader" class="headerlink" title="几个重要的loader"></a>几个重要的loader</h2><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p><code>Babel</code> 可以让你使用<code>ES2015/16/17</code> 写代码而不用顾忌浏览器的问题，<code>Babel</code> 可以帮你转换代码。</p><ul><li>安装几个必要的<code>Babel</code>库,<pre><code>npm i --save-dev babel-loader babel-core babel-preset-env</code></pre>   babel-loader让webpack去处理一些使用了es6的js文件。<br>   babel-core 提供一系列API，其实是让babel-loader去调用babel-core的API。<br>   babel-preset-env 这个库可以根据环境的不同转换代码</li><li>配置babel规则。在<code>package.json</code>里面增加一个<code>babel属性</code>。作用是设置项目中的babel转码规则和使用到的babel插件，格式如下：<pre><code>&quot;babel&quot;:{&quot;presets&quot;: [&quot;evn&quot;],//设定转码规则&quot;plugins&quot;: []//要用到的插件}</code></pre>表示告诉npm，在本项目中将使用babel，并且使用<code>babel-preset-env</code>规则进行转码。</li><li>除了上一种写法外，还有另外一种方法(<strong>推荐写法</strong>)。在根目录下面新建<code>.babelrc</code>文件，然后做一下配置：<pre><code>{&quot;presets&quot;: [&quot;babel-preset-env&quot;]}</code></pre></li></ul><pre><code>- 上面已经配置好`babel`的规则，但是`webpack`依然不知道何时使用该规则。我们还要再接着在配置里写入</code></pre><p>use: ‘babel-loader’</p><pre><code>**但要注意的是**，只有`js`文件才可以使用`babel`。### 处理图片- `npm i --save-dev url-loader file-loader`- 在`webpack.config.js`里面修改配置：</code></pre><p>test: /.(png|jpe?g|gif|svg)(?.*)?$/,<br>use : [<br>  {<br>     loader: ‘url-loader’,<br>     options: {<br>      // 限制 图片大小 10000B，小于限制会将图片转换为 base64格式<br>         limit: 10000,<br>      // 超出限制，创建的文件格式<br>      // build/images/[图片名].[hash].[图片格式]<br>         name: ‘images/[name].[hash].[ext]’<br>    }<br>  }<br>]</p><pre><code># Plugins(插件)插件用来拓展webpack功能，可以用于执行范围更广的任务，包括**打包、优化、压缩、搭建服务器**等等，功能十分强大。**要是用一个插件，一般是先使用npm包管理器进行安装，然后在配置文件webpack.config.js中require引入，最后在这个文件下使用new来创建一个实例。**   Loader一次只能处理单个相同类型的文件，但是plugins可以对整个过程起作用。## 常用的plugin插件- webpack内置`UglifyJsPlugin`插件，压缩和混淆代码。- webpack内置`CommonsChunkPlugin`，提高打包效率，将第三方库和业务代码分开打包- `ProvidePlugin`：自动加载模块，代替`require`和`import`- `html-webpack-plugin`可以根据模板自动生成html代码，并自动引用css和js文件- `extract-text-webpack-plugin` 将js文件中引用的样式单独抽离成css文件- `DefinePlugin` 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。- `HotModuleReplacementPlugin `热更新- `optimize-css-assets-webpack-plugin` 不同组件中重复的css可以快速去重- `webpack-bundle-analyzer` 一个webpack的bundle文件分析工具，将bundle文件以可交互缩放的treemap的形式展示- `compression-webpack-plugin` 生产环境可采用gzip压缩JS和CSS- `happypack`：通过多进程模型，来加速代码构建## 一个简单的插件使用- `npm install --save-dev html-webpack-plugin`安装一个插件。有的插件webpack自带，如果没有，则需用npm安装。- `const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);`在webpack.config.js中引入。- new一个实例</code></pre><p>plugins: [</p><p>  new HtmlWebpackPlugin({<br>  template: ‘./src/index.html’, //以src目录下的index.html文件为模板生成html5新文件<br>  filename: ‘index.html’,//指定生成的HTML文件叫啥名<br>  inject: ‘head’,//指定把脚本script标签放在那里，这里放在<head>标签里。还可以放<body><br>  })<br>]</p><pre><code>## 利用html-webpack-plugin插件自动生成html文件### 为什么要自动生成HTML每次执行webpack打包生成js文件后，都必须在index.html中手动插入打包好的文件的路径。**但在真实生产环境中，一次运行webpack后，完整的index.html应该是被自动生成的。** 例如静态资源、js 脚本都被自动插入了。### 根目录下的index.html文件根目录下的index.html会被html-webpack-plugin作为最终生成的 html 文件的模板。打包后，相关引用关系和文件路径都会按照正确的配置被添加进去。### 配置</code></pre><p>const HtmlWebpackPlugin = require(“html-webpack-plugin”);</p><p>module.exports = {<br> entry: {<br>    app: “./src/app.js”<br>  },<br>  output: {<br>    publicPath: <strong>dirname + “/dist/“,<br>    path: path.resolve(</strong>dirname, “dist”),<br>  },<br>    plugins: [<br>    new HtmlWebpackPlugin({<br>      filename: “index.html”,<br>      template: “./index.html”,<br>      chunks: [“app”], // entry中的app入口才会被打包<br>      minify: {<br>        // 压缩选项<br>        collapseWhitespace: true<br>      }<br>    })<br>  ]<br>}</p><pre><code>最后执行打包命令，然后在dist目录下就给你自动生成了index.html文件。dist目录下的index.html文件是以根目录下的inde.html文件为模板的。# 其他几个核心概念## Module(模块)对于webpack，模块不仅仅是javascript模块，它包括了任何类型的源文件，不管是图片、字体、json文件都是一个个模块。**Webpack支持以下的方式引用模块：**- ES2015 import 方法- CommonJs require() 方法- AMD define 和 require 语法- css/sass/less文件中的 @import 语法- url(...)和 &lt;img src=&quot;&quot;&gt;的图片路径## Dependency Graph（依赖关系图）所谓的依赖关系图是webpack根据每个模块之间的依赖关系递归生成的一张内部逻辑图，有了这张依赖关系图，webpack就能按图索骥把所有需要模块打包成一个bundle文件了。## Mode(模式)分为开发模式`development`和生产模式`production` 。两种模式的区别在于一个是为生产环境编译打包，一个是为了开发环境编译打包。生产环境模式下，webpack会自动对代码进行压缩等优化，省去了配置的麻烦。## 结语webpack断断续续终于算是入门了。与其他技能点相比，webpack算是比较酸涩难懂。但是学无止境，我学webpack的还有很长的路要走。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack入门(2) - 安装，配置，环境搭建</title>
      <link href="/2019/10/20/webpack-ru-men-2-an-zhuang-pei-zhi-huan-jing-da-jian/"/>
      <url>/2019/10/20/webpack-ru-men-2-an-zhuang-pei-zhi-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5d1867c76fb9a07eec59dfa6" target="_blank" rel="noopener">webpack入门(1)-“图解什么是webpack”</a>传送门</p><h1 id="初始化和安装"><a href="#初始化和安装" class="headerlink" title="初始化和安装"></a>初始化和安装</h1><ul><li>在工作目录新建一个文件夹</li><li><code>npm init</code> 初始化一个文件夹,出现对话框按确定就行。</li><li><code>npm install --global webpack</code> 全局安装，在c盘下会生成node_modules文件夹中会包含webpack。<code>请注意，这不是推荐的做法。全局安装会将您锁定到特定版本的webpack，并且在使用不同版本的项目中可能会失败。</code>官方并不推荐全局安装。</li><li><code>npm install --save-dev webpack</code> 安装在本地开发环境中</li><li><code>npm install --save-dev webpack-cli</code> webpack4之后要安装cli。把cli安装到开发环境中。</li><li><code>-D</code>就是<code>--save-dev</code>的缩写</li></ul><h1 id="打包一个简单的文件"><a href="#打包一个简单的文件" class="headerlink" title="打包一个简单的文件"></a>打包一个简单的文件</h1><ul><li>在文件夹下新建一个<code>src</code>文件,下面新建一个<code>main.js</code>文件。</li><li>根目录下新建一个<code>webpack.config.js</code>文件。为什么要建这个文件，因为直接使用<code>webpack</code>，它会寻找<code>webpack.config.js</code>把它当成默认的配置去运行。此时它不需要指定任何参数，就能读取里面的内容。<pre><code>// webpack.config.jsmodule.exports = {  entry: __dirname + &#39;/src/main.js&#39;,//我指定了入口文件，在src/main.js  output: {       path: __dirname + &#39;/dist&#39;, //打包后指定存放的目录,放在dist      filename: &#39;bundle.js&#39; //打包后的文件叫bundle.js  }}</code></pre></li></ul><blockquote><p>__dirname是Node.js中一个全局变量，它指向当前执行脚本所在的目录。<br>有多个入口文件的时候：<br><img src="https://user-gold-cdn.xitu.io/2019/7/3/16bb7d1cd83ec193?w=965&h=626&f=png&s=77448" alt=""></p></blockquote><ul><li>如果你一开始你就不想运行默认的<code>webpack.config.js</code>,你想运行其他的配置文件,比如<code>config.js</code>文件。你可以运行<code>webpack --config config.js</code>,这样它就会寻找<code>config.js</code>，并且运行它。</li><li>运行<code>webpack</code>，它会自动的寻找<code>webpack.config.js</code>，找到其中的入口文件比如上面的<code>main.js</code>。</li><li>如果你想有些个性化的需求，你想看到打包的进度，打包的模块，模块的信息，打包的原因。你可以输入以下的命令。<ul><li><code>webpack --progress</code>可以看到打包的进度。</li><li><code>webpack --progress --display-modules</code> 可以看到打包有几个模块，模块的信息。</li><li><code>webpack ---progress --display-modules --display-reasons</code> 打包的原因显示出来。</li></ul></li><li>但是这种方法太过繁琐，你要在命令行输入这么多东西。那么有没有更轻松的方法呢？<strong>有的！</strong><ul><li>在你初始化的时候，系统会自动生成<code>package.json</code>。现在找到根目录下的<code>package.json</code>文件。<br><img src="https://user-gold-cdn.xitu.io/2019/7/1/16bad8c1ca6b5add?w=514&h=294&f=png&s=18781" alt=""></li><li>在里面的<code>scripts</code>下添加定义一个脚本，<pre><code>&quot;dev&quot;:&quot;webpack --config webpack.config.js --progress --display-modules --colors --display-reasons&quot;</code></pre></li><li>最后在命令行运行<code>npm run dev</code></li></ul>  <strong>因为scripts脚本提供了命令的“别名”，像上面的以一个“dev”命令代替了一连串的命令，使用起来更为方便</strong>,即便你没有在命令行输入以上的配置，你依然可以看到打包的进度；以看到打包有几个模块，模块的信息；字体为彩色；打包的原因。因为你在配置文件下定义了，就不需要了。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/7/3/16bb5173b3f3e78e?w=578&h=714&f=png&s=97412" alt=""></p><h1 id="更快捷的执行打包任务"><a href="#更快捷的执行打包任务" class="headerlink" title="更快捷的执行打包任务"></a>更快捷的执行打包任务</h1><ul><li>最原始的执行打包任务，可以使用命令<code>webpack main.js bundle.js</code>在这个例子当中，<code>main.js</code>是入口文件，<code>bundle.js</code> 打包完之后的文件。</li><li>第二种，我们可以在<code>webpack.config.js</code>里写配置。<pre><code>module.exports = {entry:  __dirname + &quot;/app/main.js&quot;,//唯一入口文件output: {  path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方  filename: &quot;bundle.js&quot;//打包后输出文件的文件名}}</code></pre>我们只需要输入<code>webpack</code>命令，webpack就能自己找到<code>webpack.config.js</code>，在找出入口，找到output,执行打包。</li><li>第三种，继承第二种。更简单快捷的执行打包。在<code>package.json</code>里找到“scripts”脚本，添加<pre><code>&quot;start&quot;: &quot;webpack --config webpack.config.js --progress --display-modules --colors --display-reasons&quot;</code></pre>然后我们只需要<code>npm start</code>就可以打包了。<pre class=" language-!"><code class="language-!">需要注意的是,“start”在npm中比较特殊，只需npm start 就可以执行命令。如果是非start,还要再在前面加上一个run ,比如npm run dev,npm run build</code></pre></li></ul><h1 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h1><h2 id="使用source-maps进行调试调试"><a href="#使用source-maps进行调试调试" class="headerlink" title="使用source maps进行调试调试"></a>使用source maps进行调试调试</h2><h3 id="为何要使用source-maps？"><a href="#为何要使用source-maps？" class="headerlink" title="为何要使用source maps？"></a>为何要使用source maps？</h3><p>因为<code>webpack</code>对源代码进行打包后，会对源代码进行压缩、精简、甚至变量名替换，在浏览器中，无法对代码逐行打断点进行调试，所有需要使用<code>source maps</code>进行调试，它使得我们在浏览器中可以看到源代码，进而逐行打断点调试。</p><h3 id="如何使用source-maps？"><a href="#如何使用source-maps？" class="headerlink" title="如何使用source maps？"></a>如何使用source maps？</h3><p>在配置中添加<code>devtool</code>属性，赋值为<code>source-map</code>或者<code>inline-source-map</code>即可，后者报错信息更加具体，会指示源代码中的具体错误位置，而<code>source-map</code>选项无法指示到源代码中的具体位置。</p><h2 id="使用开发工具"><a href="#使用开发工具" class="headerlink" title="使用开发工具"></a>使用开发工具</h2><p>用开发工具可以简化开发过程的工作。比如你写完代码后保存开发工具可以自动帮你执行一系列的命令。</p><h3 id="watch模式"><a href="#watch模式" class="headerlink" title="watch模式"></a>watch模式</h3><p>在使用<code>webpack-cli</code>进行打包时，通过命令<code>webpack --watch</code>即可开启<code>watch</code>模式，进入<code>watch</code>模式之后，一旦依赖树中的某一个模块发生了变化，<code>webpack</code>就会重新进行编译。</p><h3 id="使用webpack-dev-server"><a href="#使用webpack-dev-server" class="headerlink" title="使用webpack-dev-server"></a>使用webpack-dev-server</h3><p>浏览器监听你的代码的修改，并自动刷新显示修改后的结果。它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖。</p><ul><li>安装。<code>npm install --save-dev webpack-dev-server</code></li><li>修改配置文件，添加<code>devServer</code>属性<pre><code>// webpack.config.jsmodule.exports = {    devServer: {        contentBase: &#39;./dist&#39;,//本地服务器所加载的页面所在目录        historyApiFallback: true,//不跳转        inline: true //实时刷新    }};</code></pre></li><li>在<code>package.json</code> 添加脚本<pre><code>// package.json{    &quot;scripts&quot;: {        &quot;start&quot;: &quot;webpack-dev-server --open&quot;    }}</code></pre></li><li>运行命令<br><code>npm run start</code>即可在本地的8080端口查看结果。</li><li>搭建开发环境远不止这些内容，我只挑了我在学习过程中经常用到的地方，或者我觉得重要的地方。</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>webpack很难啃，我是在网上找资料看视频，一点一点摸索。网上的资料时间维度大，有的还在讲webpack1.0,有的在讲最新版的webpack,<strong>所以在整理的时候难免有出错的地方。欢迎在下方评论指出错误！</strong>  </p><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack入门(1) - 图解Webpack是什么</title>
      <link href="/2019/10/20/webpack-ru-men-1-tu-jie-webpack-shi-shi-me/"/>
      <url>/2019/10/20/webpack-ru-men-1-tu-jie-webpack-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>毫无疑问，Webpack在前端中有着独特的重要性，是你必须要熟悉的一个技能点。因为你在投简历浏览一些大公司的<strong>前端岗位</strong>时，Webpack毫无疑问是写明了至少要是<strong>熟悉Webpack</strong>。我在学Webpack期间，常常被它的配置，环境给绕晕了,现在重新开始学一遍，希望我可以掌握它。本着分享学习的态度，记录下我学习的过程，希望可以对一些初学Webpack的同学提供一点帮助。</p><h1 id="Webpack使用原因和定义"><a href="#Webpack使用原因和定义" class="headerlink" title="Webpack使用原因和定义"></a>Webpack使用原因和定义</h1><p>我相信很多刚开始学<code>Webpack</code>的同学在学之前一定疯狂的在各大论坛或者百度搜索“什么是<code>Webpack</code>”，因为我就是这么干的。但是一些大牛的文章在提及什么是<code>Webpack</code>的时候总是一笔带过，看完之后也是云里雾里，迷迷糊糊。现在我用自己的语言来解释什么是<code>Webpack</code>。在此之前，还要向大家解释为什么要使用<code>Webpack</code>:</p><h2 id="为什么要使用Webpack"><a href="#为什么要使用Webpack" class="headerlink" title="为什么要使用Webpack"></a>为什么要使用Webpack</h2><p>我们都知道一个大公司的网站往往做的都很炫酷，美观，功能很齐全。在这背后前端工程师花了很大的精力去做优化什么的。大型网站和大型项目中的背后都拥有着复杂的JS代码和很多依赖。<strong>为了简化开发的复杂度，往往对程序切割分裂为不同的模块。</strong><br><img src="https://user-gold-cdn.xitu.io/2019/6/30/16ba776df3057afd?w=390&h=486&f=png&s=22381" alt=""><br>如图所示，把大型项目切割成很多不同的模块。那么，里面的箭头是怎么回事，我觉得可以理解为<code>require</code>。因为两个文件之间相互通联是靠<code>require</code>连接的。好比如，<code>html</code>文件利用<code>link</code>中引入样式一样。<code>webpack</code>整合了项目里的模块打包的更为精简。所以我们需要<code>webpack</code>。</p><ul><li>Webpack分析大型项目的结构</li><li>找到JS模块以及浏览器不能直接运行的模块(cjs,Sass,hbs等等)</li><li>将浏览器不能直接处理的文件转换和打包为合适的格式供浏览器直接处理。</li><li>这样前端工程师既可以更轻松系统的开发，浏览器也能更高效流畅的运行。</li></ul><h2 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/30/16ba78866fc440b7?w=1284&h=566&f=png&s=65325" alt=""><br>上面已经提到了<code>Webpack</code>的工作流程，我在举一个<strong>不怎么严谨</strong>的例子你们也许就能明白。<br><code>假如你去饭店吃饭，点完菜后你觉得把菜打包回寝室吃更爽一些。你点了很多菜，这些菜有麻辣的，酸辣的，甜的，还有水果，小糕点不同的口味。考虑到你的室友有的喜欢吃辣的，有的喜欢吃甜的，有的喜欢吃水果。如果全部的菜混在一起可能室友都不喜欢，你决定不混在一起，而是按照口味混在一起。把辣的菜混到一起，把甜的菜混到一起，把水果混到一起。这样你的室友就能够接受了。</code></p><p><img src="https://user-gold-cdn.xitu.io/2019/7/1/16bab1b71034272a?w=1097&h=606&f=png&s=70391" alt=""></p><p><code>结合上面webpack的工作流程，可以这样说：webpack分析大型项目的结构即分析这些菜是哪些口味；找到浏览器不能直接运行的模块，即分析哪些是你室友不能接受的口味；将浏览器不能直接处理的文件转换和打包为合适的格式供浏览器处理即将菜分类打包让你的室友可以接受。</code><br>结合上面的图，应该把<code>Webpack</code>的运行流程搞清楚了。</p><h1 id="webpack工作流程"><a href="#webpack工作流程" class="headerlink" title="webpack工作流程"></a>webpack工作流程</h1><p>用文字叙述不直观，我尽量用图形的方式来说明。首先先说明依赖就是本文第一张图里面的箭头。<br><img src="https://user-gold-cdn.xitu.io/2019/7/1/16bab14c0a750e74?w=570&h=796&f=png&s=82861" alt=""></p><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员都要掌握的Git</title>
      <link href="/2019/10/20/cheng-xu-yuan-du-yao-zhang-wo-de-git/"/>
      <url>/2019/10/20/cheng-xu-yuan-du-yao-zhang-wo-de-git/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是参考廖雪峰老师的Git资料再加上我自己对Git的理解，记录我的Git学习历程，作下此文是为以后学习，工作，开发中如果遇到问题可以回过头来参考参考。因为水平有限，难免会有出错的地方，欢迎指正。</p><h1 id="Git是什么"><a href="#Git是什么" class="headerlink" title="Git是什么"></a>Git是什么</h1><ul><li>官方话：Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。</li><li>引用廖雪峰老师的话，它能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以。</li></ul><h1 id="为什么要学习Git"><a href="#为什么要学习Git" class="headerlink" title="为什么要学习Git"></a>为什么要学习Git</h1><ul><li>面试要被问。可以应付面试。</li><li>很多公司开发都用Git来处理项目。现在不学，以后肯定还要学。</li><li>在我看来Git是现如今所有程序员都要掌握的，以后与同事共同开发项目必定要用到的，熟练掌握Git命令，可以提高开发的效率。。</li></ul><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><ul><li>Windows<br>直接在官网上去下载。下载完成后，随便在某个文件下右键如果有Git Bash Here就安装成功。安装后，还要在命令行输入<pre><code>$git config --global user.name &quot;你的名字&quot;$git config --global user.email &quot;你的邮箱&quot;</code></pre><code>global</code>表示全局，这台机器所有的Git仓库都会使用这个配置。允许单个仓库使用其他的名字和邮箱。</li><li>Mac<br>评论区指出Mac也可以像Windows一样，按上面的步骤安装。<br>也可以直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</li></ul><h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9d385970c7b6c?w=987&h=495&f=png&s=247329" alt=""></p><ul><li>本地仓库是对于远程仓库而言的。</li><li>本地仓库 = 工作区 + 版本区</li><li>工作区即磁盘上的文件集合。</li><li>版本区(版本库)即<code>.git</code>文件</li><li>版本库 = 暂存区(stage) + 分支(master) + 指针Head  <ul><li>以我使用最频繁的git命令为例，即提交到github为例。</li><li><code>git init</code> 原本本地仓库只包含着工作区，这是最常见的工作状态。此时，<code>git init</code>一下，表示在本地区域创建了一个<code>.git</code>文件,版本区建立。</li><li><code>git add .</code> 表示把工作区的所有文件全部提交到版本区里面的<strong>暂存区</strong></li><li>当然你也可以通过 <code>git add ./xxx/</code> 一条一条分批添加到暂存区。</li><li><code>git commit -m &quot;xxx&quot;</code> 把暂存区的<strong>所有</strong>文件提交到仓库区，暂存区空空荡荡。</li><li><code>git remote add origin https://github.com/name/name_cangku.git</code> 把本地仓库与远程仓库连接起来。</li><li><code>git push -u origin master</code> 把仓库区的文件提交到远程仓库里。</li><li>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的。会有这样的信息<code>nothing to commit, working tree clean</code></li></ul></li></ul><h1 id="提交到GitHub"><a href="#提交到GitHub" class="headerlink" title="提交到GitHub"></a>提交到GitHub</h1><p>以前不熟悉git命令的时候，我提交项目到github上都是直接在网页上直接拉取文件提交上去的。有点羞耻。<br><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9c23ee01835ce?w=1501&h=643&f=png&s=101230" alt=""></p><ol><li><code>git init</code> .初始化，表示把这个文件变成Git可以管理的仓库。初始化后打开隐藏的文件可以看到有一个<code>.git</code>文件。</li><li><code>git add .</code> 后面的一个点表示把这个文件全部提交到暂存区。</li><li><code>git add ./readme.md/</code> 表示把这个文件下面的readme.md文件提交到暂存区。</li><li><code>git commit -m &quot;你要评论一点什么东西&quot;</code> <code>git  commit</code>的意思是把暂存区的全部文件提交到本地仓库。<code>-m</code>后接评论。</li><li><code>git remote add origin https://github.com/name/name_cangku.git</code>表示把你本地的仓库与GitHub上的远程仓库连接起来。只需要连接一次，以后提交的时候就可以不用谢这条命令了。<code>name</code>是你的github名字，<code>name_cangku</code>是你的仓库名。<strong>注意</strong>不要把后面的<code>.git</code>给漏掉了。因为我前面就是这么走过来的，绕了很多弯路。至于如何在GitHub上新建仓库，网上有很多教程，这里不再赘述了。</li><li><code>git push -u origin master</code> 把本地仓库提交到远程仓库。(最后一步)在你的远程仓库上刷新一下就可以看到你提交的文件了。</li><li>最后提到的是，在<code>git commit -m &quot;&quot;</code>之前，可以重复<code>git add</code>到暂存区。但是<code>git commit</code>会把你之前存放在暂存区的全部文件<strong>一次性</strong>全部提交到本地仓库。<h1 id="版本的回溯与前进"><a href="#版本的回溯与前进" class="headerlink" title="版本的回溯与前进"></a>版本的回溯与前进</h1>提交一个文件，有时候我们会提交很多次，在提交历史中，这样就产生了不同的版本。每次提交，Git会把他们串成一条时间线。如何回溯到我们提交的上一个版本，用<code>git reset --hard + 版本号</code>即可。 版本号可以用<code>git log</code>来查看，每一次的版本都会产生不一样的版本号。回溯之后，<code>git log</code>查看一下发现离我们最近的那个版本已经不见了。但是我还想要前进到最近的版本应该如何？只要<code>git reset --hard + 版本号</code>就行。退一步来讲，虽然我们可以通过<code>git reset --hard + 版本号</code>,靠记住版本号来可以在不同的版本之间来回穿梭。<strong>但是</strong>,有时候把版本号弄丢了怎么办？<code>git reflog</code>帮你记录了每一次的命令，这样就可以找到版本号了，这样你又可以通过<code>git reset</code>来版本穿梭了。<h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1></li></ol><ul><li>场景1：在工作区时，你修改了一个东西，你想撤销修改，<code>git checkout -- file</code>。廖雪峰老师指出撤销修改就回到和版本库一模一样的状态，即用版本库里的版本替换工作区的版本。 </li><li>场景2：你修改了一个内容，并且已经<code>git add</code>到暂存区了。想撤销怎么办？回溯版本，<code>git reset --hard + 版本号</code>,再<code>git checkout -- file</code>,替换工作区的版本。</li><li>场景3：你修改了一个内容，并且已经<code>git commit</code>到了<code>master</code>。跟场景2一样，版本回溯，再进行撤销。<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1></li><li>如果你<code>git add</code>一个文件到暂存区，然后在工作区又把文件删除了，Git会知道你删除了文件。如果你要把版本库里的文件删除，<code>git rm</code> 并且<code>git commit -m &quot;xxx&quot;</code>.</li><li>如果你误删了工作区的文件，怎么办？使用撤销命令，<code>git checkout --&lt;file&gt;</code>就可以。<strong>这再次证明了撤销命令其实就是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</strong><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1>分支，就像平行宇宙，廖雪峰老师如是说。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9e012079c4724?w=553&h=291&f=png&s=11351" alt=""><br>在没有其他分支插进来时，只有一个master主分支。每次你<code>git push -u origin master</code> 提交就是增加一条时间轴，master也会跟着移动。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9e11b1115072b?w=640&h=355&f=png&s=14404" alt=""><br>创建一个other的分支，通过other提交，虽然时间轴向前走了，但是主分支master还在原来的位置。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/28/16b9e1ce1d3c3b03?w=675&h=359&f=png&s=16995" alt=""></p><p>理论分析完，看一下命令怎么写。</p><ul><li>创建分支<code>other</code>,切换到<code>other</code>分支。<pre><code>git branch othergit checkout other</code></pre></li><li>查看当前所有分支<pre><code>git branch</code></pre>```</li></ul><ul><li>other<br>master<br>```<br>当前的分支会有一个<code>*</code></li></ul><ul><li>用<code>other</code>提交<pre><code>git add ./xxx/git commit -m &quot;xxx&quot;</code></pre></li><li><code>other</code>分支完成，切换回<code>master</code><pre><code>git checkout master</code></pre></li><li>此时，master分支上并没有<code>other</code>的文件，因为分支还没有合并。</li><li><strong>合并分支</strong><pre><code>git merge other</code></pre></li><li>合并完成之后，就可以在master分支上查看到文件了。</li><li>删除<code>other</code>分支。<pre><code>git branch -d other</code></pre></li><li>我由此想到，在以后工作中，应该是一个开放小组共同开发一个项目，组长会创建很多分支，每一个分支可以交给一个人去开发某一个功能，一个小组共同开发而且不会相互干扰。谁的功能完成了，可以由组长合并一下完成了的分支。哦，完美！<h2 id="解决合并分支问题"><a href="#解决合并分支问题" class="headerlink" title="解决合并分支问题"></a>解决合并分支问题</h2></li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/6/29/16ba102bd434afc6?w=610&h=393&f=png&s=17724" alt=""><br>假如有这样一种情况，分支<code>other</code>已经<code>commit</code>了，<strong>但是</strong>此时指针指回<code>master</code>时，并且<code>master</code>没有合并，而是<code>git add / commit</code> 提交了。这样，就产生了冲突，主分支<code>master</code>文件内容与<code>other</code>分支的内容不一样。合并不起来！所以，</p><ul><li>修改文件的内容，让其保持一致。</li><li><code>git add</code> <code>git commit</code> 提交。</li><li>分支合并了。<br><img src="https://user-gold-cdn.xitu.io/2019/6/29/16ba11a0ba73803d?w=658&h=349&f=png&s=21326" alt=""></li><li><code>git log --graph</code> 查看分支合并图</li><li><code>git branch -d other</code> 删除分支，任务结束。<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2></li><li><code>git merge --no-ff other</code> 禁用<code>Fast forward</code>模式，因为使用<code>Fast forward</code>模式，删除分支后，分支历史信息会丢失。</li></ul><h2 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h2><blockquote><p>廖雪峰老师提到，工作中每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。但如果你手上有分支在工作中，你的上级要你改另外的分支的BUG。你要把现在正在工作的分支保存下来，<code>git stash</code>,把当前工作现场“存储”起来，等以后恢复后继续工作。当你解决BUG后，<code>git checkout other</code>回到自己的分支。用<code>git stash list</code>查看你刚刚“存放”起来的工作去哪里了。此时你要恢复工作：</p></blockquote><ul><li><code>git stash apply</code>恢复却不删除<code>stash</code>内容，<code>git stash drop</code>删除<code>stash</code>内容。</li><li><code>git stash pop</code>恢复的同时把stash内容也删了.</li><li>此时，用<code>git stash list</code>查看，看不到任何<code>stash</code> 内容。  </li></ul><p><strong>总结：修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场</strong></p><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><ul><li><p><code>git branch -d + 分支</code>有可能会删除失败，因为Git会保护没有被合并的分支。</p></li><li><p><code>git branch -D + 分支</code> 强行删除，丢弃没被合并的分支。</p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2></li><li><p><code>git remote</code> 查看远程库的信息，会显示<code>origin</code>，远程仓库默认名称为<code>origin</code></p></li><li><p><code>git remote -v</code>显示更详细的信息 </p></li><li><p><code>git push -u origin master</code>推送<code>master</code>分支到<code>origin</code>远程仓库。</p></li><li><p><code>git push -u origin other</code> 推送<code>other</code>到<code>origin</code>远程仓库。</p><h2 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/29/16ba20c43f386f7c?w=520&h=313&f=png&s=12170" alt=""><br>产生上图的冲突时，</p></li><li><p><code>git pull</code> 把最新的提交从远程仓库中抓取下来，在本地合并，解决冲突。在进行<code>git pull</code></p></li><li><p>如果<code>git pull</code> 也失败了，还要指定分支之间的链接，这一步Git会提醒你怎么做。然后再<code>git pull</code>。              </p><blockquote><p><strong>廖雪峰老师的总结：多人协作的工作模式通常是这样：</strong></p></blockquote><ul><li><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p></li><li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code> 推送就能成功！</p></li><li><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><h2 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h2></li></ul></li><li><p><code>git rebase</code> 把分叉的提交历史“整理”成一条直线，看上去更直观.缺点是本地的分叉提交已经被修改过了。</p></li><li><p>最后在进行<code>git push -u origin master</code></p></li><li><p><code>rebase</code>的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><blockquote><p>比如一个APP要上线，通常在版本库中打一个标签(tag),<br>这样，就确定了打标签的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<br>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针。<br><code>tag</code>其实就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。比如<code>tag v2.1</code>就是把历史上的一个版本的东西叫做<code>v2.1</code></p></blockquote><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>步骤：</p></li><li><p><code>git branch</code>查看当前分支,<code>git checkout master</code>切换到<code>master</code>分支。</p></li><li><p><code>git tag &lt;name&gt;</code> 打标签，默认为<code>HEAD</code>。比如<code>git tag v1.0</code></p></li><li><p>默认标签是打在最新提交的<code>commit</code>上的。如果想要打标签在以前的<code>commit</code>上，要<code>git log</code>找到历史提交的<code>commit</code> id.</p></li><li><p>如果一个<code>commt id</code>是<code>du2n2d9</code>,执行<code>git tag v1.0 du2n2d9</code>就把这个版本打上了<code>v1.0</code>的标签了。</p></li><li><p><code>git tag</code> 查看所有标签，可以知道历史版本的<code>tag</code></p></li><li><p>标签不是按时间顺序列出，而是按字母排序的。</p></li><li><p><code>git show &lt;tagname&gt;</code> 查看标签信息。</p></li><li><p><code>git tag -a &lt;标签名&gt; -m &quot;&lt;说明&gt;&quot;</code>,创建带说明的标签。 <code>-a</code>指定标签名，<code>-m</code>指定说明文字。用<code>show</code>可以查看说明。</p><h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2></li><li><p><code>git tag -d v1.0</code> 删除标签。因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p></li><li><p><code>git push origin &lt;tagname&gt;</code> 推送某个标签到远程</p></li><li><p><code>git push origin --tags</code> 一次性推送全部尚未推送到远程的本地标签</p></li><li><p>如果标签推送到远程。<code>git tag -d v1.0</code> 先删除本地标签v1.0。<code>git push origin :refs/tags/v1.0</code>删除远程标签v1.0</p></li></ul><h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><ul><li><code>git config --global color.ui true</code>让Git显示颜色，会让命令输出看起来更醒目</li><li>忽略特殊文件<br>创建一个<code>.gitignore</code>文件，把需要忽略的文件名填进去。Git就会自动忽略这些文件。我也在学习中遇到过这样的问题，比如<code>node_modules</code>文件就可以忽略。</li><li><blockquote><p>忽略文件原则：忽略操作系统自动生成的文件，比如缩略图等；<br>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；<br>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</p></blockquote></li><li>强制提交已忽略的的文件。<code>git add -f &lt;file&gt;</code></li><li><code>git check-ignore -v &lt;file&gt;</code>检查为什么Git会忽略该文件。</li><li><strong>给Git命令配别名</strong>,这个有点骚，就是你以后想输入<code>git rebase</code>时,你给它一个“外号”，就叫它<code>git nb</code>。以后你可以通过<code>git nb</code>来代替<code>git rebase</code>。具体怎么转换可以去<a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732837407424" target="_blank" rel="noopener">廖雪峰老师的网站</a>看。因为水平有限，我觉得先把正常的Git命令搞清楚来就很不错了。<h1 id="常用Git命令总结"><a href="#常用Git命令总结" class="headerlink" title="常用Git命令总结"></a>常用Git命令总结</h1></li><li><code>git config --global user.name &quot;你的名字&quot;</code> 让你全部的<code>Git</code>仓库绑定你的名字</li><li><code>git config --global user.email &quot;你的邮箱&quot;</code> 让你全部的<code>Git</code>仓库绑定你的邮箱</li><li><code>git init</code> 初始化你的仓库</li><li><code>git add .</code> 把工作区的文件全部提交到暂存区</li><li><code>git add ./&lt;file&gt;/</code> 把工作区的<code>&lt;file&gt;</code>文件提交到暂存区</li><li><code>git commit -m &quot;xxx&quot;</code> 把暂存区的所有文件提交到仓库区，<strong>暂存区空空荡荡</strong></li><li><code>git remote add origin https://github.com/name/name_cangku.git</code> 把本地仓库与远程仓库连接起来</li><li><code>git push -u origin master</code> 把仓库区的主分支<code>master</code>提交到远程仓库里</li><li><code>git push -u origin &lt;其他分支&gt;</code> 把其他分支提交到远程仓库</li><li><code>git status</code>查看当前仓库的状态</li><li><code>git diff</code> 查看文件修改的具体内容</li><li><code>git log</code> 显示从最近到最远的提交历史</li><li><code>git clone + 仓库地址</code>下载克隆文件</li><li><code>git reset --hard + 版本号</code> 回溯版本，版本号在<code>commit</code>的时候与<code>master</code>跟随在一起</li><li><code>git reflog</code> 显示命令历史</li><li><code>git checkout -- &lt;file&gt;</code> 撤销命令，用版本库里的文件替换掉工作区的文件。我觉得就像是<code>Git</code>世界的<code>ctrl + z</code></li><li><code>git rm</code> 删除版本库的文件</li><li><code>git branch</code> 查看当前所有分支</li><li><code>git branch &lt;分支名字&gt;</code> 创建分支</li><li><code>git checkout &lt;分支名字&gt;</code> 切换到分支</li><li><code>git merge &lt;分支名字&gt;</code> 合并分支</li><li><code>git branch -d &lt;分支名字&gt;</code> 删除分支,有可能会删除失败，因为<code>Git</code>会保护没有被合并的分支</li><li><code>git branch -D + &lt;分支名字&gt;</code> 强行删除，丢弃没被合并的分支</li><li><code>git log --graph</code> 查看分支合并图</li><li><code>git merge --no-ff &lt;分支名字&gt;</code> 合并分支的时候禁用<code>Fast forward</code>模式,因为这个模式会丢失分支历史信息</li><li><code>git stash</code> 当有其他任务插进来时，把当前工作现场“存储”起来,以后恢复后继续工作</li><li><code>git stash list</code> 查看你刚刚“存放”起来的工作去哪里了</li><li><code>git stash apply</code> 恢复却不删除<code>stash</code>内容</li><li><code>git stash drop</code> 删除<code>stash</code>内容</li><li><code>git stash pop</code> 恢复的同时把stash内容也删了</li><li><code>git remote</code> 查看远程库的信息，会显示<code>origin</code>，远程仓库默认名称为<code>origin</code></li><li><code>git remote -v</code> 显示更详细的信息</li><li><code>git pull</code> 把最新的提交从远程仓库中抓取下来，在本地合并,和<code>git push</code>相反</li><li><code>git rebase</code> 把分叉的提交历史“整理”成一条直线，看上去更直观</li><li><code>git tag</code> 查看所有标签，可以知道历史版本的tag</li><li><code>git tag &lt;name&gt;</code> 打标签，默认为<code>HEAD</code>。比如<code>git tag v1.0</code></li><li><code>git tag &lt;tagName&gt; &lt;版本号&gt;</code> 把版本号打上标签，版本号就是<code>commit</code>时，跟在旁边的一串字母数字</li><li><code>git show &lt;tagName&gt;</code> 查看标签信息</li><li><code>git tag -a &lt;tagName&gt; -m &quot;&lt;说明&gt;&quot;</code> 创建带说明的标签。 <code>-a</code>指定标签名，<code>-m</code>指定说明文字</li><li><code>git tag -d &lt;tagName&gt;</code> 删除标签</li><li><code>git push origin &lt;tagname&gt;</code> 推送某个标签到远程</li><li><code>git push origin --tags</code> 一次性推送全部尚未推送到远程的本地标签</li><li><code>git push origin :refs/tags/&lt;tagname&gt;</code> 删除远程标签<code>&lt;tagname&gt;</code></li><li><code>git config --global color.ui true</code> 让Git显示颜色，会让命令输出看起来更醒目</li><li><code>git add -f &lt;file&gt;</code> 强制提交已忽略的的文件</li><li><code>git check-ignore -v &lt;file&gt;</code> 检查为什么Git会忽略该文件<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1>廖雪峰老师讲Git讲的通俗易懂，对小白很友好。认认真真花上两天时间去整理，会有所收获的。<a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖老师的个人网站传送门</a></li></ul><p>欢迎访问我的<a href="https://zhongjunhaoz.github.io/">个人博客</a>，定时分享技术文章，一起前端学习！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>仿网易云音乐微信小程序</title>
      <link href="/2019/10/20/fang-wang-yi-yun-yin-le-wei-xin-xiao-cheng-xu/"/>
      <url>/2019/10/20/fang-wang-yi-yun-yin-le-wei-xin-xiao-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="项目部分截图-Gif"><a href="#项目部分截图-Gif" class="headerlink" title="项目部分截图(Gif)"></a>项目部分截图(Gif)</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/24/16b89bbee707dd70?w=405&h=692&f=gif&s=3289476" alt=""><br><img src="https://user-gold-cdn.xitu.io/2019/6/24/16b89f9bc0492380?w=405&h=692&f=gif&s=3465695" alt=""><br><img src="https://user-gold-cdn.xitu.io/2019/6/24/16b89c4f8e1eccb5?w=405&h=692&f=gif&s=4980551" alt=""></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一阵子学习了微信小程序，为了巩固所学的知识和提高实战经验，决定自己手撸一款小程序。因为听歌一直在用网易云音乐，所以突发奇想就做一款仿网易云音乐的小程序吧！开发中遇到了很多在学习中没有遇到过的坑，也很感谢在我改不出BUG时给予帮助的老师同学！本着学习和分享的目的，写下以下的文字,希望能给<strong>初学小程序的你</strong>带来一点帮助,大佬轻点喷。</p><hr><h1 id="开发前准备"><a href="#开发前准备" class="headerlink" title="开发前准备"></a>开发前准备</h1><ul><li>VScode代码编辑器。</li><li>微信开发者工具</li><li>ios网易云音乐(V5.9.1版本)</li><li>酷狗音乐小程序(提供了一些思路)</li><li><a href="[http://musicapi.leanapp.cn/">网易云音乐API</a></li><li>(<a href="https://www.iconfont.cn" target="_blank" rel="noopener">阿里巴巴矢量图标库</a>)提供一些图标icon</li></ul><hr><h1 id="tabBar部分"><a href="#tabBar部分" class="headerlink" title="tabBar部分"></a>tabBar部分</h1><h2 id="自定义tabBar"><a href="#自定义tabBar" class="headerlink" title="自定义tabBar"></a><strong>自定义tabBar</strong></h2><p>一般在开发中，微信小程序给我们的tabBar就能满足需求。但是，有些特别的需求必须使用自定义tabBar才能满足。<br>比如tabBar实现半透明。那么，如何才能自定义tabBar呢？<br>    1.首先,在 app.json里的”tabBar”里声明<br>    <code>&quot;tabBar&quot;: {    &quot;custom&quot;: true    }</code><br>    2.接着在项目的根目录下新建一个<code>custom-tab-bar</code>文件夹。里面包含<code>index.wxml index.js index.json index.wxss</code>四个文件。更多细节参考<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html" target="_blank" rel="noopener">微信小程序文档</a><br><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8a44df06fca6e?w=511&h=229&f=png&s=66834" alt=""></p><pre><code>&lt;!-- index.html --&gt;&lt;!-- 自定义tabbar页面 --&gt;&lt;cover-view class=&quot;tab-bar&quot;&gt;   &lt;cover-view class=&quot;tab-bar-border&quot;&gt;&lt;/cover-view&gt;&lt;!--tabBal边框样式  --&gt;&lt;!-- 乐库tabbar --&gt;  &lt;cover-view class=&#39;tab-bar-item&#39; &gt;    &lt;cover-image src=&#39;../images/music.png&#39; hidden=&#39;{{isShow_index}}&#39; bindtap=&#39;switchTab_index&#39;&gt;&lt;/cover-image&gt;    &lt;cover-image src=&#39;../images/selected-music.png&#39; hidden=&#39;{{!isShow_index}}&#39; bindtap=&#39;switchTab_index&#39;&gt;&lt;/cover-image&gt;    &lt;cover-view style=&quot;color:{{isShow_index ? selectedColor : color}}&quot;&gt;乐库&lt;/cover-view&gt;  &lt;/cover-view&gt;&lt;!-- 播放tabbar --&gt;    &lt;cover-view class=&#39;tab-bar-item&#39; bindtap=&#39;switchTab_playing&#39;&gt;    &lt;cover-image src=&#39;../images/selected-playing.png&#39; hidden=&#39;{{isShow_playing}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-image src=&#39;../images/playing.png&#39; hidden=&#39;{{!isShow_playing}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-view&gt;&lt;/cover-view&gt;  &lt;/cover-view&gt;&lt;!-- 我的tabbar --&gt;    &lt;cover-view class=&#39;tab-bar-item&#39; bindtap=&#39;switchTab_me&#39;&gt;    &lt;cover-image src=&#39;../images/me.png&#39; hidden=&#39;{{isShow_me}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-image src=&#39;../images/selected-me.png&#39; hidden=&#39;{{!isShow_me}}&#39;&gt;&lt;/cover-image&gt;    &lt;cover-view style=&quot;color:{{isShow_me ? selectedColor : color}}&quot;&gt;我的&lt;/cover-view&gt;  &lt;/cover-view&gt;&lt;/cover-view&gt;</code></pre><pre><code>// index.jsComponent({  data: {    isShow_index:true,    isShow_playing:false,    isShow_me:false,    selected: 0, //首页    color: &quot;#8D8D8D&quot;,    selectedColor: &quot;#C62F2F&quot;,    list: [{      pagePath: &quot;/pages/index/index&quot;,      iconPath: &quot;/images/music.png&quot;,      selectedIconPath: &quot;/images/selected-music.png&quot;,      text: &quot;乐库&quot;    }, {      pagePath: &quot;/pages/love/love&quot;,        iconPath: &quot;/images/selected-playing.png&quot;,      selectedIconPath: &quot;/images/playing.png&quot;,      text: &quot;&quot;    },      {        pagePath: &quot;/pages/me/me&quot;,        iconPath: &quot;/images/me.png&quot;,        selectedIconPath: &quot;/images/selected-me.png&quot;,        text: &quot;我的&quot;      }]  },  methods: {    switchTab_index:function(){      wx.switchTab({        url:&#39;/pages/index/index&#39;      })      this.setData({        isShow_index: true,        isShow_me: false,        isShow_playing: false      })    },    switchTab_playing: function () {      wx.switchTab({        url: &#39;/pages/love/love&#39;      })      this.setData({        isShow_playing: true,        isShow_index: false,        isShow_me: false      })    },    switchTab_me: function () {      wx.switchTab({        url: &#39;/pages/me/me&#39;      })      this.setData({        isShow_me:true,        isShow_playing: false,        isShow_index: false      })    }  }})</code></pre><h2 id="tabBar半透明"><a href="#tabBar半透明" class="headerlink" title="tabBar半透明"></a><strong>tabBar半透明</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8a6ee63e9f2da?w=405&h=94&f=gif&s=538191" alt=""></p><pre><code>/* custom-tab-bar/index.wxss */.tab-bar {  height:7%;  position: fixed;  bottom: 0;  left: 0;  right: 0;  height: 48px;  background:#FAFBFD;  opacity: 0.93;  display: flex;  padding-bottom: env(safe-area-inset-bottom);}</code></pre><h1 id="API封装"><a href="#API封装" class="headerlink" title="API封装"></a>API封装</h1><p>一般我们https请求都是通过<code>wx.request</code>来请求,但是这种方法只能请求一次数据,如果首页用<code>wx.request</code>来请求的话,代码看起来会很冗长和杂乱。不仅自己容易搞糊涂,其他人看代码时也会很累。因此为了代码的整洁干净,我在这里新建了一个文件专门存放API。一般在根目录下的<code>utils</code>文件夹下新建一个<code>api.js</code>,但我在根目录下新建了文件夹<code>API</code>,里面包含<code>api.js</code>。</p><pre><code>// api.jsconst API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const request = (url, data) =&gt; {   let _url = API_BASE_URL  + url;  return new Promise((resolve, reject) =&gt; {    wx.request({      url: _url,      method: &quot;get&quot;,      data: data,      header: {        &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;      },      success(request) {        resolve(request.data)      },      fail(error) {        reject(error)      }    })  });}module.exports ={  gethotsongs:(data) =&gt;{    return request(&#39;/search/hot&#39;,data)//热搜接口  },  searchSuggest:(data)=&gt;{    return request(&#39;/search/suggest&#39;,data)//搜索建议接口  },  searchResult:(data)=&gt;{    return request(&#39;/search&#39;,data)//搜索结果接口  },  getBanner:(data)=&gt;{    return request(&#39;/banner&#39;,data)//个性推荐轮播  },  getsongsheet:(data)=&gt;{    return request(&#39;/top/playlist&#39;,data)//热门歌单接口  },  getNewSong:(data)=&gt;{    return request(&#39;/personalized/newsong&#39;,data)//最新音乐接口  },  getDjRadios:(data)=&gt;{    return request(&#39;/dj/recommend&#39;,data)//电台推荐接口  },  getProgramRecommend:(data)=&gt;{    return request(&#39;/program/recommend&#39;,data)//推荐节目接口  },  getRecommendType:(data)=&gt;{    return request(&#39;/dj/recommend/type&#39;,data)//所有电台分类推荐  },  getRecommendMV:(data)=&gt;{    return request(&#39;/personalized/mv&#39;,data)//推荐MV  },  getNewMv:(data)=&gt;{    return request(&#39;/mv/first&#39;,data)//最新MV  },  getNewEst:(data)=&gt;{    return request(&#39;/album/newest&#39;,data)//最新专辑  },  getTopList:(data)=&gt;{    return request(&#39;/top/list&#39;,data)//排行榜  },  getDjList:(data)=&gt;{    return request(&#39;/dj/catelist&#39;,data) //电台分类  },  getPay:(data)=&gt;{    return request(&#39;/dj/paygift&#39;,data)//付费精品  },  getSonger:(data)=&gt;{    return request(&#39;/toplist/artist&#39;,data)//歌手排行  }}</code></pre><p><code>api.js</code>只能通过<code>module.exports</code>来暴露,那个页面要数据就从这拿。如果在哪个页面要用到它,还需要在头部引入一下:</p><p><code>const API = require(&#39;../../API/api&#39;)</code></p><p>以个性推荐轮播图为例，</p><pre><code>  getBanner: function() {    API.getBanner({      type: 2    }).then(res =&gt; {      if (res.code === 200) { //更加严谨        this.setData({          banner: res.banners        })      }    })  }</code></pre><p>  这样就把请求到的数据存储到<code>banner</code>中了。</p><hr><h1 id="搜索部分"><a href="#搜索部分" class="headerlink" title="搜索部分"></a>搜索部分</h1><h2 id="输入框样式"><a href="#输入框样式" class="headerlink" title="输入框样式"></a><strong>输入框样式</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8da289aa52854?w=436&h=97&f=png&s=7182" alt=""><br>我这里是引入了<code>WEUI</code>的样式，<br>1.下载<code>weui.wxss</code>,链接我找不到了，所以我放上了我的<a href="https://github.com/zhongjunhaoz/CloudMusic/blob/master/weui.wxss" target="_blank" rel="noopener">github</a>上的<code>weui.wxss</code>。<br>2.把下载好的<code>weui.wxss</code>放到根目录下。<br>3.在<code>app.wxss</code>中<code>@import &quot;weui.wxss&quot;;</code>引入一下就可以使用微信提供给我们的样式了。<br>4.<a href="https://weui.io/" target="_blank" rel="noopener"><code>WeUI</code>样式库</a></p><h2 id="热门搜索"><a href="#热门搜索" class="headerlink" title="热门搜索"></a><strong>热门搜索</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8daeda7452a8f?w=415&h=404&f=png&s=31051" alt=""><br>上面已经提到我从<code>api.js</code>中拿数据。</p><pre><code> // 从接口到获取到数据导入到hotsongs  gethotsongs() {    API.gethotsongs({ type: &#39;new&#39; }).then(res =&gt; {      wx.hideLoading()      if (res.code === 200) {  //严谨        this.setData({          hotsongs: res.result.hots        })      }    })  }</code></pre><h2 id="搜索历史"><a href="#搜索历史" class="headerlink" title="搜索历史"></a><strong>搜索历史</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dba723508edc?w=419&h=741&f=png&s=42298" alt=""><br>思路：当在输入框输入完成后–&gt;失去焦点–&gt; 利用<code>wx.setStorageSync</code>存进缓存中–&gt;<code>wx.getStorageSync</code>获取到并把它打印出来。</p><pre><code>  // input失去焦点函数  routeSearchResPage: function(e) {    console.log(e.detail.value)    let history = wx.getStorageSync(&quot;history&quot;) || [];    history.push(this.data.searchKey)    wx.setStorageSync(&quot;history&quot;, history);  },//每次显示变动就去获取缓存，给history，并for出来。  onShow: function () {    this.setData({      history: wx.getStorageSync(&quot;history&quot;) || []    })  },</code></pre><h2 id="清空搜索历史"><a href="#清空搜索历史" class="headerlink" title="清空搜索历史"></a><strong>清空搜索历史</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dbe42c2c2c33?w=405&h=487&f=gif&s=119001" alt=""><br>思路：×图标绑定事件-&gt;呼出对话框<code>wx.showModal</code>-&gt;确定则把<code>history</code>赋值为空</p><pre><code>    // 清空page对象data的history数组 重置缓存为[]  clearHistory: function() {    const that = this;    wx.showModal({      content: &#39;确认清空全部历史记录&#39;,      cancelColor:&#39;#DE655C&#39;,      confirmColor: &#39;#DE655C&#39;,      success(res) {        if (res.confirm) {          that.setData({            history: []          })          wx.setStorageSync(&quot;history&quot;, []) //把空数组给history,即清空历史记录        } else if (res.cancel) {        }      }    })  },</code></pre><h2 id="实时搜索建议"><a href="#实时搜索建议" class="headerlink" title="实时搜索建议"></a><strong>实时搜索建议</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dc5e9059003f?w=399&h=707&f=gif&s=62309" alt=""><br>思路：实时获取输入框的值-&gt;把值传给搜索建议API，发起网络请求-&gt;请求之后拿到搜索建议-&gt;打印结果并隐藏其他组件只保留搜索建议的组件(类似于Vue里的v-show)</p><pre><code> //获取input文本并且实时搜索,动态隐藏组件  getsearchKey:function(e){    console.log(e.detail.value) //打印出输入框的值    let that = this;    if(e.detail.cursor != that.data.cursor){ //实时获取输入框的值      that.setData({        searchKey: e.detail.value      })    }    if(e.value!=&quot;&quot;){ //组件的显示与隐藏      that.setData({        showView: false      })    } else{      that.setData({        showView: &quot;&quot;      })    }    if(e.detail.value!=&quot;&quot;){ //解决 如果输入框的值为空时，传值给搜索建议，会报错的bug      that.searchSuggest();    }    }</code></pre><pre><code>  // 搜索建议  searchSuggest(){    API.searchSuggest({ keywords: this.data.searchKey ,type:&#39;mobile&#39;}).then(res=&gt;{      if(res.code === 200){        this.setData({          searchsuggest:res.result.allMatch        })      }    })  }</code></pre><h2 id="点击热搜或历史，执行搜索"><a href="#点击热搜或历史，执行搜索" class="headerlink" title="点击热搜或历史，执行搜索"></a>点击热搜或历史，执行搜索</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8eefd6bdf126f?w=403&h=703&f=gif&s=257246" alt=""><br>思路：关键是<code>event</code>,点击通过<code>e.currentTarget.dataset.value</code>拿到所点击的值，再交给其他方法执行搜索行为。</p><pre><code>// 点击热门搜索值或搜索历史，填入搜索框  fill_value:function(e){    let that = this;    console.log(history)    // console.log(e.currentTarget.dataset.value)    that.setData({      searchKey: e.currentTarget.dataset.value,//点击吧=把值给searchKey,让他去搜索      inputValue: e.currentTarget.dataset.value,//在输入框显示内容      showView:false,//给false值，隐藏 热搜和历史 界面      showsongresult: false, //给false值，隐藏搜索建议页面    })    that.searchResult(); //执行搜索功能  }</code></pre><h2 id="搜索结果"><a href="#搜索结果" class="headerlink" title="搜索结果"></a><strong>搜索结果</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8dd6660f63f9a?w=399&h=707&f=gif&s=63353" alt=""><br>思路：输入结束-&gt;确认键-&gt;调用<code>searchResult</code>请求到结果</p><pre><code>// 搜索完成点击确认  searchover:function(){    let that = this;    that.setData({      showsongresult: false    })    that.searchResult();  }</code></pre><pre><code>   // 搜索结果  searchResult(){    console.log(this.data.searchKey)    API.searchResult({ keywords: this.data.searchKey, type: 1, limit: 100, offset:2 }).then(res =&gt; {      if (res.code === 200) {        this.setData({          searchresult: res.result.songs        })      }    })  }</code></pre><hr><h1 id="乐库部分"><a href="#乐库部分" class="headerlink" title="乐库部分"></a>乐库部分</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8deb716cb19fc?w=1049&h=734&f=png&s=483647" alt=""><br>乐库部分其实没什么逻辑很难的部分，以结构和样式为主，在这里就不赘述了。可以到我的<a href="https://github.com/zhongjunhaoz/CloudMusic" target="_blank" rel="noopener">github</a>上查看。在这里分享一些小功能的实现和踩到的坑。</p><h2 id="个性推荐，主播电台切换"><a href="#个性推荐，主播电台切换" class="headerlink" title="个性推荐，主播电台切换"></a><strong>个性推荐，主播电台切换</strong></h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8e03ef5ad0dbc?w=403&h=669&f=gif&s=1612390" alt=""><br>1.个性推荐和主播电台是两个<code>swiper-item</code>所以他们才可以左右滑动，就像轮播图一样，不过轮播图放的是图片，而这里放的是整个页面。<br>2.我要实现的效果是左右滑动的同时，<code>个性推荐</code>和<code>主播电台</code>下面的白色方块也要跟着滑动。<br><strong>1. 第一种方法</strong><br>给包裹两个<code>swiper-item</code>的<code>swiper</code>添加一个<code>bindchange=&quot;changeline&quot;</code>事件，把事件对象<code>event</code>打印出来发现，<code>console.log(e.detail.current)</code>,当我们左右滑动的时候<code>cuurrent</code>的值会在<code>0</code>和<code>1</code>之间切换。所以我给白色方块添加</p><pre><code>class=&quot;{{changeline?'swiper_header_line_before':'swiper_header_line_after'}}&quot;</code></pre><pre><code>    if(e.detail.current === 0){    this.setData({       changeline:true      })    }else{    this.setData({       changeline:false      })    }</code></pre><p>当<code>current</code>为0，即页面在个性推荐时，让<code>changeline</code>为<code>true</code>;当<code>current</code>为1，即页面在主播电台时，让<code>changeline</code>为<code>false</code>;为<code>true</code>时，给白色方块加持<code>swiper_header_line_before</code>的样式，为<code>false</code>时，加持<code>swiper_header_line_after</code>的样式。这样就可以跟随<code>swiper-item</code>的滑动而切换了。<strong>但是，这种切换方式太僵硬了</strong>，没有那种流畅的切换效果，而且不适合多<code>swiper-item</code>页面。<br><strong>2. 第二种方法</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8e8d9a71ab12a?w=436&h=295&f=png&s=23978" alt=""><br>让一半宽度，四分之一宽度设置为变量是为了兼容不同的手机型号。因为写死数据肯定会有BUG，所以才要计算宽度。</p><pre><code>&lt;view class=&quot;weui-navbar-slider&quot; style=&quot;transform:translateX({{slideOffset}}px);&quot;&gt;&lt;/view&gt;</code></pre><pre><code>.weui-navbar-slider{  width:28px;  height: 5px;  background: #ffffff;  border-radius:10rpx;  transition: transform .6s; }</code></pre><p><code>slideOffset</code>为变量，动态接受从<code>data</code>传来的数据。</p><pre><code>onLoad:function(){    wx.getSystemInfo({      success: function (res) {        // console.log(res.windowWidth)        // console.log(res.windowWidth / 2 / 2)        half = res.windowWidth / 2 ;        quarter = res.windowWidth / 2 / 2;        that.setData({          slideOffset: quarter - 14 //onLoad的时候让 quarter - 14 给slideOffset，即一开始就让他在个性推荐的下面，否则onLoad的时候一开始在0的位置        })      }    })}  changeline:function(e){    // console.log(e)    // console.log(e.detail.current)    let current = e.detail.current; //获取swiper的current值    if(e.detail.current === 0){      this.setData({        slideOffset: quarter - 14      })    }    if(e.detail.current === 1){      this.setData({        slideOffset: (quarter - 14) + half      })    }    if(e.detail.current === null){      this.setData({        slideOffset: quarter - 14      })    }  }</code></pre><h2 id="MV播放"><a href="#MV播放" class="headerlink" title="MV播放"></a>MV播放</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8ea3d1f4e6c01?w=403&h=669&f=gif&s=2204017" alt=""><br>主要是结构和样式，我直接上代码了。</p><pre><code>&lt;!-- play_mv.wxml --&gt;&lt;view class=&quot;mv_box&quot;&gt;    &lt;video src=&quot;{{mv.brs['480']}}&quot; class=&quot;mv&quot; autoplay=&quot;{{autoplay}}&quot; loop=&quot;{{loop}}&quot; direction=&quot;{{0}}&quot; show-fullscreen-btn=&quot;{{showfullscreenbtn}}&quot;    show-center-play-btn=&quot;{{showcenterplaybtn}}&quot; enable-progress-gesture=&quot;{{enableprogressgesture}}&quot; show-mute-btn=&quot;{{showmutebtn}}&quot; title=&quot;{{mv.name}}&quot;    play-btn-position=&quot;{{center}}&quot; object-fit=&quot;{{objectfit}}&quot;&gt;&lt;/video&gt;&lt;/view&gt;&lt;view class=&quot;mv_name&quot;&gt;{{mv.name}}&lt;/view&gt;&lt;view class=&quot;mv_time&quot;&gt; 发行:  {{mv.publishTime}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_times&quot;&gt;播放次数:  {{mv.playCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc&quot;&gt;{{mv.desc}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;点赞: {{mv.likeCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;收藏: {{mv.subCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;评论: {{mv.commentCount}}&lt;/view&gt;&lt;view class=&quot;mv_time mv_desc mv_other&quot;&gt;分享: {{mv.shareCount}}&lt;/view&gt;</code></pre><pre><code>/* play/play_mv.wxss */.mv_box{    width: 100%;    height: 480rpx;    margin-top:-2rpx;}.mv{    width: 100%;    height: 100%;    border-radius:15rpx;}.mv_name{    margin-top:20rpx;    margin-left:20rpx;}.mv_time{    font-size: 12px;    margin-left:20rpx;    color:#979798;    display:initial;}.mv_times{    margin-left: 100rpx;}.mv_desc{    display: block;    color:#6A6B6C;}.mv_other{    display: block;}</code></pre><pre><code>// play_mv.jsconst API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const app = getApp();Page({  data: {    mv: [],    autoplay: true,    loop: true,    showfullscreenbtn: true,    showcenterplaybtn: true,    enableprogressgesture: true,    showmutebtn: true,    objectfit: &#39;contain&#39;,  },  onLoad: function (options) {    // console.log(mv_url);    const mvid = options.id; // onLoad()后获取到歌曲视频之类的id    // 请求MV的地址，失败则播放出错，成功则传值给createBgAudio(后台播放管理器，让其后台播放)    wx.request({      url: API_BASE_URL + &#39;/mv/detail&#39;,      data: {        mvid: mvid          },      success: res =&gt; {        console.log(res.data.data.brs[&#39;480&#39;])        console.log(&#39;歌曲音频url:&#39;, res)        if (res.data.data.brs === null) {  //如果是MV 电台 广告 之类的就提示播放出错，并返回首页          console.log(&#39;播放出错&#39;)          wx.showModal({            content: &#39;服务器开了点小差~~&#39;,            cancelColor: &#39;#DE655C&#39;,            confirmColor: &#39;#DE655C&#39;,            showCancel: false,            confirmText: &#39;返回&#39;,            complete() {              wx.switchTab({                url: &#39;/pages/index/index&#39;              })            }          })        } else {          this.setData({            mv: res.data.data          })        }      }    })  },})</code></pre><h2 id="歌手榜"><a href="#歌手榜" class="headerlink" title="歌手榜"></a>歌手榜</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8eaed5f5e5b3b?w=795&h=695&f=png&s=242469" alt=""></p><pre><code>// 歌手榜的jsconst API = require(&#39;../../API/api&#39;);const app = getApp();Page({  data: {    songers: [], //歌手榜  },  onLoad: function (options) {    wx.showLoading({      title: &#39;加载中&#39;,    });    this.getSonger();  },  getSonger: function () {    API.getSonger({}).then(res =&gt; {      wx.hideLoading()      this.setData({        songers: res.list.artists.slice(0, 100)      })    })  },  handleSheet: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性    const sheetId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面      url: `./moremore_songer?id=${sheetId}`    })  },})</code></pre><pre><code>&lt;!-- 歌手榜结构 --&gt;&lt;view wx:for=&quot;{{songers}}&quot; wx:key=&quot;&quot; class=&#39;songer_box&#39; data-id=&quot;{{item.id}}&quot; bindtap=&#39;handleSheet&#39;&gt;  &lt;view class=&#39;songer_index_box&#39;&gt;    &lt;text class=&#39;songer_index&#39;&gt;{{index + 1}}&lt;/text&gt;  &lt;/view&gt;  &lt;view class=&#39;songer_img_box&#39;&gt;  &lt;image src=&quot;{{item.picUrl}}&quot; class=&#39;songer_img&#39;&gt;&lt;/image&gt;  &lt;/view&gt;  &lt;view class=&#39;songer_name_box&#39;&gt;  &lt;text class=&#39;songer_name&#39;&gt;{{item.name}}&lt;/text&gt;  &lt;text class=&#39;songer_score&#39;&gt;{{item.score}}热度&lt;/text&gt;  &lt;/view&gt;&lt;/view&gt;</code></pre><pre><code>// 歌手下级路由歌曲列表const API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const app = getApp();Page({  data: {    songList: []  },  onLoad: function (options) {    wx.showLoading({      title: &#39;加载中&#39;,    });    const sheetId = options.id;    wx.request({      url: API_BASE_URL + &#39;/artists&#39;,      data: {        id: sheetId          },      success: res =&gt; {        const waitForPlay = new Array;        for (let i = 0; i &lt;= res.data.hotSongs.length - 1; i++) { //循环打印出其id          waitForPlay.push(res.data.hotSongs[i].id) //循环push ID 到waitForPlay数组          app.globalData.waitForPlaying = waitForPlay  //让waitForPlay数组给全局数组          // console.log(app.globalData.waitForPlaying)        }        wx.hideLoading()        console.log(res.data.hotSongs)        this.setData({          songList: res.data.hotSongs        })      }    })  },  handlePlayAudio: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性    const audioId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面      url: `../../play/play?id=${audioId}`    })  }})</code></pre><pre><code>&lt;!-- more/more_songer/moremore_songer.wxml歌手下面的歌曲 --&gt;&lt;view class=&#39;search_result_songs&#39;&gt;  &lt;view wx:for=&quot;{{songList}}&quot; wx:key=&quot;&quot; class=&#39;search_result_song_item songer_box&#39; data-id=&quot;{{item.id}}&quot; bindtap=&#39;handlePlayAudio&#39;&gt;    &lt;view class=&#39;songer_index_box&#39;&gt;      &lt;text class=&#39;songer_index&#39;&gt;{{index + 1}}&lt;/text&gt;    &lt;/view&gt;    &lt;view class=&#39;songer_img_box&#39;&gt;      &lt;view class=&#39;search_result_song_song_name&#39;&gt;{{item.name}}&lt;/view&gt;      &lt;view class=&#39;search_result_song_song_art-album&#39;&gt;{{item.ar[0].name}} - {{item.al.name}}&lt;/view&gt;    &lt;/view&gt;  &lt;/view&gt;&lt;/view&gt;</code></pre><h2 id="推荐歌单"><a href="#推荐歌单" class="headerlink" title="推荐歌单"></a>推荐歌单</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8eb96b06ef0b4?w=800&h=642&f=png&s=373779" alt=""><br>因为样式与排行榜类似，所以只放出图片，源码可以到我的<a href="https://github.com/zhongjunhaoz/CloudMusic/tree/master/more/more_sheet" target="_blank" rel="noopener">github</a>上查看。</p><h2 id="榜单排行"><a href="#榜单排行" class="headerlink" title="榜单排行"></a>榜单排行</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8ebf82357b4e6?w=735&h=623&f=png&s=222179" alt=""><br><a href="https://github.com/zhongjunhaoz/CloudMusic/tree/master/more" target="_blank" rel="noopener">请查看源码</a></p><h2 id="换一换功能"><a href="#换一换功能" class="headerlink" title="换一换功能"></a>换一换功能</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8ec5afa3172e5?w=403&h=386&f=gif&s=301154" alt=""><br>思路：绑定点击事件-&gt;选取随机的三个数-&gt;给空值-&gt;push三个随机数进数组中-&gt;重新赋值。</p><pre><code>  // 换一换  change_1:function(){    let maxNum = this.data.more_recommend_create.length  //计算数据长度    let r1 = parseInt(Math.random() * (maxNum - 0) + 0); //取【0-数据长度】内的整数随机数    let r2 = parseInt(Math.random() * (maxNum - 0) + 0);    let r3 = parseInt(Math.random() * (maxNum - 0) + 0);    this.setData({      recommend_create: []    })    //重新取3组数据    this.data.recommend_create.push(this.data.more_recommend_create[r1])    this.data.recommend_create.push(this.data.more_recommend_create[r2])    this.data.recommend_create.push(this.data.more_recommend_create[r3])    //重新赋值    this.setData({      recommend_create: this.data.recommend_create    })  }</code></pre><h1 id="播放界面"><a href="#播放界面" class="headerlink" title="播放界面"></a>播放界面</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8f088b494cb9c?w=403&h=703&f=gif&s=3753267" alt=""><br>图片太大，因此加快了播放。</p><h2 id="播放功能"><a href="#播放功能" class="headerlink" title="播放功能"></a>播放功能</h2><p><strong>思路：利用<code>data-id=&quot;&quot;</code>获取到歌曲ID放在<code>event</code>中-&gt; 通过<code>event</code>对象事件获取ID并跳转到播放页面 -&gt;<code>wx.request</code>获取到歌曲的音频地址及detail-&gt;背景音频管理器 <code>wx.getBackgroundAudioManager()</code>-&gt;播放</strong><br>以歌手榜下级路由歌曲列表为例，  </p><pre><code>&lt;view wx:for=&quot;{{songList}}&quot; wx:key=&quot;&quot; class=&#39;search_result_song_item songer_box&#39; data-id=&quot;{{item.id}}&quot; bindtap=&#39;handlePlayAudio&#39;&gt;</code></pre><pre><code>  handlePlayAudio: function (event) { //event 对象，自带，点击事件后触发，event有type,target，timeStamp，currentTarget属性    const audioId = event.currentTarget.dataset.id; //获取到event里面的歌曲id赋值给audioId    wx.navigateTo({                                 //获取到id带着完整url后跳转到play页面      url: `../../play/play?id=${audioId}`    })  }</code></pre><pre><code>  // play.jsconst API_BASE_URL = &#39;http://musicapi.leanapp.cn&#39;;const app = getApp();Page({  data: {    isPlay: &#39;&#39;,    song:[],    innerAudioContext: {},    show:true,    showLyric:true,    songid:[],    history_songId:[]  },  onLoad: function (options) {    const audioid = options.id; // onLoad()后获取到歌曲视频之类的id    this.play(audioid); //把从wxml获取到的值传给play()  },  play: function (audioid){    const audioId = audioid;    app.globalData.songId = audioId;  //让每一个要播放的歌曲ID给全局变量的songId    const innerAudioContext = wx.createInnerAudioContext();    this.setData({      innerAudioContext,      isPlay: true    })    // 请求歌曲音频的地址，失败则播放出错，成功则传值给createBgAudio(后台播放管理器，让其后台播放)    wx.request({      url: API_BASE_URL + &#39;/song/url&#39;,      data: {        id: audioId      },      success: res =&gt; {        if (res.data.data[0].url === null) {  //如果是MV 电台 广告 之类的就提示播放出错，并返回首页          wx.showModal({            content: &#39;服务器开了点小差~~&#39;,            cancelColor: &#39;#DE655C&#39;,            confirmColor: &#39;#DE655C&#39;,            showCancel: false,            confirmText: &#39;返回&#39;,            complete() {              wx.switchTab({                url: &#39;/pages/index/index&#39;              })            }          })        } else {          this.createBgAudio(res.data.data[0]);        }      }    })    //获取到歌曲音频，则显示出歌曲的名字，歌手的信息，即获取歌曲详情；如果失败，则播放出错。    wx.request({      url: API_BASE_URL + &#39;/song/detail&#39;,      data: {        ids: audioId    //必选参数ids      },      success: res =&gt; {        if (res.data.songs.length === 0) {          wx.showModal({            content: &#39;服务器开了点小差~~&#39;,            cancelColor: &#39;#DE655C&#39;,            confirmColor: &#39;#DE655C&#39;,            showCancel: false,            confirmText: &#39;返回&#39;,            complete() {              wx.switchTab({                url: &#39;/pages/index/index&#39;              })            }          })        } else {          this.setData({            song: res.data.songs[0],  //获取到歌曲的详细内容，传给song          })          app.globalData.songName = res.data.songs[0].name;        }      },    })  },  createBgAudio(res) {    const bgAudioManage = wx.getBackgroundAudioManager(); //获取全局唯一的背景音频管理器。并把它给实例bgAudioManage    app.globalData.bgAudioManage = bgAudioManage;         //把实例bgAudioManage(背景音频管理器) 给 全局    bgAudioManage.title = &#39;title&#39;;                        //把title 音频标题 给实例    bgAudioManage.src = res.url;                          // res.url 在createBgAudio 为 mp3音频  url为空，播放出错    const history_songId = this.data.history_songId    const historySong = {      id: app.globalData.songId,      songName:app.globalData.songName    }    history_songId.push(historySong)    bgAudioManage.onPlay(res =&gt; {                         // 监听背景音频播放事件      this.setData({        isPlay: true,        history_songId      })    });    bgAudioManage.onEnded(() =&gt; {                  //监听背景音乐自然结束事件，结束后自动播放下一首。自然结束，调用go_lastSong()函数，即歌曲结束自动播放下一首歌      this.go_lastSong();    })    wx.setStorageSync(&#39;historyId&#39;, history_songId); //把historyId存入缓存  },})</code></pre><h2 id="暂停-播放"><a href="#暂停-播放" class="headerlink" title="暂停/播放"></a>暂停/播放</h2><pre><code>    &lt;!-- 暂停播放图标 --&gt;  &lt;view class=&quot;play_suspend&quot;&gt;    &lt;view class=&quot;icon_playing&quot;&gt;&lt;image bindtap=&quot;handleToggleBGAudio&quot; src=&quot;../images/suspend.png&quot; hidden=&quot;{{!isPlay}}&quot; class=&quot;{{'img_play_suspend'}}&quot; /&gt;  &lt;!-- 暂停图标--&gt;    &lt;image bindtap=&quot;handleToggleBGAudio&quot; src=&quot;../images/play.png&quot; hidden=&quot;{{isPlay}}&quot; class=&quot;{{'img_play_suspend'}}&quot; /&gt;&lt;/view&gt; &lt;!--播放图标--&gt;  &lt;/view&gt;</code></pre><pre><code>  // 播放和暂停  handleToggleBGAudio() {    // const innerAudioContext = app.globalData.innerAudioContext;    const bgAudioManage = app.globalData.bgAudioManage;    const {isPlay} = this.data;    if (isPlay) {      bgAudioManage.pause();      // innerAudioContext.pause();handleToggleBGAudio    } else {      bgAudioManage.play();      // innerAudioContext.play();    }    this.setData({      isPlay: !isPlay    })    console.log(this.data.isPlay)  }</code></pre><h2 id="上一首-下一首-随机播放"><a href="#上一首-下一首-随机播放" class="headerlink" title="上一首/下一首(随机播放)"></a>上一首/下一首(随机播放)</h2><p>  <strong>思路：点击歌单或歌手页，获取到对应的歌单/歌手id-&gt;<code>wx.request</code>请求数据获取到所有的歌单内/歌手热门歌曲音频地址-&gt;给全局变量globalData-&gt;点击上一首/下一首随机获取到全局变量的一则数据-&gt;给play()方法-&gt;播放</strong></p><pre><code>  &lt;!--歌单--&gt;    onLoad: function (options) {    wx.showLoading({      title: &#39;加载中&#39;,    });    const sheetId = options.id;    wx.request({      url: API_BASE_URL + &#39;/playlist/detail&#39;,      data: {        id: sheetId          },      success: res =&gt; {        const waitForPlay = new Array;        for (let i = 0; i &lt;= res.data.playlist.trackIds.length - 1;i++){ //循环打印出其id          waitForPlay.push(res.data.playlist.trackIds[i].id) //循环push ID 到waitForPlay数组          app.globalData.waitForPlaying = waitForPlay  //让waitForPlay数组给全局数组        }        wx.hideLoading()        this.setData({          songList: res.data.playlist.tracks        })        }    })  }</code></pre><pre><code>  &lt;view class=&quot;icon_playing &quot;&gt;&lt;image src=&quot;../images/lastSong.png&quot; class=&quot; icon_play&quot; bindtap=&quot;go_lastSong&quot; /&gt;&lt;/view&gt;  &lt;view class=&quot;icon_playing &quot;&gt;&lt;image src=&quot;../images/nextSong.png&quot; class=&quot; icon_play&quot; bindtap=&quot;go_lastSong&quot; /&gt;&lt;/view&gt;</code></pre><pre><code>    go_lastSong:function(){     let that = this;    const lastSongId = app.globalData.waitForPlaying;    const songId = lastSongId[Math.floor(Math.random() * lastSongId.length)]; //随机选取lastSongId数组的一个元素    that.data.songid = songId;    this.play(songId)//传进play()方法中    app.globalData.songId=songId;  }</code></pre><h2 id="歌词-封面切换"><a href="#歌词-封面切换" class="headerlink" title="歌词/封面切换"></a>歌词/封面切换</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b8f5e9d2a1e22b?w=403&h=703&f=gif&s=1127200" alt=""><br>  因为网易云API的歌词接口崩溃，请求不到歌词，所以我只能把歌词写死为<code>纯音乐，请欣赏</code>。类似于<code>v-show</code>。</p><pre><code>   &lt;!-- 封面 --&gt;  &lt;!-- 一开始onload时,showLyric=true, 显示为转动的图标，点击图标，切换为歌词--&gt;  &lt;view class=&quot;sing-show&quot; bindtap=&quot;showLyric&quot; &gt;    &lt;view class=&quot;moveCircle {{isPlay ? 'play' : ''}}&quot; hidden=&quot;{{!showLyric}}&quot;&gt;      &lt;image src=&quot;{{song.al.picUrl}}&quot; class=&quot;coverImg {{isPlay ? 'play' : ''}}&quot; hidden=&quot;{{!showLyric}}&quot;/&gt;    &lt;/view&gt;    &lt;text  hidden=&quot;{{showLyric}}&quot; class=&quot;songLyric&quot;&gt;纯音乐，请欣赏&lt;/text&gt;  &lt;/view&gt;</code></pre><pre><code>    // 点击切换歌词和封面  showLyric(){    const {showLyric} = this.data;    this.setData({      showLyric: !showLyric    })  }</code></pre><h2 id="破产版的孤独星球动效"><a href="#破产版的孤独星球动效" class="headerlink" title="破产版的孤独星球动效"></a>破产版的孤独星球动效</h2><p><img src="https://user-gold-cdn.xitu.io/2019/6/25/16b8f4e771e9a04d?w=403&h=703&f=gif&s=1629412" alt=""><br>封面旋转：</p><pre><code>@keyframes rotate {  0%{    transform: rotate(0);  }  100%{    transform: rotate(360deg);  }}</code></pre><p>扩散的圆形线条：<br>其实就是外面套一个盒子，盒子宽高变大以及透明度逐渐变低。</p><pre><code>@keyframes moveCircle {  0%{    width: 400rpx;    height: 400rpx;    border: 1px solid rgba(255, 255, 255, 1)  }  30%{    width: 510rpx;    height: 510rpx;    border: 1px solid rgba(255, 255, 255, 0.8)  }  50%{    width: 610rpx;    height: 610rpx;    border: 1px solid rgba(255, 255, 255, 0.6)  }  80%{    width: 700rpx;    height: 700rpx;    border: 1px solid rgba(255, 255, 255, 0.4)  }  99%{    width: 375px;    height: 375px;    border: 1px solid rgba(255, 255, 255, 0.1)  }  100%{    width: 0px;    height: 0px;    border: 1px solid rgba(255, 255, 255, 0)  }}</code></pre><h2 id="背景毛玻璃"><a href="#背景毛玻璃" class="headerlink" title="背景毛玻璃"></a>背景毛玻璃</h2><pre><code>&lt;!-- play.wxml --&gt;&lt;image src=&quot;{{song.al.picUrl}}&quot; class=&quot;background_img&quot; &gt;&lt;/image&gt;</code></pre><pre><code>/* 播放界面毛玻璃效果 */.background_img{   position: fixed;  top: 0;  left: 0;  bottom: 0;  width: 100%;  height: 100%;  filter: blur(20px);  z-index: -1;  transform: scale(1.5); /*和网易云音乐对比了一下，发现也是放大1.5倍*/}</code></pre><hr><h1 id="播放tabBar"><a href="#播放tabBar" class="headerlink" title="播放tabBar"></a>播放tabBar</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b8f674f2bdc7a5?w=403&h=731&f=gif&s=1441605" alt=""><br>思路是参考酷狗音乐小程序。这个tabBar的js，wxml与播放功能界面的js，wxml相同。因为音乐播放是用<code>wx.getBackgroundAudioManager()</code>背景音频播放器管理的，所以才能同步。</p><hr><h1 id="我的tabBar"><a href="#我的tabBar" class="headerlink" title="我的tabBar"></a>我的tabBar</h1><p><img src="https://user-gold-cdn.xitu.io/2019/6/26/16b8f828b086f094?w=418&h=735&f=png&s=154747" alt=""></p><h2 id="播放历史"><a href="#播放历史" class="headerlink" title="播放历史"></a>播放历史</h2><p>思路：play.js中一旦播放成功就把歌名及歌曲ID传入全局变量-&gt;push到play.js里的数组中-&gt;<code>wx.setStorageSync</code>把数据存入缓存-&gt;在需要的页面<code>wx.getStorageSync</code>获取到缓存。</p><pre><code>&lt;!--play.js--&gt;const history_songId = this.data.history_songIdconst historySong = {      // id: res.id      id: app.globalData.songId,      songName:app.globalData.songName    }    history_songId.push(historySong)    wx.setStorageSync(&#39;historyId&#39;, history_songId); //把historyId存入缓存</code></pre><pre><code>&lt;!--me.js--&gt; onShow:function(){    var history = wx.getStorageSync(&#39;historyId&#39;);    // console.log(history)     this.setData({      hidden:true,      //  historyId: app.globalData.songName       historyId: history    })    console.log(this.data.historyId)  }</code></pre><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>  做项目的过程总的来说痛并快乐，因为改不出BUG的样子真的很狼狈，但实现了某一个功能的那一刻真的很欣慰。再次感谢给予帮助的老师同学。如果你喜欢这篇文章或者可以帮到你，不妨点个赞吧！同时也非常希望看到这篇文章的你在下方给出建议！最后奉上<a href="https://github.com/zhongjunhaoz/CloudMusic" target="_blank" rel="noopener"><strong>源码</strong></a>，有需要的可以自取。最后，说点题外话，因为我是2020届毕业生，现在面临实习压力，有没有大佬捞一下。</p><p>  欢迎访问我的<a href="https://zhongjunhaoz.github.io/">个人博客</a>，定时分享技术文章，一起前端学习！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
